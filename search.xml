<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>SPI机制</title>
    <url>/blog/2024/12/29/Java/Spring/SPI%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="什么是-SPI-机制？">什么是 SPI 机制？</h2>
<p>在面向的对象的设计里，一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候能不在程序里动态指明，这就需要一种服务发现机制。</p>
<p>SPI （Service Provider Interface）是专门提供给服务提供者或者扩展框架功能的开发者去使用的一个接口，SPI 将服务接口和具体的服务实现分离开来，将服务调用方和服务实现者解耦，能够提升程序的扩展性、可维护性。修改或者替换服务实现并不需要修改调用方。</p>
<p><img src="10.png" alt=""></p>
<p><img src="9.png" alt=""></p>
<h2 id="API-与-SPI-区别">API 与 SPI 区别</h2>
<p><img src="2.png" alt=""></p>
<p><img src="3.png" alt=""></p>
<table>
<thead>
<tr>
<th>区别</th>
<th>API</th>
<th>SPI</th>
</tr>
</thead>
<tbody>
<tr>
<td>存在位置</td>
<td>API 依赖的接口位于实现者的包中</td>
<td>SPI 依赖的接口在调用方的包中</td>
</tr>
<tr>
<td>针对对象</td>
<td>API 通常是面向最终用户或外部系统的，提供了可直接使用的功能</td>
<td>SPI 更多是面向系统开发者，为他们提供一种将新服务或插件加入系统的方式</td>
</tr>
<tr>
<td>目的</td>
<td>API 的主要目的是提供接口供外界访问和使用特定的功能或数据</td>
<td>SPI 则是为了提供一个标准，允许第三方开发者实现并插入新的服务</td>
</tr>
<tr>
<td>定义方式</td>
<td>API 是由开发者主动编写并公开给其他开发者使用的</td>
<td>SPI 是由框架或库提供方定义的接口，供第三方开发者实现</td>
</tr>
<tr>
<td>调用方式</td>
<td>API 是通过直接调用接口的方法来使用功能</td>
<td>SPI 是通过配置文件来指定具体的实现类，然后由框架或库自动加载和调用</td>
</tr>
<tr>
<td>灵活性</td>
<td>API 的实现类必须在编译时就确定，无法动态替换</td>
<td>SPI 的实现类可以在运行时根据配置文件的内容进行动态加载和替换</td>
</tr>
<tr>
<td>依赖关系</td>
<td>API 是被调用方依赖的，即应用程序需要引入 API 所在的库才能使用其功能</td>
<td>SPI 是调用方依赖的，即框架或库需要引入第三方实现类的库才能加载和调用</td>
</tr>
</tbody>
</table>
<h2 id="SPI-优缺点">SPI 优缺点</h2>
<p><strong>优点</strong></p>
<p>使用 Java SPI 机制的优势是实现解耦，使得第三方服务模块的装配控制的逻辑与调用者的业务代码分离，而不是耦合在一起。应用程序可以根据实际业务情况启用框架扩展或替换框架组件。</p>
<p><strong>缺点</strong></p>
<ol>
<li>不能按需加载，需要遍历所有的实现类并实例化，然后在循环中才能找到我们需要的实现类。如果不想用某些实现类，或者某些类实例化很耗时，它也被载入并实例化了，这就造成了浪费。</li>
<li>获取某个实现类的方式不够灵活，只能通过 Iterator 形式获取，不能根据某个参数来获取对应的实现类。（Spring 的 BeanFactory，ApplicationContext 就要高级一些了。）</li>
<li>多个并发多线程使用 ServiceLoader 类的实例是不安全的。</li>
</ol>
<h2 id="SPI-使用场景">SPI 使用场景</h2>
<ol>
<li>数据库驱动加载接口实现类的加载：JDBC 加载不同类型数据库的驱动</li>
<li>日志门面接口实现类加载：SLF4J 加载不同提供商的日志实现类</li>
<li>Spring 中大量使用了 SPI：对 servlet3.0 规范对 ServletContainerInitializer 的实现、自动类型转换 Type Conversion SPI（Converter SPI、Formatter SPI）等</li>
<li>Dubbo：Dubbo 中也大量使用 SPI 的方式实现框架的扩展, 不过它对 Java 提供的原生 SPI 做了封装，允许用户扩展实现 Filter 接口</li>
</ol>
<h2 id="SPI-基本使用">SPI 基本使用</h2>
<h3 id="使用方法">使用方法</h3>
<ol>
<li>当服务提供者提供了接口的一种具体实现后，在 jar 包的 META-INF/services 目录下创建一个以“接口全限定名”为命名的文件，内容为实现类的全限定名；</li>
<li>接口实现按行配置，可以是多个。如果包含#号，每一行只取第一个#号前的内容。</li>
<li>接口实现类所在的 jar 包放在主程序的 classpath 中；</li>
<li>主程序通过 java.util.ServiceLoder 动态装载实现模块，它通过扫描 META-INF/services 目录下的配置文件找到实现类的全限定名，把类加载到 JVM；</li>
</ol>
<h3 id="使用案例">使用案例</h3>
<ol>
<li>包结构</li>
</ol>
<p><img src="4.png" alt=""></p>
<ol start="2">
<li>接口和方法定义</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IShout</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">shout</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">IShout</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shout</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;miao miao&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">IShout</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shout</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;wang wang&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在项目 META-INF/services 创建一个文本文件：名称为接口的“全限定名”，内容为实现类的全限定名</li>
</ol>
<p><strong>com.example.spi.demos.service.IShout</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">com.example.spi.demos.service.impl.Cat</span><br><span class="line">com.example.spi.demos.service.impl.Dog</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>测试</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ServiceLoader&lt;IShout&gt; shouts = ServiceLoader.load(IShout.class);</span><br><span class="line">        <span class="keyword">for</span> (IShout s : shouts) &#123;</span><br><span class="line">            s.shout();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line">miao miao</span><br><span class="line">wang wang</span><br></pre></td></tr></table></figure>
<h3 id="ServiceLoader-分析">ServiceLoader 分析</h3>
<p><img src="5.png" alt=""></p>
<p><img src="8.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ServiceLoader</span>&lt;S&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;S&gt; &#123;</span><br><span class="line">    <span class="comment">// 配置文件的路径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PREFIX</span> <span class="operator">=</span> <span class="string">&quot;META-INF/services/&quot;</span>;</span><br><span class="line">	<span class="comment">// 待加载的类或接口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;S&gt; service;</span><br><span class="line">	<span class="comment">// 类加载器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader loader;</span><br><span class="line">	<span class="comment">// 访问控制器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AccessControlContext acc;</span><br><span class="line">	<span class="comment">// 缓存已经加载的实例</span></span><br><span class="line">    <span class="keyword">private</span> LinkedHashMap&lt;String,S&gt; providers = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">	<span class="comment">// 内部类，加载服务类（懒加载）</span></span><br><span class="line">    <span class="keyword">private</span> LazyIterator lookupIterator;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// .....</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; ServiceLoader&lt;S&gt; <span class="title function_">load</span><span class="params">(Class&lt;S&gt; service)</span> &#123;</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">        <span class="keyword">return</span> ServiceLoader.load(service, cl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; ServiceLoader&lt;S&gt; <span class="title function_">load</span><span class="params">(Class&lt;S&gt; service,</span></span><br><span class="line"><span class="params">                                            ClassLoader loader)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ServiceLoader</span>&lt;&gt;(service, loader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ServiceLoader</span><span class="params">(Class&lt;S&gt; svc, ClassLoader cl)</span> &#123;</span><br><span class="line">        service = Objects.requireNonNull(svc, <span class="string">&quot;Service interface cannot be null&quot;</span>);</span><br><span class="line">        loader = (cl == <span class="literal">null</span>) ? ClassLoader.getSystemClassLoader() : cl;</span><br><span class="line">        acc = (System.getSecurityManager() != <span class="literal">null</span>) ? AccessController.getContext() : <span class="literal">null</span>;</span><br><span class="line">        reload();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reload</span><span class="params">()</span> &#123;</span><br><span class="line">        providers.clear();</span><br><span class="line">        lookupIterator = <span class="keyword">new</span> <span class="title class_">LazyIterator</span>(service, loader);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ........</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>应用程序调用 ServiceLoader.load 方法</li>
</ol>
<p>ServiceLoader.load(Class &lt; S &gt; service) 方法内先创建一个新的 ServiceLoader，并实例化该类中的成员变量，包括：</p>
<ul>
<li>loader（ClassLoader 类型，类加载器）</li>
<li>acc（AccessControlContext 类型，访问控制器）</li>
<li>providers（LinkedHashMap &lt;String,S&gt; 类型，用于缓存加载成功的类）</li>
<li>lookupIterator（实现迭代器功能）</li>
</ul>
<ol start="2">
<li>
<p>ServiceLoader 的构造方法内会调用 reload 方法，来清理缓存，初始化 LazyIterator，注意此处是 Lazy，也就懒加载，此时并不会去加载文件下的内容</p>
</li>
<li>
<p>当遍历器被遍历时，才会去读取配置文件，应用程序通过迭代器接口获取对象实例</p>
</li>
</ol>
<p>ServiceLoader 先判断成员变量 providers 对象中（LinkedHashMap &lt;String,S&gt; 类型）是否有缓存实例对象，如果有缓存，直接返回。如果没有缓存，执行类的装载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;S&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;S&gt;() &#123;</span><br><span class="line">        Iterator&lt;Map.Entry&lt;String, S&gt;&gt; knownProviders = providers.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (knownProviders.hasNext())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> lookupIterator.hasNext(); <span class="comment">// 调用 LazyIterator</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> S <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (knownProviders.hasNext())</span><br><span class="line">                <span class="keyword">return</span> knownProviders.next().getValue();</span><br><span class="line">            <span class="keyword">return</span> lookupIterator.next(); <span class="comment">// 调用 LazyIterator</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>读取 META-INF/services 下的配置文件，获得所有能被实例化的类的名称，ServiceLoader 可以跨越 jar 包获取 META-INF 下的配置文件</li>
</ol>
<p>核心代码如下（即 ServiceLoader 扫描了所有 jar 包下的配置文件。然后通过解析全限定名获得，并在遍历时通过 Class.forName 进行实例化）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">LazyIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;S&gt; &#123;</span><br><span class="line"></span><br><span class="line">    Class&lt;S&gt; service;</span><br><span class="line">    ClassLoader loader;</span><br><span class="line">    Enumeration&lt;URL&gt; configs = <span class="literal">null</span>;</span><br><span class="line">    Iterator&lt;String&gt; pending = <span class="literal">null</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">nextName</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazyIterator</span><span class="params">(Class&lt;S&gt; service, ClassLoader loader)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.service = service;</span><br><span class="line">        <span class="built_in">this</span>.loader = loader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hasNextService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextName != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (configs == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 通过PREFIX（META-INF/services/）和类名获取对应的配置文件，得到具体的实现类</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">fullName</span> <span class="operator">=</span> PREFIX + service.getName();</span><br><span class="line">                <span class="keyword">if</span> (loader == <span class="literal">null</span>)</span><br><span class="line">                    configs = ClassLoader.getSystemResources(fullName);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 加载配置文件</span></span><br><span class="line">                    configs = loader.getResources(fullName);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">                fail(service, <span class="string">&quot;Error locating configuration files&quot;</span>, x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 配置文件解析，获取接口对应的实现类，可以是多个</span></span><br><span class="line">        <span class="keyword">while</span> ((pending == <span class="literal">null</span>) || !pending.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!configs.hasMoreElements()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pending = parse(service, configs.nextElement());</span><br><span class="line">        &#125;</span><br><span class="line">        nextName = pending.next();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> S <span class="title function_">nextService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasNextService())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">cn</span> <span class="operator">=</span> nextName;</span><br><span class="line">        nextName = <span class="literal">null</span>;</span><br><span class="line">        Class&lt;?&gt; c = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c = Class.forName(cn, <span class="literal">false</span>, loader);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException x) &#123;</span><br><span class="line">            fail(service,<span class="string">&quot;Provider &quot;</span> + cn + <span class="string">&quot; not found&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!service.isAssignableFrom(c)) &#123;</span><br><span class="line">            fail(service,<span class="string">&quot;Provider &quot;</span> + cn  + <span class="string">&quot; not a subtype&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 实例化并缓存</span></span><br><span class="line">            <span class="type">S</span> <span class="variable">p</span> <span class="operator">=</span> service.cast(c.newInstance());</span><br><span class="line">            providers.put(cn, p);</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">            fail(service,<span class="string">&quot;Provider &quot;</span> + cn + <span class="string">&quot; could not be instantiated&quot;</span>,x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();          <span class="comment">// This cannot happen</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acc == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> hasNextService();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            PrivilegedAction&lt;Boolean&gt; action = <span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Boolean&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> Boolean <span class="title function_">run</span><span class="params">()</span> &#123; <span class="keyword">return</span> hasNextService(); &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> AccessController.doPrivileged(action, acc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> S <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acc == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nextService();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            PrivilegedAction&lt;S&gt; action = <span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;S&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> S <span class="title function_">run</span><span class="params">()</span> &#123; <span class="keyword">return</span> nextService(); &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> AccessController.doPrivileged(action, acc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义-ServiceLoader">自定义 ServiceLoader</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServiceLoader</span>&lt;S&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对应的接口 Class 模板</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;S&gt; service;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对应实现类的 可以有多个，用 List 进行封装</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;S&gt; providers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类加载器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader classLoader;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暴露给外部使用的方法，通过调用这个方法可以开始加载自己定制的实现流程。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; MyServiceLoader&lt;S&gt; <span class="title function_">load</span><span class="params">(Class&lt;S&gt; service)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyServiceLoader</span>&lt;&gt;(service);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法私有化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">MyServiceLoader</span><span class="params">(Class&lt;S&gt; service)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.service = service;</span><br><span class="line">        <span class="built_in">this</span>.classLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        doLoad();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关键方法，加载具体实现类的逻辑</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doLoad</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 读取所有 jar 包里面 META-INF/services 包下面的文件，这个文件名就是接口名，然后文件里面的内容就是具体的实现类的路径加全类名</span></span><br><span class="line">            Enumeration&lt;URL&gt; urls = classLoader.getResources(<span class="string">&quot;META-INF/services/&quot;</span> + service.getName());</span><br><span class="line">            <span class="comment">// 挨个遍历取到的文件</span></span><br><span class="line">            <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">                <span class="comment">// 取出当前的文件</span></span><br><span class="line">                <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> urls.nextElement();</span><br><span class="line">                System.out.println(<span class="string">&quot;File = &quot;</span> + url.getPath());</span><br><span class="line">                <span class="comment">// 建立链接</span></span><br><span class="line">                <span class="type">URLConnection</span> <span class="variable">urlConnection</span> <span class="operator">=</span> url.openConnection();</span><br><span class="line">                urlConnection.setUseCaches(<span class="literal">false</span>);</span><br><span class="line">                <span class="comment">// 获取文件输入流</span></span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> urlConnection.getInputStream();</span><br><span class="line">                <span class="comment">// 从文件输入流获取缓存</span></span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream));</span><br><span class="line">                <span class="comment">// 从文件内容里面得到实现类的全类名</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> bufferedReader.readLine();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (className != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 通过反射拿到实现类的实例</span></span><br><span class="line">                    Class&lt;?&gt; clazz = Class.forName(className, <span class="literal">false</span>, classLoader);</span><br><span class="line">                    <span class="comment">// 如果声明的接口跟这个具体的实现类是属于同一类型，（可以理解为Java的一种多态，接口跟实现类、父类和子类等等这种关系。）则构造实例</span></span><br><span class="line">                    <span class="keyword">if</span> (service.isAssignableFrom(clazz)) &#123;</span><br><span class="line">                        Constructor&lt;? <span class="keyword">extends</span> <span class="title class_">S</span>&gt; constructor = (Constructor&lt;? <span class="keyword">extends</span> <span class="title class_">S</span>&gt;) clazz.getConstructor();</span><br><span class="line">                        <span class="type">S</span> <span class="variable">instance</span> <span class="operator">=</span> constructor.newInstance();</span><br><span class="line">                        <span class="comment">// 把当前构造的实例对象添加到 Provider的列表里面</span></span><br><span class="line">                        providers.add(instance);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 继续读取下一行的实现类，可以有多个实现类，只需要换行就可以了。</span></span><br><span class="line">                    className = bufferedReader.readLine();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;读取文件异常。。。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回spi接口对应的具体实现类列表</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;S&gt; <span class="title function_">getProviders</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> providers;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>通过 URL 工具类从 jar 包的 /META-INF/services 目录下面找到对应的文件，</li>
<li>读取这个文件的名称找到对应的 spi 接口，</li>
<li>通过 InputStream 流将文件里面的具体实现类的全类名读取出来，</li>
<li>根据获取到的全类名，先判断跟 spi 接口是否为同一类型，如果是的，那么就通过反射的机制构造对应的实例对象，</li>
<li>将构造出来的实例对象添加到 Providers 的列表中。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    MyServiceLoader&lt;IShout&gt; shouts = MyServiceLoader.load(IShout.class);</span><br><span class="line">    <span class="keyword">for</span> (IShout s : shouts.getProviders()) &#123;</span><br><span class="line">        s.shout();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SpringBoot-使用-SPI">SpringBoot 使用 SPI</h2>
<h3 id="使用方法-2">使用方法</h3>
<p>Spring Boot 有一个与 SPI 相似的机制，但它并不完全等同于 Java 标准 SPI。</p>
<p>Spring Boot 的自动配置机制主要依赖于 spring.factories 文件。这个文件可以在多个 jar 中存在，并且 Spring Boot 会加载所有可见的 spring.factories 文件。我们可以在这个文件中声明一系列的自动配置类，这样当满足某些条件时，这些配置类会自动被 Spring Boot 应用。</p>
<p>spring.factories 文件中的条目键和值之间不能有换行，即 key = value 形式的结构必须在同一行开始。但是，如果有多个值需要列出（如多个实现类），并且这些值是逗号分隔的，那么可以使用反斜杠（\）来换行。spring.factories 的名称是约定俗成的。如果试图使用一个不同的文件名，那么 Spring Boot 的自动配置机制将不会识别它。</p>
<h3 id="使用案例-2">使用案例</h3>
<ol>
<li>包结构</li>
</ol>
<p><img src="7.png" alt=""></p>
<ol start="2">
<li>接口和方法定义</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MessageService</span> &#123;</span><br><span class="line">    String <span class="title function_">getMessage</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloMessageService</span> <span class="keyword">implements</span> <span class="title class_">MessageService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello from HelloMessageService!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HiMessageService</span> <span class="keyword">implements</span> <span class="title class_">MessageService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hi from HiMessageService!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在项目 META-INF 创建一个 spring.factories 文件</li>
</ol>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">com.example.spi.demos.service.MessageService</span>=<span class="string">com.example.spi.demos.service.impl.HelloMessageService,\</span></span><br><span class="line"><span class="string">  com.example.spi.demos.service.impl.HiMessageService</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>测试</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;MessageService&gt; services = SpringFactoriesLoader.loadFactories(MessageService.class, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">for</span> (MessageService service : services) &#123;</span><br><span class="line">            System.out.println(service.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果：</span></span><br><span class="line">Hello from HelloMessageService!</span><br><span class="line">Hi from HiMessageService!</span><br></pre></td></tr></table></figure>
<h3 id="SpringFactoriesLoader-分析">SpringFactoriesLoader 分析</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SpringFactoriesLoader</span> &#123;</span><br><span class="line">    <span class="comment">// 加载器所需要加载的路径</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FACTORIES_RESOURCE_LOCATION</span> <span class="operator">=</span> <span class="string">&quot;META-INF/spring.factories&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Log</span> <span class="variable">logger</span> <span class="operator">=</span> LogFactory.getLog(SpringFactoriesLoader.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;ClassLoader, MultiValueMap&lt;String, String&gt;&gt; cache = <span class="keyword">new</span> <span class="title class_">ConcurrentReferenceHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; <span class="title function_">loadSpringFactories</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> &#123;</span><br><span class="line">        MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 根据路径去录取各个包下的文件</span></span><br><span class="line">            Enumeration&lt;URL&gt; urls = (classLoader != <span class="literal">null</span> ?</span><br><span class="line">                classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class="line">                ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">            result = <span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">// 获取后进行循环遍历，因为不止一个包有spring.factories文件</span></span><br><span class="line">            <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">                <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> urls.nextElement();</span><br><span class="line">                <span class="type">UrlResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlResource</span>(url);</span><br><span class="line">                <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">                <span class="comment">// 获取到了key和value对应关系</span></span><br><span class="line">                <span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">factoryClassName</span> <span class="operator">=</span> ((String) entry.getKey()).trim();</span><br><span class="line">                <span class="comment">// 循环获取配置文件的value，并放进result集合中</span></span><br><span class="line">                <span class="keyword">for</span> (String factoryName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123;</span><br><span class="line">                        result.add(factoryClassName, factoryName.trim());</span><br><span class="line">                	&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 并缓存起来，以便后续直接获取</span></span><br><span class="line">            cache.put(classLoader, result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unable to load factories from location [&quot;</span> +</span><br><span class="line">                    FACTORIES_RESOURCE_LOCATION + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>定时任务工具类（Cron Util）</title>
    <url>/blog/2024/11/19/Java/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/Cron%20Util/</url>
    <content><![CDATA[<h2 id="依赖">依赖</h2>
<p>cron-utils的github地址：<a href="https://github.com/jmrozanec/cron-utils">https://github.com/jmrozanec/cron-utils</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.cronutils<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cron-utils<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="基本使用">基本使用</h2>
<h3 id="定义cron表达式的支持范围">定义cron表达式的支持范围</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建cron定义，自定义cron表达式支持的范围</span></span><br><span class="line"><span class="type">CronDefinition</span> <span class="variable">cronDefinition</span> <span class="operator">=</span></span><br><span class="line">    CronDefinitionBuilder.defineCron()</span><br><span class="line">        .withSeconds().and()</span><br><span class="line">        .withMinutes().and()</span><br><span class="line">        .withHours().and()</span><br><span class="line">        .withDayOfMonth()</span><br><span class="line">            .supportsHash().supportsL().supportsW().and()</span><br><span class="line">        .withMonth().and()</span><br><span class="line">        .withDayOfWeek()</span><br><span class="line">            .withIntMapping(<span class="number">7</span>, <span class="number">0</span>) </span><br><span class="line">            .supportsHash().supportsL().supportsW().and()</span><br><span class="line">        .withYear().optional().and()</span><br><span class="line">        .instance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入要生成的cron表达式类型获取cron定义</span></span><br><span class="line">cronDefinition = CronDefinitionBuilder.instanceDefinitionFor(CronType.QUARTZ);</span><br></pre></td></tr></table></figure>
<p>支持定时任务的类型：</p>
<ol>
<li>CRON4J</li>
<li>QUARTZ</li>
<li>UNIX</li>
<li>SPRING</li>
<li>SPRING53</li>
</ol>
<h3 id="生成cron表达式">生成cron表达式</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.cronutils.model.field.expression.FieldExpressionFactory.*;</span><br><span class="line"></span><br><span class="line"><span class="type">Cron</span> <span class="variable">cron</span> <span class="operator">=</span> CronBuilder.cron(CronDefinitionBuilder.instanceDefinitionFor(CronType.QUARTZ))</span><br><span class="line">    .withYear(always())</span><br><span class="line">    .withDoM(between(SpecialChar.L, <span class="number">3</span>))</span><br><span class="line">    .withMonth(always())</span><br><span class="line">    .withDoW(questionMark())</span><br><span class="line">    .withHour(always())</span><br><span class="line">    .withMinute(always())</span><br><span class="line">    .withSecond(on(<span class="number">0</span>))</span><br><span class="line">    .instance();</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">cronAsString</span> <span class="operator">=</span> cron.asString(); <span class="comment">// 0 * * L-3 * ? *</span></span><br></pre></td></tr></table></figure>
<p>各方法对应cron表达式关系：</p>
<ol>
<li>always：表示*</li>
<li>questionMark：表示?</li>
<li>on：表示具体值</li>
<li>between：表示-，例如，between(0,5)表示0-5</li>
<li>and：表示,，例如，and(on(1),on(5))表示0,5</li>
<li>every：表示/，例如，every(on(2),3)表示2/3</li>
</ol>
<h3 id="获取cron表达式描述">获取cron表达式描述</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建cron描述器</span></span><br><span class="line">        <span class="type">CronDescriptor</span> <span class="variable">descriptor</span> <span class="operator">=</span> CronDescriptor.instance();</span><br><span class="line">        <span class="comment">// 创建cron定义</span></span><br><span class="line">        <span class="type">CronDefinition</span> <span class="variable">cronDefinition</span> <span class="operator">=</span> CronDefinitionBuilder.instanceDefinitionFor(QUARTZ);</span><br><span class="line">        <span class="comment">// 创建cron解析器</span></span><br><span class="line">        <span class="type">CronParser</span> <span class="variable">cronParser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CronParser</span>(cronDefinition);</span><br><span class="line">        <span class="type">String</span> <span class="variable">describe</span> <span class="operator">=</span> descriptor.describe(cronParser.parse(<span class="string">&quot;0 0 12 ? * 6&quot;</span>));</span><br><span class="line">        System.out.println(describe);</span><br><span class="line">        describe = descriptor.describe(cronParser.parse(<span class="string">&quot;*/45 * * * * ?&quot;</span>));</span><br><span class="line">        System.out.println(describe);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置语言</span></span><br><span class="line">		descriptor = CronDescriptor.instance(Locale.CHINESE);</span><br><span class="line">        describe = descriptor.describe(cronParser.parse(<span class="string">&quot;0 0 12 ? * 6&quot;</span>));</span><br><span class="line">        System.out.println(describe);</span><br><span class="line">        describe = descriptor.describe(cronParser.parse(<span class="string">&quot;*/45 * * * * ?&quot;</span>));</span><br><span class="line">        System.out.println(describe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line">at <span class="number">12</span>:<span class="number">00</span> at Friday day</span><br><span class="line">every <span class="number">45</span> seconds</span><br><span class="line">在 <span class="number">12</span>:<span class="number">00</span> 在 星期五 天</span><br><span class="line">每 <span class="number">45</span> 秒</span><br></pre></td></tr></table></figure>
<h3 id="校验cron表达式的正确性">校验cron表达式的正确性</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CronDefinition</span> <span class="variable">cronDefinition</span> <span class="operator">=</span> CronDefinitionBuilder.instanceDefinitionFor(QUARTZ);</span><br><span class="line">        <span class="type">CronParser</span> <span class="variable">cronParser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CronParser</span>(cronDefinition);</span><br><span class="line">        <span class="type">Cron</span> <span class="variable">cron</span> <span class="operator">=</span> cronParser.parse(<span class="string">&quot;0 0 12 ? * 6&quot;</span>);</span><br><span class="line">        <span class="comment">// 校验cron表达式</span></span><br><span class="line">        cron.validate();</span><br><span class="line">        cron = cronParser.parse(<span class="string">&quot;0 0 12 ? * ?&quot;</span>);</span><br><span class="line">        cron.validate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="工具类">工具类</h2>
<h3 id="WeekEnum">WeekEnum</h3>
<p>定义星期的枚举类信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">WeekEnum</span> &#123;</span><br><span class="line"></span><br><span class="line">    SUNDAY(<span class="number">1</span>, <span class="string">&quot;星期天&quot;</span>),</span><br><span class="line">    MONDAY(<span class="number">2</span>, <span class="string">&quot;星期一&quot;</span>),</span><br><span class="line">    TUESDAY(<span class="number">3</span>, <span class="string">&quot;星期二&quot;</span>),</span><br><span class="line">    WEDNESDAY(<span class="number">4</span>, <span class="string">&quot;星期三&quot;</span>),</span><br><span class="line">    THURSDAY(<span class="number">5</span>, <span class="string">&quot;星期四&quot;</span>),</span><br><span class="line">    FRIDAY(<span class="number">6</span>, <span class="string">&quot;星期五&quot;</span>),</span><br><span class="line">    SATURDAY(<span class="number">7</span>, <span class="string">&quot;星期六&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CycleTypeEnum">CycleTypeEnum</h3>
<p>定义要生成的cron表达式类型枚举类信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">CycleTypeEnum</span> &#123;</span><br><span class="line"></span><br><span class="line">    MINUTE(<span class="number">1</span>, <span class="string">&quot;分钟&quot;</span>),</span><br><span class="line">    HOUR(<span class="number">2</span>, <span class="string">&quot;小时&quot;</span>),</span><br><span class="line">    DAY(<span class="number">3</span>, <span class="string">&quot;日&quot;</span>),</span><br><span class="line">    WEEK(<span class="number">4</span>, <span class="string">&quot;周&quot;</span>),</span><br><span class="line">    MONTH(<span class="number">5</span>, <span class="string">&quot;月&quot;</span>),</span><br><span class="line">    QUARTER(<span class="number">6</span>, <span class="string">&quot;季度&quot;</span>),</span><br><span class="line">    YEAR(<span class="number">7</span>, <span class="string">&quot;年&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RepeatRuleEnum">RepeatRuleEnum</h3>
<p>定义要生成月、季度的cron表达式循环规则枚举类信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">RepeatRuleEnum</span> &#123;</span><br><span class="line"></span><br><span class="line">    WEEK(<span class="number">1</span>, <span class="string">&quot;周&quot;</span>),</span><br><span class="line">    DATE(<span class="number">2</span>, <span class="string">&quot;日期&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CronDto">CronDto</h3>
<p>定义cron表达式工具类的请求体信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CronDto</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 周期类型 minute:分钟 hour: 小时; day: 天; week: 周; month: 月; quarter: 季; year: 年</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer cycleType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime executionTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定一周哪几天</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; weekDays;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定一个月哪几天</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; monthDays;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定一年哪几月</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; quartzMonths;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一周的星期几</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer dayOfWeek;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第几周</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer week;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重复规则：周 天</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer repeatRule;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CronUtils">CronUtils</h3>
<p>根据年、月、日、时、分、秒、星期、季度实现不同的cron表达式</p>
<p>注意：生成年、月、季度的cron表达式时可以根据日或者星期额外判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CronUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 星期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Integer&gt; WEEKS = Arrays.stream(WeekEnum.values()).map(WeekEnum::getCode).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createCron</span><span class="params">(CronDto cronDto)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">cycleType</span> <span class="operator">=</span> cronDto.getCycleType();</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">executionTime</span> <span class="operator">=</span> cronDto.getExecutionTime();</span><br><span class="line">        <span class="type">CronBuilder</span> <span class="variable">cronBuilder</span> <span class="operator">=</span> CronBuilder.cron(CronDefinitionBuilder.instanceDefinitionFor(CronType.QUARTZ));</span><br><span class="line">        <span class="comment">// 每分钟一次</span></span><br><span class="line">        <span class="keyword">if</span> (Objects.equals(CycleTypeEnum.MINUTE.getCode(), cycleType)) &#123;</span><br><span class="line">            <span class="keyword">return</span> getSecondCron(cronBuilder, executionTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每小时一次</span></span><br><span class="line">        <span class="keyword">if</span> (Objects.equals(CycleTypeEnum.HOUR.getCode(), cycleType)) &#123;</span><br><span class="line">            <span class="keyword">return</span> getMinuteCron(cronBuilder, executionTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每日一次</span></span><br><span class="line">        <span class="keyword">if</span> (Objects.equals(CycleTypeEnum.DAY.getCode(), cycleType)) &#123;</span><br><span class="line">            <span class="keyword">return</span> getDayCron(cronBuilder, executionTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每周一次</span></span><br><span class="line">        <span class="keyword">if</span> (Objects.equals(CycleTypeEnum.WEEK.getCode(), cycleType)) &#123;</span><br><span class="line">            <span class="keyword">return</span> getWeekCron(cronDto, cronBuilder, executionTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每月一次</span></span><br><span class="line">        <span class="keyword">if</span> (Objects.equals(CycleTypeEnum.MONTH.getCode(), cycleType)) &#123;</span><br><span class="line">            <span class="keyword">return</span> getMonthCron(cronDto, cronBuilder, executionTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每季度一次</span></span><br><span class="line">        <span class="keyword">if</span> (Objects.equals(CycleTypeEnum.QUARTER.getCode(), cycleType)) &#123;</span><br><span class="line">            <span class="keyword">return</span> getQuarterCron(cronDto, cronBuilder, executionTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每年一次</span></span><br><span class="line">        <span class="keyword">if</span> (Objects.equals(CycleTypeEnum.YEAR.getCode(), cycleType)) &#123;</span><br><span class="line">            <span class="keyword">return</span> getYearCron(cronBuilder, executionTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getYearCron</span><span class="params">(CronBuilder cronBuilder, LocalDateTime executionTime)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cronBuilder.withSecond(on(executionTime.getSecond()))</span><br><span class="line">                .withMinute(on(executionTime.getMinute()))</span><br><span class="line">                .withHour(on(executionTime.getHour()))</span><br><span class="line">                .withDoM(on(executionTime.getDayOfMonth()))</span><br><span class="line">                .withMonth(on(executionTime.getMonthValue()))</span><br><span class="line">                .withDoW(questionMark())</span><br><span class="line">                .instance()</span><br><span class="line">                .asString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getQuarterCron</span><span class="params">(CronDto cronDto, CronBuilder cronBuilder, LocalDateTime executionTime)</span> &#123;</span><br><span class="line">        List&lt;FieldExpression&gt; flist = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        cronDto.getQuartzMonths().forEach(e -&gt; flist.add(FieldExpressionFactory.on(e)));</span><br><span class="line">        <span class="keyword">return</span> cronBuilder.withSecond(on(executionTime.getSecond()))</span><br><span class="line">                .withMinute(on(executionTime.getMinute()))</span><br><span class="line">                .withHour(on(executionTime.getHour()))</span><br><span class="line">                .withDoM(questionMark())</span><br><span class="line">                .withMonth(and(flist))</span><br><span class="line">                .withDoW(on(WEEKS.get(cronDto.getDayOfWeek()), SpecialChar.HASH, cronDto.getWeek()))</span><br><span class="line">                .instance()</span><br><span class="line">                .asString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getMonthCron</span><span class="params">(CronDto cronDto, CronBuilder cronBuilder, LocalDateTime executionTime)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">repeatRule</span> <span class="operator">=</span> cronDto.getRepeatRule();</span><br><span class="line">        <span class="comment">// 按周</span></span><br><span class="line">        <span class="keyword">if</span> (Objects.equals(RepeatRuleEnum.WEEK.getCode(), repeatRule)) &#123;</span><br><span class="line">            List&lt;FieldExpression&gt; weekDays = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">if</span> (!CollectionUtils.isEmpty(cronDto.getWeekDays())) &#123;</span><br><span class="line">                cronDto.getWeekDays().forEach(e -&gt; weekDays.add(FieldExpressionFactory.on(WEEKS.get(cronDto.getDayOfWeek()),</span><br><span class="line">                        SpecialChar.HASH, e)));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cronBuilder.withSecond(on(executionTime.getSecond()))</span><br><span class="line">                    .withMinute(on(executionTime.getMinute()))</span><br><span class="line">                    .withHour(on(executionTime.getHour()))</span><br><span class="line">                    .withDoM(questionMark())</span><br><span class="line">                    .withMonth(always())</span><br><span class="line">                    .withDoW(CollectionUtils.isEmpty(weekDays) ? on(WEEKS.get(cronDto.getDayOfWeek()), SpecialChar.HASH,</span><br><span class="line">                            cronDto.getWeek()) : and(weekDays))</span><br><span class="line">                    .instance()</span><br><span class="line">                    .asString();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 按天</span></span><br><span class="line">        <span class="keyword">if</span> (Objects.equals(RepeatRuleEnum.DATE.getCode(), repeatRule)) &#123;</span><br><span class="line">            List&lt;FieldExpression&gt; monthDays = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            cronDto.getMonthDays().forEach(e -&gt; monthDays.add(FieldExpressionFactory.on(e)));</span><br><span class="line">            <span class="keyword">return</span> cronBuilder.withSecond(on(executionTime.getSecond()))</span><br><span class="line">                    .withMinute(on(executionTime.getMinute()))</span><br><span class="line">                    .withHour(on(executionTime.getHour()))</span><br><span class="line">                    .withDoM(and(monthDays))</span><br><span class="line">                    .withMonth(always())</span><br><span class="line">                    .withDoW(questionMark())</span><br><span class="line">                    .instance()</span><br><span class="line">                    .asString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getWeekCron</span><span class="params">(CronDto cronDto, CronBuilder cronBuilder, LocalDateTime executionTime)</span> &#123;</span><br><span class="line">        List&lt;FieldExpression&gt; weekDays = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        cronDto.getWeekDays().forEach(e -&gt; weekDays.add(FieldExpressionFactory.on(e)));</span><br><span class="line">        <span class="keyword">return</span> cronBuilder.withSecond(on(executionTime.getSecond()))</span><br><span class="line">                .withMinute(on(executionTime.getMinute()))</span><br><span class="line">                .withHour(on(executionTime.getHour()))</span><br><span class="line">                .withDoM(questionMark())</span><br><span class="line">                .withMonth(always())</span><br><span class="line">                .withDoW(and(weekDays))</span><br><span class="line">                .instance()</span><br><span class="line">                .asString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getDayCron</span><span class="params">(CronBuilder cronBuilder, LocalDateTime executionTime)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cronBuilder.withSecond(on(executionTime.getSecond()))</span><br><span class="line">                .withMinute(on(executionTime.getMinute()))</span><br><span class="line">                .withHour(on(executionTime.getHour()))</span><br><span class="line">                .withDoM(always())</span><br><span class="line">                .withMonth(always())</span><br><span class="line">                .withDoW(questionMark())</span><br><span class="line">                .instance()</span><br><span class="line">                .asString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getMinuteCron</span><span class="params">(CronBuilder cronBuilder, LocalDateTime executionTime)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cronBuilder.withSecond(on(executionTime.getSecond()))</span><br><span class="line">                .withMinute(on(executionTime.getMinute()))</span><br><span class="line">                .withHour(always())</span><br><span class="line">                .withDoM(always())</span><br><span class="line">                .withMonth(always())</span><br><span class="line">                .withDoW(questionMark())</span><br><span class="line">                .instance()</span><br><span class="line">                .asString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getSecondCron</span><span class="params">(CronBuilder cronBuilder, LocalDateTime executionTime)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cronBuilder.withSecond(on(executionTime.getSecond()))</span><br><span class="line">                .withMinute(always())</span><br><span class="line">                .withHour(always())</span><br><span class="line">                .withDoM(always())</span><br><span class="line">                .withMonth(always())</span><br><span class="line">                .withDoW(questionMark())</span><br><span class="line">                .instance()</span><br><span class="line">                .asString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用案例">使用案例</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CronDto</span> <span class="variable">cronDto</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CronDto</span>();</span><br><span class="line">        cronDto.setCycleType(<span class="number">1</span>);</span><br><span class="line">        cronDto.setExecutionTime(LocalDateTime.now());</span><br><span class="line">        <span class="type">String</span> <span class="variable">cron</span> <span class="operator">=</span> createCron(cronDto);</span><br><span class="line">        System.out.println(cron);</span><br><span class="line"></span><br><span class="line">        cronDto.setCycleType(<span class="number">2</span>);</span><br><span class="line">        cron = createCron(cronDto);</span><br><span class="line">        System.out.println(cron);</span><br><span class="line"></span><br><span class="line">        cronDto.setCycleType(<span class="number">3</span>);</span><br><span class="line">        cron = createCron(cronDto);</span><br><span class="line">        System.out.println(cron);</span><br><span class="line"></span><br><span class="line">        cronDto.setCycleType(<span class="number">4</span>);</span><br><span class="line">        cronDto.setWeekDays(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">        cron = createCron(cronDto);</span><br><span class="line">        System.out.println(cron);</span><br><span class="line"></span><br><span class="line">        cronDto.setCycleType(<span class="number">5</span>);</span><br><span class="line">        cronDto.setRepeatRule(<span class="number">1</span>);</span><br><span class="line">        cronDto.setDayOfWeek(<span class="number">1</span>);</span><br><span class="line">        cron = createCron(cronDto);</span><br><span class="line">        System.out.println(cron);</span><br><span class="line"></span><br><span class="line">        cronDto.setCycleType(<span class="number">5</span>);</span><br><span class="line">        cronDto.setRepeatRule(<span class="number">1</span>);</span><br><span class="line">        cronDto.setWeek(<span class="number">1</span>);</span><br><span class="line">        cronDto.setDayOfWeek(<span class="number">1</span>);</span><br><span class="line">        cronDto.setWeekDays(<span class="literal">null</span>);</span><br><span class="line">        cron = createCron(cronDto);</span><br><span class="line">        System.out.println(cron);</span><br><span class="line"></span><br><span class="line">        cronDto.setCycleType(<span class="number">5</span>);</span><br><span class="line">        cronDto.setRepeatRule(<span class="number">2</span>);</span><br><span class="line">        cronDto.setMonthDays(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">        cron = createCron(cronDto);</span><br><span class="line">        System.out.println(cron);</span><br><span class="line"></span><br><span class="line">        cronDto.setCycleType(<span class="number">6</span>);</span><br><span class="line">        cronDto.setQuartzMonths(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">        cron = createCron(cronDto);</span><br><span class="line">        System.out.println(cron);</span><br><span class="line"></span><br><span class="line">        cronDto.setCycleType(<span class="number">7</span>);</span><br><span class="line">        cron = createCron(cronDto);</span><br><span class="line">        System.out.println(cron);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="number">14</span> * * * * ?</span><br><span class="line"><span class="number">14</span> <span class="number">28</span> * * * ?</span><br><span class="line"><span class="number">14</span> <span class="number">28</span> <span class="number">9</span> * * ?</span><br><span class="line"><span class="number">14</span> <span class="number">28</span> <span class="number">9</span> ? * <span class="number">1</span>,<span class="number">2</span></span><br><span class="line"><span class="number">14</span> <span class="number">28</span> <span class="number">9</span> ? * <span class="number">2</span>#<span class="number">1</span>,<span class="number">2</span>#<span class="number">2</span></span><br><span class="line"><span class="number">14</span> <span class="number">28</span> <span class="number">9</span> ? * <span class="number">2</span>#<span class="number">1</span></span><br><span class="line"><span class="number">14</span> <span class="number">28</span> <span class="number">9</span> <span class="number">1</span>,<span class="number">2</span> * ?</span><br><span class="line"><span class="number">14</span> <span class="number">28</span> <span class="number">9</span> ? <span class="number">1</span>,<span class="number">2</span> <span class="number">2</span>#<span class="number">1</span></span><br><span class="line"><span class="number">14</span> <span class="number">28</span> <span class="number">9</span> <span class="number">19</span> <span class="number">11</span> ?</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>定时任务</tag>
        <tag>Cron Util</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot Async异步调用</title>
    <url>/blog/2024/11/22/Java/%E5%BC%82%E6%AD%A5%E5%A4%9A%E7%BA%BF%E7%A8%8B/SpringBoot%20Async%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<h2 id="基本使用">基本使用</h2>
<h3 id="异步调用">异步调用</h3>
<p>在使用@Async 之前，我们需要确保已经启用了 Spring 的异步任务执行功能，这通常通过在配置类上添加@EnableAsync 注解来完成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">// 开启异步调用</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Async01Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Async01Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>未使用@Async</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doTaskOne</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start 任务1....&quot;</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        Thread.sleep(random.nextInt(<span class="number">10000</span>));</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;任务1耗时：&quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doTaskTwo</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start 任务2....&quot;</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        Thread.sleep(random.nextInt(<span class="number">10000</span>));</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;任务2耗时：&quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doTaskThree</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start 任务3....&quot;</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        Thread.sleep(random.nextInt(<span class="number">10000</span>));</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;任务3耗时：&quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>使用@Async</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doTaskOne</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start 任务1...&quot;</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        Thread.sleep(random.nextInt(<span class="number">10000</span>));</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;任务1，耗时&quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doTaskTwo</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start 任务2...&quot;</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        Thread.sleep(random.nextInt(<span class="number">10000</span>));</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;任务2，耗时&quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doTaskThree</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start 任务3...&quot;</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        Thread.sleep(random.nextInt(<span class="number">10000</span>));</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;任务3，耗时&quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用两个方法进行比较</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Async01ApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Task1 task1;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Task2 task2;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        task1.doTaskOne();</span><br><span class="line">        task1.doTaskTwo();</span><br><span class="line">        task1.doTaskThree();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        task2.doTaskOne();</span><br><span class="line">        task2.doTaskTwo();</span><br><span class="line">        task2.doTaskThree();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>未使用@Async 执行结果</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">start 任务<span class="number">1.</span>...</span><br><span class="line">任务<span class="number">1</span>耗时：<span class="number">1498</span></span><br><span class="line">start 任务<span class="number">2.</span>...</span><br><span class="line">任务<span class="number">2</span>耗时：<span class="number">1967</span></span><br><span class="line">start 任务<span class="number">3.</span>...</span><br><span class="line">任务<span class="number">3</span>耗时：<span class="number">9994</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>使用@Async 执行结果</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">start 任务<span class="number">1.</span>..</span><br><span class="line">start 任务<span class="number">3.</span>..</span><br><span class="line">start 任务<span class="number">2.</span>..</span><br><span class="line">任务<span class="number">2</span>，耗时<span class="number">664</span></span><br><span class="line">任务<span class="number">1</span>，耗时<span class="number">2378</span></span><br><span class="line">任务<span class="number">3</span>，耗时<span class="number">4973</span></span><br></pre></td></tr></table></figure>
<p>可以看出，未使用@Async 时所有任务是串行执行的，只能等上一个任务执行完毕才能执行下一个，而使用@Async 后任务是并发执行的</p>
<h3 id="异步返回结果">异步返回结果</h3>
<p>注意：被@Async 标注的方法必须是 void 类型的，且不能有返回值，除非返回类型是 Future，这样可以通过 Future 获取异步操作的结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncTask</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> Future&lt;String&gt; <span class="title function_">asyncTask2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;asyncTask2 start.....&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AsyncResult</span>&lt;String&gt;(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> AsyncTask asyncTask;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    Future&lt;String&gt; future = asyncTask.asyncTask2();</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">//判断是否执行完毕</span></span><br><span class="line">        <span class="keyword">if</span> (future.isDone()) &#123;</span><br><span class="line">            System.out.println(future.get());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="异常处理">异常处理</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncExceptionHandler</span> <span class="keyword">implements</span> <span class="title class_">AsyncUncaughtExceptionHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(AsyncExceptionHandler.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常捕获</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleUncaughtException</span><span class="params">(Throwable ex, Method method, Object... params)</span> &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;@Async调用异常，出现异常的方法：&#123;&#125;，参数：&#123;&#125;，异常信息：&#123;&#125;&quot;</span>, method.getDeclaringClass().getName() + <span class="string">&quot;.&quot;</span></span><br><span class="line">                + method.getName(), JSON.toJSONString(params), ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncConfig</span> <span class="keyword">extends</span> <span class="title class_">AsyncConfigurerSupport</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AsyncExceptionHandler asyncExceptionHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将异常处理类注入容器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> AsyncUncaughtExceptionHandler <span class="title function_">getAsyncUncaughtExceptionHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> asyncExceptionHandler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doTaskOne</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start 任务1...&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        Thread.sleep(random.nextInt(<span class="number">10000</span>));</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;任务1，耗时&quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Task3 task3;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    task3.doTaskOne();</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line">start 任务<span class="number">1.</span>..</span><br><span class="line"><span class="number">2024</span>-<span class="number">11</span>-<span class="number">22</span> 09:<span class="number">12</span>:<span class="number">45.828</span> ERROR <span class="number">20716</span> --- [         task-<span class="number">1</span>] c.e.a.d.config.AsyncExceptionHandler     : <span class="meta">@Async</span>调用异常，出现异常的方法：com.example.async.demos.config.Task3.doTaskOne，参数：[]，异常信息：/ by zero</span><br></pre></td></tr></table></figure>
<h2 id="线程池配置">线程池配置</h2>
<h3 id="默认线程池">默认线程池</h3>
<p>SpringBoot 从 2.1 开始使用的是 ThreadPoolTaskExecutor 线程池，之前使用的是 SimpleAsyncTaskExecutor，查看 AsyncExecutionInterceptor 源码中的 getDefaultExecutor 方法，会先去找名称为 taskExecutor 的 Bean，如果找不到才使用 SimpleAsyncTaskExecutor</p>
<p>注意：名称为 taskExecutor 的 Bean 在 TaskExecutionAutoConfiguration 会被实例化</p>
<p><img src="1.png" alt=""></p>
<p><img src="2.png" alt=""></p>
<p><img src="3.png" alt=""></p>
<ol>
<li>ThreadPoolTaskExecutor</li>
</ol>
<p>此线程池的默认参数（由 SpringBoot 配置 TaskExecutionProperties），核心线程数 8，队列容量不限，最大线程数不限。如果业务逻辑需要执行的时间比较长，或者由于代码缺陷导致核心线程不能被释放，那么队列中的任务会越来越多且不会被执行。因此使用@Async 必须配置自定义线程池，或者修改默认线程池参数</p>
<ol start="2">
<li>SimpleAsyncTaskExecutor</li>
</ol>
<p>此线程池会一直创建新的线程，失去了线程池的优势，不推荐使用，若系统中不断地创建线程，最终会导致系统占用内存过高，引发 OutOfMemoryError 错误。</p>
<p>针对线程创建问题，SimpleAsyncTaskExecutor 提供了限流机制，查看 ConcurrencyThrottleSupport 源码中的 beforeAccess 方法，通过 concurrencyLimit 属性来控制开关，当 concurrencyLimit &gt;= 0 时开启限流机制，默认关闭限流机制即 concurrencyLimit =-1，当关闭情况下，会不断创建新的线程来处理任务。基于默认配置，SimpleAsyncTaskExecutor 并不是严格意义的线程池，达不到线程复用的功能</p>
<p><img src="4.png" alt=""></p>
<p><img src="5.png" alt=""></p>
<h3 id="线程池修改">线程池修改</h3>
<h4 id="配置文件修改">配置文件修改</h4>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#核心线程数</span></span><br><span class="line"><span class="attr">spring.task.execution.pool.core-size</span>=<span class="string">200</span></span><br><span class="line"><span class="comment">#最大线程数</span></span><br><span class="line"><span class="attr">spring.task.execution.pool.max-size</span>=<span class="string">1000</span></span><br><span class="line"><span class="comment">#空闲线程保留时间</span></span><br><span class="line"><span class="attr">spring.task.execution.pool.keep-alive</span>=<span class="string">3s</span></span><br><span class="line"><span class="comment">#队列容量</span></span><br><span class="line"><span class="attr">spring.task.execution.pool.queue-capacity</span>=<span class="string">1000</span></span><br><span class="line"><span class="comment">#线程名称前缀</span></span><br><span class="line"><span class="attr">spring.task.execution.thread-name-prefix</span>=<span class="string">test-thread-</span></span><br></pre></td></tr></table></figure>
<p>@Async 异步方法默认使用 Spring 创建 ThreadPoolTaskExecutor（参考 TaskExecutionAutoConfiguration）</p>
<ol>
<li>默认核心线程数：8</li>
<li>最大线程数：Integet.MAX_VALUE</li>
<li>队列使用：LinkedBlockingQueue</li>
<li>容量是：Integet.MAX_VALUE</li>
<li>空闲线程保留时间：60s</li>
<li>线程池拒绝策略：AbortPolicy</li>
</ol>
<h4 id="自定义线程池">自定义线程池</h4>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">task.pool.corePoolSize</span>=<span class="string">20</span></span><br><span class="line"><span class="attr">task.pool.maxPoolSize</span>=<span class="string">40</span></span><br><span class="line"><span class="attr">task.pool.keepAliveSeconds</span>=<span class="string">300</span></span><br><span class="line"><span class="attr">task.pool.queueCapacity</span>=<span class="string">50</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Async02Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Async02Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;task.pool&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskThreadPoolConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> corePoolSize;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxPoolSize;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> keepAliveSeconds;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> queueCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskExecutePool</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TaskThreadPoolConfig config;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Executor <span class="title function_">myTaskAsyncPool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        <span class="comment">//核心线程池大小</span></span><br><span class="line">        executor.setCorePoolSize(config.getCorePoolSize());</span><br><span class="line">        <span class="comment">//最大线程数</span></span><br><span class="line">        executor.setMaxPoolSize(config.getMaxPoolSize());</span><br><span class="line">        <span class="comment">//队列容量</span></span><br><span class="line">        executor.setQueueCapacity(config.getQueueCapacity());</span><br><span class="line">        <span class="comment">//活跃时间</span></span><br><span class="line">        executor.setKeepAliveSeconds(config.getKeepAliveSeconds());</span><br><span class="line">        <span class="comment">//线程名字前缀</span></span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">&quot;myExecutor-&quot;</span>);</span><br><span class="line">        <span class="comment">//setRejectedExecutionHandler：当 pool 已经达到 max size 的时候，如何处理新任务</span></span><br><span class="line">        <span class="comment">//CallerRunsPolicy: 不在新线程中执行任务，而是由调用者所在的线程来执行</span></span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//用来设置线程池关闭的时候等待所有任务都完成再继续销毁其他的 Bean，这样这些异步任务的销毁就会先于 Redis 线程池的销毁</span></span><br><span class="line">        executor.setWaitForTasksToCompleteOnShutdown(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//用来设置线程池中任务的等待时间，如果超过这个时间还没有销毁就强制销毁，以确保应用最后能够被关闭，而不是阻塞住</span></span><br><span class="line">        executor.setAwaitTerminationSeconds(<span class="number">60</span>);</span><br><span class="line">        <span class="comment">//线程初始化</span></span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过指定@Async 中的值去找对应的 Bean，从而获取自定义的线程池</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncTask</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(AsyncTask.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//myTaskAsynPool 即配置线程池的方法名，此处如果不写自定义线程池的方法名，会使用默认的线程池</span></span><br><span class="line">    <span class="meta">@Async(&quot;myTaskAsyncPool&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doTask1</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;task:&quot;</span> + i + <span class="string">&quot; start&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Async02ApplicationTests</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AsyncTask asyncTask;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            asyncTask.doTask1(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实现接口-AsyncConfigurer">实现接口 AsyncConfigurer</h4>
<p>AsyncConfigurer 接口是 Spring 框架用于全局配置异步执行器（即线程池）的核心接口。当我们的 Spring 应用需要统一管理所有异步任务的执行环境时，可以选择实现此接口</p>
<p>使用@EnableAsync 后会导入 AsyncConfigurationSelector 类，根据代理类型返回对应的类（默认为 PROXY，即 ProxyAsyncConfiguration 类），ProxyAsyncConfiguration 会实例化 AsyncAnnotationBeanPostProcessor，并注入对应的实现 AsyncConfigurer 接口的类</p>
<p><img src="6.png" alt=""></p>
<p><img src="7.png" alt=""></p>
<p><img src="8.png" alt=""></p>
<p><img src="9.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AsyncConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">default</span> Executor <span class="title function_">getAsyncExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">default</span> AsyncUncaughtExceptionHandler <span class="title function_">getAsyncUncaughtExceptionHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>getAsyncExecutor()：用于实现自定义线程池，控制并发数</li>
</ol>
<ul>
<li>在 getAsyncExecutor()中创建线程池的时候，必须使用 executor.initialize()，不然在调用时会报线程池未初始化的异常</li>
<li>如果使用 threadPoolTaskExecutor()来定义 bean，则不需要初始化</li>
</ul>
<ol start="2">
<li>getAsyncUncaughtExceptionHandler()：用于处理异步方法的异常</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NativeAsyncTaskExecutePool</span> <span class="keyword">implements</span> <span class="title class_">AsyncConfigurer</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TaskThreadPoolConfig config;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Executor <span class="title function_">getAsyncExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        <span class="comment">//核心线程池大小</span></span><br><span class="line">        executor.setCorePoolSize(config.getCorePoolSize());</span><br><span class="line">        <span class="comment">//最大线程数</span></span><br><span class="line">        executor.setMaxPoolSize(config.getMaxPoolSize());</span><br><span class="line">        <span class="comment">//队列容量</span></span><br><span class="line">        executor.setQueueCapacity(config.getQueueCapacity());</span><br><span class="line">        <span class="comment">//活跃时间</span></span><br><span class="line">        executor.setKeepAliveSeconds(config.getKeepAliveSeconds());</span><br><span class="line">        <span class="comment">//线程名字前缀</span></span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">&quot;MyExecutor-&quot;</span>);</span><br><span class="line">        <span class="comment">//CallerRunsPolicy：不在新线程中执行任务，而是由调用者所在的线程来执行</span></span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line">        <span class="comment">//线程初始化</span></span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Bean</span></span><br><span class="line"><span class="comment">//    public ThreadPoolTaskExecutor threadPoolTaskExecutor()&#123;</span></span><br><span class="line"><span class="comment">//        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();</span></span><br><span class="line"><span class="comment">//        executor.setCorePoolSize(10);</span></span><br><span class="line"><span class="comment">//        executor.setMaxPoolSize(100);</span></span><br><span class="line"><span class="comment">//        executor.setQueueCapacity(100);</span></span><br><span class="line"><span class="comment">//        return executor;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异步任务中异常处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> AsyncUncaughtExceptionHandler <span class="title function_">getAsyncUncaughtExceptionHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AsyncUncaughtExceptionHandler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleUncaughtException</span><span class="params">(Throwable ex, Method method, Object... params)</span> &#123;</span><br><span class="line">                log.error(<span class="string">&quot;@Async调用异常，出现异常的方法：&#123;&#125;，参数：&#123;&#125;，异常信息：&#123;&#125;&quot;</span>, method.getDeclaringClass().getName() + <span class="string">&quot;.&quot;</span></span><br><span class="line">                        + method.getName(), JSON.toJSONString(params), ex.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="继承-AsyncConfigurerSupport">继承 AsyncConfigurerSupport</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncConfigurerSupport</span> <span class="keyword">implements</span> <span class="title class_">AsyncConfigurer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AsyncConfigurerSupport</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Executor <span class="title function_">getAsyncExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> AsyncUncaughtExceptionHandler <span class="title function_">getAsyncUncaughtExceptionHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Async-注意点">@Async 注意点</h2>
<h3 id="失效情况">失效情况</h3>
<ol>
<li>异步方法使用 static 修饰</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">async</span><span class="params">(String value)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;async:&#123;&#125;&quot;</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时@Async 的异步功能会失效，因为这种情况 idea 会直接报错：<code>Methods annotated with '@Async' must be overridable</code> 。<br>
使用@Async 注解声明的方法，必须是能被重写的，很显然 static 修饰的方法，是类的静态方法，是不允许被重写的。因此这种情况下，@Async 注解的异步功能会失效。</p>
<ol start="2">
<li>方法用 final 修饰</li>
</ol>
<p>在 Java 种 final 关键字，是一个非常特别的存在。</p>
<ul>
<li>用 final 修饰的类，没法被继承。</li>
<li>用 final 修饰的方法，没法被重写。</li>
<li>用 final 修饰的变量，没法被修改。</li>
</ul>
<p>如果 final 使用不当，也会导致@Async 注解的异步功能失效，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        async(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">async</span><span class="params">(String value)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;async:&#123;&#125;&quot;</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种情况下 idea 也会直接报错：<code>Methods annotated with '@Async' must be overridable</code> 。</p>
<p>因为使用 final 关键字修饰的方法，是没法被子类重写的。因此这种情况下，@Async 注解的异步功能会失效。</p>
<ol start="3">
<li>
<p>异步类没有使用@Component 注解导致 Spring 无法扫描到异步类</p>
</li>
<li>
<p>需要在启动类上添加@EnableAsync 注解</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>异步方法在同一个类中调用</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        async(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">async</span><span class="params">(String value)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;async:&#123;&#125;&quot;</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>方法不是 public</li>
</ol>
<p>private 修饰的方法，只能在 UserService 类的对象中使用。而@Async 注解的异步功能，需要使用 Spring 的 AOP 生成 UserService 类的代理对象，该代理对象没法访问 UserService 类的 private 方法，因此会出现@Async 注解失效的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">async</span><span class="params">(String value)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;async:&#123;&#125;&quot;</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>方法返回值错误</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">async</span><span class="params">(String value)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;async:&#123;&#125;&quot;</span>, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 AsyncExecutionInterceptor 类的 invoke()方法，会调用它的父类 AsyncExecutionAspectSupport 中的 doSubmit 方法，该方法时异步功能的核心代码，如下：</p>
<p><img src="10.png" alt=""></p>
<p>从上面看出，@Async 注解的异步方法的返回值，要么是 Future，要么是 null。<br>
因此，在实际项目中，如果想要使用 <code>@Async</code> 注解的异步功能，相关方法的返回值必须是 void 或者 Future</p>
<h3 id="事务使用">事务使用</h3>
<p>在 Async 方法上标注@Transactional 是没用的，在 Async 方法中调用的方法上添加@Transactional 有效</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无效事务方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">doTaskOne2</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;start 任务1...&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;任务1结束&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="异常情况">异常情况</h3>
<ol>
<li>异步方法中抛出的异常不能直接捕获，因为调用者将无法获取到异常。建议使用 Future 或 CompletableFuture 来捕获异步方法的异常并进行处理</li>
<li>异步方法的执行是非阻塞的，它们可能以任意顺序完成。如果需要按照特定的顺序处理结果，可以使用 CompletableFuture 的 thenApply 方法或者使用@Async 的 order 属性来指定顺序</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>异步多线程</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot Task</title>
    <url>/blog/2024/11/08/Java/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/SpringBoot%20Task/</url>
    <content><![CDATA[<h2 id="参数详解">参数详解</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Repeatable(Schedules.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Scheduled &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">CRON_DISABLED</span> <span class="operator">=</span> <span class="string">&quot;-&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    String <span class="title function_">cron</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    String <span class="title function_">zone</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">long</span> <span class="title function_">fixedDelay</span><span class="params">()</span> <span class="keyword">default</span> -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    String <span class="title function_">fixedDelayString</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">long</span> <span class="title function_">fixedRate</span><span class="params">()</span> <span class="keyword">default</span> -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    String <span class="title function_">fixedRateString</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">long</span> <span class="title function_">initialDelay</span><span class="params">()</span> <span class="keyword">default</span> -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    String <span class="title function_">initialDelayString</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="fixedDelay">fixedDelay</h3>
<p>它的间隔时间是根据上次任务结束的时候开始计时的，只要盯紧上一次任务执行结束的时间即可，跟任务逻辑的执行时间无关，两个任务的间隔时间是固定的</p>
<p><img src="1.png" alt=""></p>
<h3 id="fixedDelayString">fixedDelayString</h3>
<p>与 fixedDalay 一样，不同的是使用的是 String 字符串，支持占位符方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scheduled(fixedDelayString = &quot;$&#123;time.fixedDelay&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Execute at &quot;</span> + System.currentTimeMillis());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="fixedRate">fixedRate</h3>
<p>在理想情况下，下一次开始和上一次开始之间的时间间隔是一定的，但是默认情况下 SpringBoot 定时任务是单线程执行的。当下一轮的任务满足时间策略后任务就会加入队列，即当本次任务开始执行时下一次任务的时间就已经确定了，由于本次任务的“超时”执行，下一次任务的等待时间就会被压缩甚至阻塞</p>
<p><img src="2.png" alt=""></p>
<h3 id="fixedRateString">fixedRateString</h3>
<p>与 fixedRate 一样，不同的是使用的是 String 字符串，支持占位符方式</p>
<h3 id="initialDelay">initialDelay</h3>
<p>这个参数只能配合 fixedDelay 或 fixedRate 使用。如：@Scheduled(initialDelay = 10000, fixedRate = 15000)，意思是在容器启动后，延迟 10 秒再执行一次定时器，以后每 15 秒再执行一次该定时器</p>
<h3 id="initialDelayString">initialDelayString</h3>
<p>与 initialDelay 一样，不同的是使用的是 String 字符串，支持占位符方式</p>
<h3 id="cron-表达式">cron 表达式</h3>
<p>语法格式：</p>
<ol>
<li>
<p>秒 分 小时 月份中的日期 月份 星期中的日期 年份</p>
</li>
<li>
<p>秒 分 小时 月份中的日期 月份 星期中的日期</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>字段</th>
<th>值</th>
<th>特殊字符</th>
</tr>
</thead>
<tbody>
<tr>
<td>秒（Seconds）</td>
<td>0~59 的整数</td>
<td>, - * /</td>
</tr>
<tr>
<td>分（Minutes）</td>
<td>0~59 的整数</td>
<td>, - * /</td>
</tr>
<tr>
<td>小时（Hours）</td>
<td>0~23 的整数</td>
<td>, - * /</td>
</tr>
<tr>
<td>日期（DayofMonth）</td>
<td>1~31 的整数（需要看月的天数）</td>
<td>, - * ? / L W C</td>
</tr>
<tr>
<td>月份（Month）</td>
<td>1~12 的整数</td>
<td>, - * /</td>
</tr>
<tr>
<td>星期（DayOfWeek）</td>
<td>1~7 的整数</td>
<td>, - * ? / L W C</td>
</tr>
<tr>
<td>年（Year）（可选）</td>
<td>1970~2099</td>
<td>, - * /</td>
</tr>
</tbody>
</table>
<ol>
<li>
<p>*：表示匹配该域的任意值。</p>
<p>例如：在 Minutes 域使用*，即表示每分钟都会触发事件</p>
</li>
<li>
<p>?：只能用在 DayofMonth 和 DayofWeek 两个域，它也匹配域的任意值，但实际不会，因为 DayofMonth 和 DayofWeek 会相互影响。</p>
<p>例如：在每月的 20 日触发任务，不管 20 日是星期几，只能使用如下写法：13 13 15 20 * ?，其中最后一位只能用?，而不能使用*，如果使用*表示不管星期几都会触发</p>
</li>
<li>
<p>-：表示范围。</p>
<p>例如：在 Minutes 域使用 5-20，表示从 5 到 20 分钟每分钟触发一次</p>
</li>
<li>
<p>/：表示起始时间开始触发，然后每隔固定时间触发一次。</p>
<p>例如：在 Minutes 域使用 5/20，则意味着从第 5 分钟开始，每隔 20 分钟触发一次</p>
</li>
<li>
<p>,：表示列出枚举值。</p>
<p>例如：在 Minutes 域使用 5,20，则意味着在 5 和 20 分都会触发一次</p>
</li>
<li>
<p>L：表示最后，只能出现在 DayofWeek 和 DayofMonth 域。</p>
<p>例如：在 DayofWeek 域使用 5L，意味着在最后的一个星期四触发</p>
</li>
<li>
<p>W：表示有效工作日（周一到周五），只能出现在 DayofMonth 域，系统将在离指定日期的最近的有效工作日触发事件。</p>
<p>例如：在 DayofMonth 使用 5W，如果 5 日是星期六，则将在最近的工作日（星期五，即 4 日触发）；如果 5 日是星期天，则在 6 日（星期一）触发；如果 5 日在星期一到星期五中的一天，则就在 5 日触发。注意：W 的最近寻找不会跨过月份</p>
</li>
<li>
<p>LW：这两个字符可以连用，表示在某个月最后一个工作日，即最后一个星期五</p>
</li>
<li>
<p>#：用于确定每个月第 n 个星期 x（x#n），只能出现在 DayofMonth 域。</p>
<p>例如：4#2 表示第 2 个星期三</p>
</li>
</ol>
<p><strong>常用表达式参考</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;*/5 * * * * ?&quot;</span>       # 每隔<span class="number">5</span>秒执行一次</span><br><span class="line"><span class="string">&quot;0 */1 * * * ?&quot;</span>       # 每隔<span class="number">1</span>分钟执行一次</span><br><span class="line"><span class="string">&quot;0 0 23 * * ?&quot;</span>        # 每天<span class="number">23</span>点执行一次</span><br><span class="line"><span class="string">&quot;0 0 1 * * ?&quot;</span>         # 每天凌晨<span class="number">1</span>点执行一次</span><br><span class="line"><span class="string">&quot;0 0 1 1 * ?&quot;</span>         # 每月<span class="number">1</span>号凌晨<span class="number">1</span>点执行一次</span><br><span class="line"><span class="string">&quot;0 0 23 L * ?&quot;</span>        # 每月最后一天<span class="number">23</span>点执行一次</span><br><span class="line"><span class="string">&quot;0 0 1 ? * L&quot;</span>         # 每周星期天凌晨<span class="number">1</span>点实行一次：</span><br><span class="line"><span class="string">&quot;0 26,29,33 * * * ?&quot;</span>  # 在<span class="number">26</span>分、<span class="number">29</span>分、<span class="number">33</span>分执行一次</span><br><span class="line"><span class="string">&quot;0 0 0,3,8,21 * * ?&quot;</span>  # 每天的<span class="number">0</span>点、<span class="number">3</span>点、<span class="number">8</span>点、<span class="number">21</span>点执行一次</span><br><span class="line"><span class="string">&quot;0 0 10,14,16 * * ?&quot;</span>  # 每天上午<span class="number">10</span>点，下午<span class="number">2</span>点，<span class="number">4</span>点</span><br><span class="line"><span class="string">&quot;0 0/30 9-17 * * ?&quot;</span>   # 朝九晚五工作时间内每半小时</span><br><span class="line"><span class="string">&quot;0 0 12 ? * WED&quot;</span>      # 表示每个星期三中午<span class="number">12</span>点</span><br><span class="line"><span class="string">&quot;0 0 12 * * ?&quot;</span>        # 每天中午<span class="number">12</span>点触发</span><br><span class="line"><span class="string">&quot;0 15 10 ? * *&quot;</span>       # 每天上午<span class="number">10</span>:<span class="number">15</span>触发</span><br><span class="line"><span class="string">&quot;0 15 10 * * ?&quot;</span>       # 每天上午<span class="number">10</span>:<span class="number">15</span>触发</span><br><span class="line"><span class="string">&quot;0 15 10 * * ? *&quot;</span>     # 每天上午<span class="number">10</span>:<span class="number">15</span>触发</span><br><span class="line"><span class="string">&quot;0 15 10 * * ?&quot;</span>       # <span class="number">2005</span><span class="string">&quot; 2005年的每天上午10:15触发</span></span><br><span class="line"><span class="string">&quot;</span><span class="number">0</span> * <span class="number">14</span> * * ?<span class="string">&quot;        # 在每天下午2点到下午2:59期间的每1分钟触发</span></span><br><span class="line"><span class="string">&quot;</span><span class="number">0</span> <span class="number">0</span>/<span class="number">5</span> <span class="number">14</span> * * ?<span class="string">&quot;      # 在每天下午2点到下午2:55期间的每5分钟触发</span></span><br><span class="line"><span class="string">&quot;</span><span class="number">0</span> <span class="number">0</span>/<span class="number">5</span> <span class="number">14</span>,<span class="number">18</span> * * ?<span class="string">&quot;   # 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发</span></span><br><span class="line"><span class="string">&quot;</span><span class="number">0</span> <span class="number">0</span>-<span class="number">5</span> <span class="number">14</span> * * ?<span class="string">&quot;      # 在每天下午2点到下午2:05期间的每1分钟触发</span></span><br><span class="line"><span class="string">&quot;</span><span class="number">0</span> <span class="number">10</span>,<span class="number">44</span> <span class="number">14</span> ? <span class="number">3</span> WED<span class="string">&quot;  # 每年三月的星期三的下午2:10和2:44触发</span></span><br><span class="line"><span class="string">&quot;</span><span class="number">0</span> <span class="number">15</span> <span class="number">10</span> ? * MON-FRI<span class="string">&quot; # 周一至周五的上午10:15触发</span></span><br><span class="line"><span class="string">&quot;</span><span class="number">0</span> <span class="number">15</span> <span class="number">10</span> <span class="number">15</span> * ?<span class="string">&quot;      # 每月15日上午10:15触发</span></span><br><span class="line"><span class="string">&quot;</span><span class="number">0</span> <span class="number">15</span> <span class="number">10</span> L * ?<span class="string">&quot;       # 每月最后一日的上午10:15触发</span></span><br><span class="line"><span class="string">&quot;</span><span class="number">0</span> <span class="number">15</span> <span class="number">10</span> ? * <span class="number">6L</span><span class="string">&quot;      # 每月的最后一个星期五上午10:15触发</span></span><br><span class="line"><span class="string">&quot;</span><span class="number">0</span> <span class="number">15</span> <span class="number">10</span> ? * <span class="number">6</span>#<span class="number">3</span><span class="string">&quot;     # 每月的第三个星期五上午10:15触发</span></span><br><span class="line"><span class="string">&quot;</span><span class="number">0</span> <span class="number">15</span> <span class="number">10</span> ? * <span class="number">6L</span> <span class="number">2002</span>-<span class="number">2005</span><span class="string">&quot; # 2002年至2005年的每月的最后一个星期五上午10:15触发</span></span><br></pre></td></tr></table></figure>
<h2 id="基本使用">基本使用</h2>
<h3 id="基本方法">基本方法</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">// 开启定时任务开关</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringtaskApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringtaskApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskService01</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Scheduled(fixedDelay = 1000)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">task01</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;fixedDelay....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Scheduled(fixedRate = 1000)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">task02</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;fixedRate....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Scheduled(initialDelay = 10000,fixedDelay = 1000)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">task03</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;initialDelay&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;1 * * * * *&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">task04</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cron&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定时任务开-关">定时任务开/关</h3>
<p>通过配置文件控制Bean的实例化，根据需要进行开启/关闭定时任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;test.job&quot;, name = &quot;enable&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJob</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;1 * * * * *&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">task04</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cron&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="定时任务配置">定时任务配置</h2>
<p>@EnableScheduling 注解引入了 ScheduledAnnotationBeanPostProcessor 其 setScheduler(Object scheduler) 有以下的注释：</p>
<p>如果 TaskScheduler 或者 ScheduledExecutorService 没有定义为该方法的参数，该方法将在 Spring IoC 中寻找唯一的 TaskScheduler 或者名称为 taskScheduler 的 Bean 作为参数，当然你按照查找 TaskScheduler 的方法找一个 ScheduledExecutorService 也可以。要是都找不到那么只能使用本地单线程调度器了</p>
<p><img src="5.png" alt=""></p>
<p><img src="3.png" alt=""></p>
<h3 id="执行器">执行器</h3>
<p>SpringBoot 内默认自动配置 TaskExecutor 任务执行器线程池，主要用于执行单次任务</p>
<h4 id="自动配置条件">自动配置条件</h4>
<ol>
<li>当类路径下存在 ThreadPoolTaskExecutor 类</li>
<li>当 Spring 容器中不存在 Executor 的 bean</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 仅在类 ThreadPoolTaskExecutor 存在于 classpath 时才应用</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(ThreadPoolTaskExecutor.class)</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(TaskExecutionProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskExecutionAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">APPLICATION_TASK_EXECUTOR_BEAN_NAME</span> <span class="operator">=</span> <span class="string">&quot;applicationTaskExecutor&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="keyword">public</span> TaskExecutorBuilder <span class="title function_">taskExecutorBuilder</span><span class="params">(TaskExecutionProperties properties,</span></span><br><span class="line"><span class="params">            ObjectProvider&lt;TaskExecutorCustomizer&gt; taskExecutorCustomizers,</span></span><br><span class="line"><span class="params">            ObjectProvider&lt;TaskDecorator&gt; taskDecorator)</span> &#123;</span><br><span class="line">        TaskExecutionProperties.<span class="type">Pool</span> <span class="variable">pool</span> <span class="operator">=</span> properties.getPool();</span><br><span class="line">        <span class="type">TaskExecutorBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskExecutorBuilder</span>();</span><br><span class="line">        builder = builder.queueCapacity(pool.getQueueCapacity());</span><br><span class="line">        builder = builder.corePoolSize(pool.getCoreSize());</span><br><span class="line">        builder = builder.maxPoolSize(pool.getMaxSize());</span><br><span class="line">        builder = builder.allowCoreThreadTimeOut(pool.isAllowCoreThreadTimeout());</span><br><span class="line">        builder = builder.keepAlive(pool.getKeepAlive());</span><br><span class="line">        <span class="type">Shutdown</span> <span class="variable">shutdown</span> <span class="operator">=</span> properties.getShutdown();</span><br><span class="line">        builder = builder.awaitTermination(shutdown.isAwaitTermination());</span><br><span class="line">        builder = builder.awaitTerminationPeriod(shutdown.getAwaitTerminationPeriod());</span><br><span class="line">        builder = builder.threadNamePrefix(properties.getThreadNamePrefix());</span><br><span class="line">        builder = builder.customizers(taskExecutorCustomizers.orderedStream()::iterator);</span><br><span class="line">        builder = builder.taskDecorator(taskDecorator.getIfUnique());</span><br><span class="line">        <span class="keyword">return</span> builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Lazy</span></span><br><span class="line">    <span class="meta">@Bean(name = &#123; APPLICATION_TASK_EXECUTOR_BEAN_NAME,</span></span><br><span class="line"><span class="meta">            AsyncAnnotationBeanPostProcessor.DEFAULT_TASK_EXECUTOR_BEAN_NAME &#125;)</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(Executor.class)</span></span><br><span class="line">    <span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title function_">applicationTaskExecutor</span><span class="params">(TaskExecutorBuilder builder)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> builder.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="线程池配置">线程池配置</h4>
<p>TaskExecutionProperties 默认值：</p>
<ol>
<li>线程名称前缀：threadNamePrefix = “task-”</li>
<li>核心线程数：coreSize = 8</li>
<li>最大线程数：maxSize = Integer.MAX_VALUE</li>
<li>非核心线程存活时长：keepAlive = Duration.ofSeconds(60)</li>
</ol>
<h3 id="调度器">调度器</h3>
<p>SpringBoot 内默认自动配置 TaskScheduler 任务调度器线程池，主要用于执行周期性任务</p>
<h4 id="自动配置条件-2">自动配置条件</h4>
<ol>
<li>当类路径下存在 ThreadPoolTaskScheduler 类</li>
<li>当 Spring 容器中不存在 SchedulingConfigurer 、 TaskScheduler 、ScheduledExecutorService 的 bean</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnClass(ThreadPoolTaskScheduler.class)</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(TaskSchedulingProperties.class)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(TaskExecutionAutoConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskSchedulingAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnBean(name = TaskManagementConfigUtils.SCHEDULED_ANNOTATION_PROCESSOR_BEAN_NAME)</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(&#123; SchedulingConfigurer.class, TaskScheduler.class, ScheduledExecutorService.class &#125;)</span></span><br><span class="line">    <span class="keyword">public</span> ThreadPoolTaskScheduler <span class="title function_">taskScheduler</span><span class="params">(TaskSchedulerBuilder builder)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> builder.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="keyword">public</span> TaskSchedulerBuilder <span class="title function_">taskSchedulerBuilder</span><span class="params">(TaskSchedulingProperties properties,</span></span><br><span class="line"><span class="params">            ObjectProvider&lt;TaskSchedulerCustomizer&gt; taskSchedulerCustomizers)</span> &#123;</span><br><span class="line">        <span class="type">TaskSchedulerBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskSchedulerBuilder</span>();</span><br><span class="line">        builder = builder.poolSize(properties.getPool().getSize());</span><br><span class="line">        <span class="type">Shutdown</span> <span class="variable">shutdown</span> <span class="operator">=</span> properties.getShutdown();</span><br><span class="line">        builder = builder.awaitTermination(shutdown.isAwaitTermination());</span><br><span class="line">        builder = builder.awaitTerminationPeriod(shutdown.getAwaitTerminationPeriod());</span><br><span class="line">        builder = builder.threadNamePrefix(properties.getThreadNamePrefix());</span><br><span class="line">        builder = builder.customizers(taskSchedulerCustomizers);</span><br><span class="line">        <span class="keyword">return</span> builder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>当 Spring 容器中存在名字叫 org.springframework.context.annotation.internalScheduledAnnotationProcessor （需要配置 @EnableScheduling 注解将会注入这个名字的 bean）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Import(SchedulingConfiguration.class)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableScheduling &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SchedulingConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = TaskManagementConfigUtils.SCHEDULED_ANNOTATION_PROCESSOR_BEAN_NAME)</span></span><br><span class="line">    <span class="meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class="line">    <span class="keyword">public</span> ScheduledAnnotationBeanPostProcessor <span class="title function_">scheduledAnnotationProcessor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduledAnnotationBeanPostProcessor</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="线程池配置-2">线程池配置</h4>
<p>TaskSchedulingProperties 默认配置值：</p>
<ol>
<li>线程名称前缀：threadNamePrefix = “scheduling-”</li>
<li>线程数：size = 1</li>
</ol>
<p>该配置的自定义配置以 spring.task.scheduling 开头。同时它需要在任务执行器配置 TaskExecutionAutoConfiguration 配置后才生效。我们只需要在中对其配置属性 spring.task.execution 相关属性配置即可。</p>
<p>注意：定义任务默认用的是 TaskSchedulingAutoConfiguration 实例化的 Bean（applicationTaskExecutor、taskScheduler）</p>
<h3 id="Properties-配置">Properties 配置</h3>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">######任务调度线程池######</span></span><br><span class="line"><span class="comment"># 任务调度线程池大小 默认 1 建议根据任务加大</span></span><br><span class="line"><span class="attr">spring.task.scheduling.pool.size</span>=<span class="string">1</span></span><br><span class="line"><span class="comment"># 调度线程名称前缀 默认 scheduling-</span></span><br><span class="line"><span class="attr">spring.task.scheduling.thread-name-prefix</span>=<span class="string">scheduling-</span></span><br><span class="line"><span class="comment"># 线程池关闭时等待所有任务完成</span></span><br><span class="line"><span class="attr">spring.task.scheduling.shutdown.await-termination</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 调度线程关闭前最大等待时间，确保最后一定关闭</span></span><br><span class="line"><span class="attr">spring.task.scheduling.shutdown.await-termination-period</span>=<span class="string">60</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">######任务执行线程池配置######</span></span><br><span class="line"><span class="comment"># 是否允许核心线程超时。这样可以动态增加和缩小线程池</span></span><br><span class="line"><span class="attr">spring.task.execution.pool.allow-core-thread-timeout</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#  核心线程池大小 默认 8</span></span><br><span class="line"><span class="attr">spring.task.execution.pool.core-size</span>=<span class="string">8</span></span><br><span class="line"><span class="comment"># 线程空闲等待时间 默认 60s</span></span><br><span class="line"><span class="attr">spring.task.execution.pool.keep-alive</span>=<span class="string">60s</span></span><br><span class="line"><span class="comment"># 线程池最大数  根据任务定制</span></span><br><span class="line"><span class="attr">spring.task.execution.pool.max-size</span>=<span class="string">16</span></span><br><span class="line"><span class="comment">#  线程池 队列容量大小</span></span><br><span class="line"><span class="attr">spring.task.execution.pool.queue-capacity</span>=<span class="string">10</span></span><br><span class="line"><span class="comment"># 线程池关闭时等待所有任务完成</span></span><br><span class="line"><span class="attr">spring.task.execution.shutdown.await-termination</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 执行线程关闭前最大等待时间，确保最后一定关闭</span></span><br><span class="line"><span class="attr">spring.task.execution.shutdown.await-termination-period</span>=<span class="string">60</span></span><br><span class="line"><span class="comment"># 线程名称前缀</span></span><br><span class="line"><span class="attr">spring.task.execution.thread-name-prefix</span>=<span class="string">task-</span></span><br></pre></td></tr></table></figure>
<h4 id="TaskSchedulingAutoConfiguration-源码">TaskSchedulingAutoConfiguration 源码</h4>
<p>当 Spring Boot 应用程序中没有定义自定义的线程池 bean 时，Spring Boot 应用程序会根据自动配置类注入一个名为 applicationTaskExecutor 或 taskExecutor 的线程池对象，它的配置是在 TaskExecutionProperties 类中完成的，这个类使用 spring.task.execution 前缀进行配置，包含了很多线程池相关细节的配置选项，当我们容器中存在自定义线程池时，applicationTaskExecutor 或 taskExecutor 的线程池对象是不会被创建的。</p>
<h4 id="Async-注解相关配置">@Async 注解相关配置</h4>
<p>使用@Async 注解没有指定 value 属性时，项目启动的时候会有这样的提示：“在上下文中找到多个 TaskExecutor bean，并且没有一个名为’ taskExecutor’。将其中一个标记为 primary 或将其命名为’taskExecutor’（可能作为别名），以便将其用于异步处理”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 标记为 Primary，即主要的线程</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title function_">threadPoolTaskExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">    executor.setThreadNamePrefix(<span class="string">&quot;my-free-style-&quot;</span>);</span><br><span class="line">    executor.setMaxPoolSize(maxPoolSize);</span><br><span class="line">    executor.setCorePoolSize(corePoolSize);</span><br><span class="line">    executor.setQueueCapacity(queueCapacity);</span><br><span class="line">    executor.setKeepAliveSeconds(keepAliveSeconds);</span><br><span class="line">    <span class="comment">// 线程池对拒绝任务(无线程可用)的处理策略</span></span><br><span class="line">    executor.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 直接起别名为 taskExecutor</span></span><br><span class="line"><span class="meta">@Bean(name = &quot;taskExecutor&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title function_">threadPoolTaskExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">    executor.setThreadNamePrefix(<span class="string">&quot;my-free-style-&quot;</span>);</span><br><span class="line">    executor.setMaxPoolSize(maxPoolSize);</span><br><span class="line">    executor.setCorePoolSize(corePoolSize);</span><br><span class="line">    executor.setQueueCapacity(queueCapacity);</span><br><span class="line">    executor.setKeepAliveSeconds(keepAliveSeconds);</span><br><span class="line">    <span class="comment">// 线程池对拒绝任务(无线程可用)的处理策略</span></span><br><span class="line">    executor.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="任务阻塞">任务阻塞</h2>
<h3 id="出现原因">出现原因</h3>
<p>Spring 中@EnableScheduling 和@Scheduled 标注的定时任务默认单线程同步执行，多个任务时，一个任务执行完毕以后才能执行下一个任务，可能会有阻塞现象发生（如果希望并发运行，需要配置线程池）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootTaskApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringbootTaskApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduleTask1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;*/2 * * * * ?&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">task1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;我是task1，我需要执行 10s 钟的时间，我的线程的 id == &gt; &#123;&#125;，时间 == &gt;&#123;&#125;&quot;</span>, Thread.currentThread().getId(), <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        log.info(<span class="string">&quot;我是task1 ending ,我的线程的 id == &gt; &#123;&#125; , 时间 == &gt; &#123;&#125;&quot;</span>, Thread.currentThread().getId(), <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;*/4 * * * * ?&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">task2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;我是task2，我需要执行 2s 钟的时间，我的线程的 id == &gt; &#123;&#125;，时间 == &gt;&#123;&#125;&quot;</span>, Thread.currentThread().getId(), <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        log.info(<span class="string">&quot;我是task2 ending ,我的线程的 id == &gt; &#123;&#125; , 时间 == &gt; &#123;&#125;&quot;</span>,Thread.currentThread().getId(), <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">我是task1，我需要执行 10s 钟的时间，我的线程的 id == &gt; <span class="number">95</span>，时间 == &gt;Fri Feb <span class="number">01</span> <span class="number">15</span>:<span class="number">16</span>:<span class="number">52</span> CST <span class="number">2019</span></span><br><span class="line">我是task1 ending ,我的线程的 id == &gt; <span class="number">95</span> , 时间 == &gt; Fri Feb <span class="number">01</span> <span class="number">15</span>:<span class="number">17</span>:<span class="number">02</span> CST <span class="number">2019</span></span><br><span class="line">我是task2，我需要执行 2s 钟的时间，我的线程的 id == &gt; <span class="number">95</span>，时间 == &gt;Fri Feb <span class="number">01</span> <span class="number">15</span>:<span class="number">17</span>:<span class="number">02</span> CST <span class="number">2019</span></span><br><span class="line">task2 ending ,我的线程的 id == &gt; <span class="number">95</span> , 时间 == &gt; Fri Feb <span class="number">01</span> <span class="number">15</span>:<span class="number">17</span>:<span class="number">04</span> CST <span class="number">2019</span></span><br><span class="line">我是task1，我需要执行 10s 钟的时间，我的线程的 id == &gt; <span class="number">95</span>，时间 == &gt;Fri Feb <span class="number">01</span> <span class="number">15</span>:<span class="number">17</span>:<span class="number">04</span> CST <span class="number">2019</span></span><br><span class="line">task1 ending ,我的线程的 id == &gt; <span class="number">95</span> , 时间 == &gt; Fri Feb <span class="number">01</span> <span class="number">15</span>:<span class="number">17</span>:<span class="number">14</span> CST <span class="number">2019</span></span><br></pre></td></tr></table></figure>
<p>可以看出，从 task1 任务运行时，等到 4s 时，task2 任务没有执行，而是等到 task1 任务执行结束后才执行</p>
<h3 id="解决方法">解决方法</h3>
<h4 id="使用-Async-异步执行任务">使用@Async 异步执行任务</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootTaskApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringbootTaskApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>使用默认线程池配置</li>
</ol>
<p>@Async默认的线程池配置是Bean名称为taskExecutor的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduleTask2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;*/2 * * * * ?&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">task1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;我是task1，我需要执行 10s 钟的时间，我的线程的 id == &gt; &#123;&#125;，时间 == &gt;&#123;&#125;&quot;</span>, Thread.currentThread().getId(), <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        log.info(<span class="string">&quot;我是task1 ending ,我的线程的 id == &gt; &#123;&#125; , 时间 == &gt; &#123;&#125;&quot;</span>, Thread.currentThread().getId(), <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;*/4 * * * * ?&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">task2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;我是task2，我需要执行 2s 钟的时间，我的线程的 id == &gt; &#123;&#125;，时间 == &gt;&#123;&#125;&quot;</span>, Thread.currentThread().getId(), <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        log.info(<span class="string">&quot;我是task2 ending ,我的线程的 id == &gt; &#123;&#125; , 时间 == &gt; &#123;&#125;&quot;</span>,Thread.currentThread().getId(), <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>自定义线程池配置</li>
</ol>
<p>通过指定Bean名称来决定使用哪个线程池，用户可以自定义线程池配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduleTask3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async(&quot;myPoolTaskExecutor&quot;)</span></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;*/2 * * * * ?&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">task1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;我是task1，我需要执行 10s 钟的时间，我的线程的 id == &gt; &#123;&#125;，时间 == &gt;&#123;&#125;&quot;</span>, Thread.currentThread().getId(), <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        log.info(<span class="string">&quot;我是task1 ending ,我的线程的 id == &gt; &#123;&#125; , 时间 == &gt; &#123;&#125;&quot;</span>, Thread.currentThread().getId(), <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async(&quot;myPoolTaskExecutor&quot;)</span></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;*/4 * * * * ?&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">task2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;我是task2，我需要执行 2s 钟的时间，我的线程的 id == &gt; &#123;&#125;，时间 == &gt;&#123;&#125;&quot;</span>, Thread.currentThread().getId(), <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        log.info(<span class="string">&quot;我是task2 ending ,我的线程的 id == &gt; &#123;&#125; , 时间 == &gt; &#123;&#125;&quot;</span>,Thread.currentThread().getId(), <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 创建自定义线程池，提供异步调用时使用</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;myPoolTaskExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title function_">getMyPoolTaskExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">taskExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        <span class="comment">//核心线程数</span></span><br><span class="line">        taskExecutor.setCorePoolSize(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//线程池维护线程的最大数量, 只有在缓冲队列满了之后才会申请超过核心线程数的线程</span></span><br><span class="line">        taskExecutor.setMaxPoolSize(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">//缓存队列</span></span><br><span class="line">        taskExecutor.setQueueCapacity(<span class="number">50</span>);</span><br><span class="line">        <span class="comment">//许的空闲时间, 当超过了核心线程出之外的线程在空闲时间到达之后会被销毁</span></span><br><span class="line">        taskExecutor.setKeepAliveSeconds(<span class="number">200</span>);</span><br><span class="line">        <span class="comment">//异步方法内部线程名称</span></span><br><span class="line">        taskExecutor.setThreadNamePrefix(<span class="string">&quot;poolTestThread-&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 当线程池的任务缓存队列已满并且线程池中的线程数目达到 maximumPoolSize，如果还有任务到来就会采取任务拒绝策略</span></span><br><span class="line"><span class="comment">         * 通常有以下四种策略：</span></span><br><span class="line"><span class="comment">         * ThreadPoolExecutor.AbortPolicy: 丢弃任务并抛出 RejectedExecutionException 异常。</span></span><br><span class="line"><span class="comment">         * ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。</span></span><br><span class="line"><span class="comment">         * ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</span></span><br><span class="line"><span class="comment">         * ThreadPoolExecutor.CallerRunsPolicy：重试添加当前的任务，自动重复调用 execute() 方法，直到成功</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 拒绝策略</span></span><br><span class="line">        taskExecutor.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line">        taskExecutor.initialize();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;@Async 业务处理线程配置成功，核心线程池：[&#123;&#125;]，最大线程池：[&#123;&#125;]，队列容量：[&#123;&#125;]，线程名称前缀：[&#123;&#125;]&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> taskExecutor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>执行结果</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//运行结果：</span></span><br><span class="line">我是task2，我需要执行 2s 钟的时间，我的线程的 id == &gt; <span class="number">116</span>，时间 == &gt;Fri Feb <span class="number">01</span> <span class="number">16</span>:<span class="number">19</span>:<span class="number">32</span> CST <span class="number">2019</span></span><br><span class="line">我是task1，我需要执行 10s 钟的时间，我的线程的 id == &gt; <span class="number">117</span>，时间 == &gt;Fri Feb <span class="number">01</span> <span class="number">16</span>:<span class="number">19</span>:<span class="number">32</span> CST <span class="number">2019</span></span><br><span class="line">我是task1，我需要执行 10s 钟的时间，我的线程的 id == &gt; <span class="number">124</span>，时间 == &gt;Fri Feb <span class="number">01</span> <span class="number">16</span>:<span class="number">19</span>:<span class="number">34</span> CST <span class="number">2019</span></span><br><span class="line">task2 ending ,我的线程的 id == &gt; <span class="number">116</span> , 时间 == &gt; Fri Feb <span class="number">01</span> <span class="number">16</span>:<span class="number">19</span>:<span class="number">34</span> CST <span class="number">2019</span></span><br><span class="line">我是task1，我需要执行 10s 钟的时间，我的线程的 id == &gt; <span class="number">125</span>，时间 == &gt;Fri Feb <span class="number">01</span> <span class="number">16</span>:<span class="number">19</span>:<span class="number">36</span> CST <span class="number">2019</span></span><br><span class="line">我是task2，我需要执行 2s 钟的时间，我的线程的 id == &gt; <span class="number">126</span>，时间 == &gt;Fri Feb <span class="number">01</span> <span class="number">16</span>:<span class="number">19</span>:<span class="number">36</span> CST <span class="number">2019</span></span><br><span class="line">我是task1，我需要执行 10s 钟的时间，我的线程的 id == &gt; <span class="number">127</span>，时间 == &gt;Fri Feb <span class="number">01</span> <span class="number">16</span>:<span class="number">19</span>:<span class="number">38</span> CST <span class="number">2019</span></span><br><span class="line">task2 ending ,我的线程的 id == &gt; <span class="number">126</span> , 时间 == &gt; Fri Feb <span class="number">01</span> <span class="number">16</span>:<span class="number">19</span>:<span class="number">38</span> CST <span class="number">2019</span></span><br><span class="line">我是task2，我需要执行 2s 钟的时间，我的线程的 id == &gt; <span class="number">128</span>，时间 == &gt;Fri Feb <span class="number">01</span> <span class="number">16</span>:<span class="number">19</span>:<span class="number">40</span> CST <span class="number">2019</span></span><br><span class="line">我是task1，我需要执行 10s 钟的时间，我的线程的 id == &gt; <span class="number">129</span>，时间 == &gt;Fri Feb <span class="number">01</span> <span class="number">16</span>:<span class="number">19</span>:<span class="number">40</span> CST <span class="number">2019</span></span><br></pre></td></tr></table></figure>
<p>从日志可知：task1 和 task2 的确是并行执行的，因为开始的时间节点是一样的。</p>
<p>存在问题：当 task1 第一次任务执行时间过长时，此时 task1 又到了其第二次执行任务的调度时间，这时会并行执行两个任务</p>
<h4 id="实现-SchedulingConfigurer-接口">实现 SchedulingConfigurer 接口</h4>
<p>使用@Async 会导致第一次任务执行时间过长，从而第二次任务和第一次任务并发执行</p>
<p>解决方法：实现 SchedulingConfigurer 接口，这样自动装配中 TaskSchedulingAutoConfiguration 的 taskScheduler 就不会被实例化，替换原来的线程池配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduleConfig</span> <span class="keyword">implements</span> <span class="title class_">SchedulingConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureTasks</span><span class="params">(ScheduledTaskRegistrar taskRegistrar)</span> &#123;</span><br><span class="line">        taskRegistrar.setScheduler(taskExecutor());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Bean</span></span><br><span class="line">     <span class="keyword">public</span> Executor <span class="title function_">taskExecutor</span><span class="params">()</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduleTask4</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;*/2 * * * * ?&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">task1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;我是task1，我需要执行 10s 钟的时间，我的线程的 id == &gt; &#123;&#125;，时间 == &gt;&#123;&#125;&quot;</span>, Thread.currentThread().getId(), <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        log.info(<span class="string">&quot;我是task1 ending ,我的线程的 id == &gt; &#123;&#125; , 时间 == &gt; &#123;&#125;&quot;</span>, Thread.currentThread().getId(), <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;*/4 * * * * ?&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">task2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;我是task2，我需要执行 2s 钟的时间，我的线程的 id == &gt; &#123;&#125;，时间 == &gt;&#123;&#125;&quot;</span>, Thread.currentThread().getId(), <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        log.info(<span class="string">&quot;我是task2 ending ,我的线程的 id == &gt; &#123;&#125; , 时间 == &gt; &#123;&#125;&quot;</span>,Thread.currentThread().getId(), <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>执行结果</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//执行结果：</span></span><br><span class="line">我是task2，我需要执行 2s 钟的时间，我的线程的 id == &gt; <span class="number">95</span>，时间 == &gt;Fri Feb <span class="number">01</span> <span class="number">16</span>:<span class="number">28</span>:<span class="number">16</span> CST <span class="number">2019</span></span><br><span class="line">我是task1，我需要执行 10s 钟的时间，我的线程的 id == &gt; <span class="number">96</span>，时间 == &gt;Fri Feb <span class="number">01</span> <span class="number">16</span>:<span class="number">28</span>:<span class="number">16</span> CST <span class="number">2019</span></span><br><span class="line">task2 ending ,我的线程的 id == &gt; <span class="number">95</span> , 时间 == &gt; Fri Feb <span class="number">01</span> <span class="number">16</span>:<span class="number">28</span>:<span class="number">18</span> CST <span class="number">2019</span></span><br><span class="line">我是task2，我需要执行 2s 钟的时间，我的线程的 id == &gt; <span class="number">95</span>，时间 == &gt;Fri Feb <span class="number">01</span> <span class="number">16</span>:<span class="number">28</span>:<span class="number">20</span> CST <span class="number">2019</span></span><br><span class="line">task2 ending ,我的线程的 id == &gt; <span class="number">95</span> , 时间 == &gt; Fri Feb <span class="number">01</span> <span class="number">16</span>:<span class="number">28</span>:<span class="number">22</span> CST <span class="number">2019</span></span><br><span class="line">我是task2，我需要执行 2s 钟的时间，我的线程的 id == &gt; <span class="number">121</span>，时间 == &gt;Fri Feb <span class="number">01</span> <span class="number">16</span>:<span class="number">28</span>:<span class="number">24</span> CST <span class="number">2019</span></span><br><span class="line">task1 ending ,我的线程的 id == &gt; <span class="number">96</span> , 时间 == &gt; Fri Feb <span class="number">01</span> <span class="number">16</span>:<span class="number">28</span>:<span class="number">26</span> CST <span class="number">2019</span></span><br><span class="line">task2 ending ,我的线程的 id == &gt; <span class="number">121</span> , 时间 == &gt; Fri Feb <span class="number">01</span> <span class="number">16</span>:<span class="number">28</span>:<span class="number">26</span> CST <span class="number">2019</span></span><br><span class="line">我是task1，我需要执行 10s 钟的时间，我的线程的 id == &gt; <span class="number">95</span>，时间 == &gt;Fri Feb <span class="number">01</span> <span class="number">16</span>:<span class="number">28</span>:<span class="number">28</span> CST <span class="number">2019</span></span><br><span class="line">我是task2，我需要执行 2s 钟的时间，我的线程的 id == &gt; <span class="number">122</span>，时间 == &gt;Fri Feb <span class="number">01</span> <span class="number">16</span>:<span class="number">28</span>:<span class="number">28</span> CST <span class="number">2019</span></span><br></pre></td></tr></table></figure>
<p>注意：此时每次定时任务执行的 traceId 是一致的，无法很好地追踪每次定时任务的情况，修改如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduleConfig</span> <span class="keyword">implements</span> <span class="title class_">SchedulingConfigurer</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureTasks</span><span class="params">(ScheduledTaskRegistrar taskRegistrar)</span> &#123;</span><br><span class="line">        <span class="comment">// taskRegistrar.setScheduler(taskExecutor());  </span></span><br><span class="line">        <span class="type">ThreadPoolTaskScheduler</span> <span class="variable">taskScheduler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskScheduler</span>();</span><br><span class="line">		taskScheduler.setPoolSize(<span class="number">10</span>);</span><br><span class="line">		taskScheduler.initialize();</span><br><span class="line">        taskRegistrar.setScheduler(taskScheduler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缺点：可能每次定时任务产生的 traceId 是一致的</span></span><br><span class="line">    <span class="comment">// @Bean</span></span><br><span class="line">    <span class="comment">// public Executor taskExecutor()&#123;</span></span><br><span class="line">    <span class="comment">//     return Executors.newScheduledThreadPool(10);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Properties-配置-2">Properties 配置</h4>
<p>修改默认的线程池配置，适当将调度线程池的配置修改，支持多任务并发执行</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">######任务调度线程池######</span></span><br><span class="line"><span class="comment"># 任务调度线程池大小 默认 1 建议根据任务加大</span></span><br><span class="line"><span class="attr">spring.task.scheduling.pool.size</span>=<span class="string">10</span></span><br><span class="line"><span class="comment"># 调度线程名称前缀 默认 scheduling-</span></span><br><span class="line"><span class="attr">spring.task.scheduling.thread-name-prefix</span>=<span class="string">scheduling-</span></span><br><span class="line"><span class="comment"># 线程池关闭时等待所有任务完成</span></span><br><span class="line"><span class="attr">spring.task.scheduling.shutdown.await-termination</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 调度线程关闭前最大等待时间，确保最后一定关闭</span></span><br><span class="line"><span class="attr">spring.task.scheduling.shutdown.await-termination-period</span>=<span class="string">60</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">######任务执行线程池配置######</span></span><br><span class="line"><span class="comment"># 是否允许核心线程超时。这样可以动态增加和缩小线程池</span></span><br><span class="line"><span class="attr">spring.task.execution.pool.allow-core-thread-timeout</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 核心线程池大小 默认 8</span></span><br><span class="line"><span class="attr">spring.task.execution.pool.core-size</span>=<span class="string">8</span></span><br><span class="line"><span class="comment"># 线程空闲等待时间 默认 60s</span></span><br><span class="line"><span class="attr">spring.task.execution.pool.keep-alive</span>=<span class="string">60s</span></span><br><span class="line"><span class="comment"># 线程池最大数 根据任务定制</span></span><br><span class="line"><span class="attr">spring.task.execution.pool.max-size</span>=<span class="string">16</span></span><br><span class="line"><span class="comment"># 线程池队列容量大小</span></span><br><span class="line"><span class="attr">spring.task.execution.pool.queue-capacity</span>=<span class="string">10</span></span><br><span class="line"><span class="comment"># 线程池关闭时等待所有任务完成</span></span><br><span class="line"><span class="attr">spring.task.execution.shutdown.await-termination</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 执行线程关闭前最大等待时间，确保最后一定关闭</span></span><br><span class="line"><span class="attr">spring.task.execution.shutdown.await-termination-period</span>=<span class="string">60</span></span><br><span class="line"><span class="comment"># 线程名称前缀</span></span><br><span class="line"><span class="attr">spring.task.execution.thread-name-prefix</span>=<span class="string">task-</span></span><br></pre></td></tr></table></figure>
<h2 id="缺点">缺点</h2>
<ol>
<li>不支持集群配置，在分布式环境下会出现多个任务并发执行的情况</li>
</ol>
<p>解决方法：通过分布式锁的方式预防任务并发执行的情况</p>
<ol start="2">
<li>不支持指定的时间范围执行任务（例如在9点到11点间执行任务，其他时间段不执行）</li>
<li>不支持分片执行任务</li>
</ol>
<h2 id="动态定时任务实现">动态定时任务实现</h2>
<h3 id="出现问题">出现问题</h3>
<p>用实现 SpringBoot + @Scheduled 实现了定时任务。但是也存在很多问题：</p>
<p>通常，@Scheduled 注解的所有属性只在 Spring Context 启动时解析和初始化一次。因此，当在 Spring 中使用 @Scheduled 注解时，无法在运行时更改 fixedDelay 或 fixedRate 值。</p>
<ol>
<li>在一个线程内执行，那么任务多了就可能被阻塞，导致任务延迟执行。</li>
<li>每次修改执行频率都要改代码，重启服务。</li>
<li>无法提供定时任务的启用、暂停、修改接口。</li>
</ol>
<p>实现方法：参考 ScheduledTaskRegistrar 源码提供的方法</p>
<h3 id="简单案例">简单案例</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `sys_task` (</span><br><span class="line">  `id` bigint(21) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;,</span><br><span class="line">  `task_uuid` varchar(50) DEFAULT NULL COMMENT &#x27;任务UUID&#x27;,</span><br><span class="line">  `task_name` varchar(50) DEFAULT NULL COMMENT &#x27;任务名称&#x27;,</span><br><span class="line">  `task_cron` varchar(50) DEFAULT NULL COMMENT &#x27;任务定时表达式&#x27;,</span><br><span class="line">  `class_name` varchar(100) DEFAULT NULL COMMENT &#x27;任务类&#x27;,</span><br><span class="line">  `method_name` varchar(100) DEFAULT NULL COMMENT &#x27;任务方法&#x27;,</span><br><span class="line">  `task_type` int(1) DEFAULT NULL COMMENT &#x27;任务类型&#x27;,</span><br><span class="line">  `remark` varchar(250) DEFAULT NULL,</span><br><span class="line">  `del_flag` int(1) DEFAULT &#x27;1&#x27;,</span><br><span class="line">  `create_user` varchar(50) DEFAULT NULL,</span><br><span class="line">  `create_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP,</span><br><span class="line">  `update_user` varchar(50) DEFAULT NULL,</span><br><span class="line">  `update_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ScheduledTaskRegistrar <span class="title function_">taskRegistrar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduledTaskRegistrar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduleTask5</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">task1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;我是task1，我的线程的 id == &gt; &#123;&#125;，时间 == &gt;&#123;&#125;&quot;</span>, Thread.currentThread().getId(), <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">        log.info(<span class="string">&quot;我是task1 ending ,我的线程的 id == &gt; &#123;&#125; , 时间 == &gt; &#123;&#125;&quot;</span>, Thread.currentThread().getId(), <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SysTask</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 主键</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 任务 UUID</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String taskUuid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 任务名称</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String taskName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 任务定时表达式</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String taskCron;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 任务类</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 任务方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 任务类型</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> Integer taskType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 备注</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String remark;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer delFlag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建人</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String createUser;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改人</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String updateUser;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Date updateTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CronServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">CronService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, ScheduledTask&gt; scheduledTaskMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ScheduledTaskRegistrar taskRegistrar;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(SysTask sysTask)</span> &#123;</span><br><span class="line">        <span class="type">CronTask</span> <span class="variable">cronTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CronTask</span>(getRunnable(sysTask), sysTask.getTaskCron());</span><br><span class="line">        <span class="type">ScheduledTask</span> <span class="variable">scheduledTask</span> <span class="operator">=</span> taskRegistrar.scheduleCronTask(cronTask);</span><br><span class="line">        <span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">        scheduledTaskMap.put(uuid, scheduledTask);</span><br><span class="line">        log.info(<span class="string">&quot;添加任务成功, uuid == &gt; &#123;&#125;, 任务名称 == &gt; &#123;&#125;, 任务表达式 == &gt; &#123;&#125;&quot;</span>, uuid, sysTask.getTaskName(), sysTask.getTaskCron());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Runnable <span class="title function_">getRunnable</span><span class="params">(SysTask sysTask)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Class&lt;?&gt; aClass = Class.forName(sysTask.getClassName());</span><br><span class="line">                Constructor&lt;?&gt; constructor = aClass.getConstructor();</span><br><span class="line">                <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> constructor.newInstance();</span><br><span class="line">                <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> aClass.getMethod(sysTask.getMethodName());</span><br><span class="line">                method.invoke(o);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(String uuid)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ScheduledTask</span> <span class="variable">scheduledTask</span> <span class="operator">=</span> scheduledTaskMap.get(uuid);</span><br><span class="line">            scheduledTask.cancel();</span><br><span class="line">            scheduledTaskMap.remove(uuid);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(SysTask sysTask)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.delete(sysTask.getTaskUuid());</span><br><span class="line">        <span class="built_in">this</span>.add(sysTask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/cron&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CronController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> CronService cronService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/add&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">add</span><span class="params">(<span class="meta">@RequestBody</span> SysTask sysTask)</span> &#123;</span><br><span class="line">        cronService.add(sysTask);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/delete&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">delete</span><span class="params">(String uuid)</span> &#123;</span><br><span class="line">        cronService.delete(uuid);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/update&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> SysTask sysTask)</span> &#123;</span><br><span class="line">        cronService.update(sysTask);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>定时任务</tag>
        <tag>SpringBoot Task</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础（2-equals与运算符==）</title>
    <url>/blog/2024/12/18/%E5%BF%83%E5%BE%97/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%EF%BC%882-equals%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6==%EF%BC%89/</url>
    <content><![CDATA[<h2 id="运算符">== 运算符</h2>
<ol>
<li>作用于基本数据类型时，是比较两个数值是否相等</li>
<li>作用于引用数据类型时，是比较两个对象的内存地址是否相同，即判断它们是否为同一个对象</li>
</ol>
<h2 id="equals-方法">equals()方法</h2>
<p>作用：</p>
<ol>
<li>没有重写时，Object 默认以 == 来实现，即比较两个对象的内存地址是否相同</li>
<li>进行重写后，一般会按照对象的内容来进行比较，若两个对象内容相同则认为对象相等，否则认为对象不等</li>
</ol>
<p>注意：</p>
<ol>
<li>equals 不能用于比较基本数据类型的变量；</li>
<li>如果没有对 equals 方法进行重写，则比较的是引用类型的变量所指向的对象的地址</li>
</ol>
<h3 id="java-lang-Object-equals">java.lang.Object: equals</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">    <span class="comment">//Java中==符号在比较复合型数据类型（类）比较的是对象在内存中的地址</span></span><br><span class="line">    <span class="comment">//只有同个new出来的对象，它们在内存中的存放地址才一样，比较结果才为true</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span>==obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="java-lang-String-equals">java.lang.String: equals</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span>&#123;</span><br><span class="line">    <span class="comment">//首先看一下是不是比较同一个对象，如果是直接返回true</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断anObject是否为String的一个实例，如果不是直接返回false</span></span><br><span class="line">    <span class="comment">//如果是再进一步判断两个字符串是否相等：将字符串转化为char数组进行一一比较</span></span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">anotherString</span> <span class="operator">=</span> (String)anObject;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="type">char</span> v1[] = value;</span><br><span class="line">            <span class="type">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="java-util-Arrays-equals">java.util.Arrays: equals</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(<span class="type">int</span>[] a,<span class="type">int</span>[] b)</span>&#123;</span><br><span class="line">    <span class="comment">//两个数组为同一对象返回true</span></span><br><span class="line">    <span class="keyword">if</span>(a==b)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//两个数组全为null返回false</span></span><br><span class="line">    <span class="keyword">if</span>(a==<span class="literal">null</span> || b==<span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//两个数组长度不一致返回false</span></span><br><span class="line">    <span class="type">int</span> length=a.length;</span><br><span class="line">    <span class="keyword">if</span>(b.length!=length)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//两个数组不是同一对象，不为null且长度相同再比较数组中的每一个元素是否相等</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]!=b[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="java-util-Object-equals">java.util.Object: equals</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object a,Object b)</span>&#123;</span><br><span class="line">    <span class="comment">//如果a,b都为null返回true，如果只有一个为null返回false，否则返回a.equals(b)的结果</span></span><br><span class="line">    <span class="keyword">return</span> (a==b) || (a!=<span class="literal">null</span> &amp;&amp; a.equals(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="java-util-Date-equals">java.util.Date: equals</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">    <span class="comment">//obj必须是Date类型，在把两个时间转化为GMT 1970-01-01 00:00:00</span></span><br><span class="line">    <span class="comment">//到此date对象上时间的毫秒数进行比较</span></span><br><span class="line">    <span class="keyword">return</span> obj instance Date &amp;&amp; getTime==((Date)obj).getTime();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>==</code> 比较运算符</th>
<th><code>equals()</code> 方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>比较内容</td>
<td>比较对象的引用（内存地址）</td>
<td>比较对象的内容（由类重写方法决定）</td>
</tr>
<tr>
<td>适用类型</td>
<td>基本数据类型、对象引用</td>
<td>对象（通常需要重写 <code>equals</code> 方法）</td>
</tr>
<tr>
<td>默认行为</td>
<td>对象比较内存地址，基本类型比较值</td>
<td>默认比较对象引用；大多数类重写此方法</td>
</tr>
<tr>
<td>典型用法</td>
<td>用于比较基本数据类型和检查对象是否是同一实例</td>
<td>用于比较对象内容（如字符串、集合等）</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础（1-基本类型和包装类型）</title>
    <url>/blog/2024/12/17/%E5%BF%83%E5%BE%97/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%EF%BC%881-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%EF%BC%89/</url>
    <content><![CDATA[<h2 id="基本数据类型和包装类型">基本数据类型和包装类型</h2>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>包装类型</th>
<th>位数</th>
<th>字节</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>Byte</td>
<td>8</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
<td>16</td>
<td>2</td>
<td>0</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
<td>32</td>
<td>4</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
<td>64</td>
<td>8</td>
<td>0L</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
<td>16</td>
<td>2</td>
<td>‘u0000’</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
<td>32</td>
<td>4</td>
<td>0f</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
<td>64</td>
<td>8</td>
<td>0d</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
<td>1</td>
<td></td>
<td>false</td>
</tr>
</tbody>
</table>
<p>注意：float 的精度为 6~7 位，double 的精度为 15~16</p>
<h3 id="区别">区别</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>基本数据类型</th>
<th>包装类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>类型</td>
<td>直接存储值</td>
<td>存储为对象</td>
</tr>
<tr>
<td>默认值</td>
<td>有默认值（如 <code>0</code>、<code>false</code> 等）</td>
<td><code>null</code></td>
</tr>
<tr>
<td>存储位置</td>
<td>栈内存</td>
<td>堆内存</td>
</tr>
<tr>
<td>性能</td>
<td>高效，访问速度快</td>
<td>较低，因为涉及对象的创建和拆箱</td>
</tr>
<tr>
<td>是否为对象</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>支持的功能</td>
<td>无</td>
<td>提供多种实用方法（如解析、转换等）</td>
</tr>
<tr>
<td>是否为可变对象</td>
<td>否（不可修改值）</td>
<td>否（包装类型对象不可变）</td>
</tr>
</tbody>
</table>
<h3 id="适用场景">适用场景</h3>
<ol>
<li>基本数据类型：</li>
</ol>
<ul>
<li>用于对性能要求较高的场景，如大规模的数值计算、循环处理等。</li>
<li>更适用于需要较少内存分配的简单数据存储。</li>
</ul>
<ol start="2">
<li>包装类型：</li>
</ol>
<ul>
<li>用于需要对象的场景，如需要存储在集合类（如 <code>List</code>、<code>Set</code>）中的数据，或者需要与其他类进行交互时。</li>
<li>包装类对象用于 Java 泛型类型，因为泛型不支持基本数据类型。</li>
</ul>
<h3 id="自动装箱拆箱">自动装箱拆箱</h3>
<p>对于 Java 基本数据类型，均对应一个包装类</p>
<ol>
<li>装箱：自动将基本数据类型转换为包装器类型，如 <code>int -&gt; Integer</code></li>
<li>拆箱：自动将包装器类型转换为基本数据类型，如 <code>Integer -&gt; int</code></li>
</ol>
<h2 id="缓存信息">缓存信息</h2>
<h3 id="Integer-缓存源码">Integer 缓存源码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">integerCacheHighPropValue</span> <span class="operator">=</span></span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> <span class="title class_">Integer</span>[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> <span class="title class_">Integer</span>(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">IntegerCache</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优点：对-128 到 127 的 Integer 对象进行缓存，当创建新的 Integer 对象时，如果符合这个范围，并且已有存在的相同值的对象，则返回这个对象（地址），不需要再创建一个新的 Integer 对象，否则创建新的 Integer 对象。在做 == 运算时，Integer 会自动拆箱为 int 类型，然后再进行比较</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Integer a=<span class="number">123</span>;</span><br><span class="line">        Integer b=<span class="number">123</span>;</span><br><span class="line">        System.out.println(a==b);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        a=<span class="number">128</span>;</span><br><span class="line">        b=<span class="number">128</span>;</span><br><span class="line">        System.out.println(a==b);<span class="comment">//false     </span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> c=<span class="number">128</span>;</span><br><span class="line">        <span class="type">int</span> d=<span class="number">128</span>;</span><br><span class="line">        System.out.println(c==d);<span class="comment">//true</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">Integer</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">12</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">12</span>);</span><br><span class="line">        System.out.println(e==f);<span class="comment">//false</span></span><br><span class="line">        Integer g=<span class="number">12</span>;</span><br><span class="line">        System.out.println(e==g);<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Integer g = 12</code> 会发生装箱，等价于 <code>Integer g = Integer.valueOf(12)</code>，因此，g 直接使用的常量池中的对象，而 <code>Integer e = new Integer(40)</code> 会直接创建新的对象。所有整型包装类对象之间值的比较，全部使用 equals 方法比较</p>
<h3 id="Long-缓存源码">Long 缓存源码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title function_">valueOf</span><span class="params">(<span class="type">long</span> l)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= -<span class="number">128</span> &amp;&amp; l &lt;= <span class="number">127</span>) &#123; <span class="comment">// will cache</span></span><br><span class="line">        <span class="keyword">return</span> LongCache.cache[(<span class="type">int</span>)l + offset];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Long</span>(l);</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LongCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LongCache</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Long cache[] = <span class="keyword">new</span> <span class="title class_">Long</span>[-(-<span class="number">128</span>) + <span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">            cache[i] = <span class="keyword">new</span> <span class="title class_">Long</span>(i - <span class="number">128</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Short-缓存源码">Short 缓存源码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Short <span class="title function_">valueOf</span><span class="params">(<span class="type">short</span> s)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sAsInt</span> <span class="operator">=</span> s;</span><br><span class="line">    <span class="keyword">if</span> (sAsInt &gt;= -<span class="number">128</span> &amp;&amp; sAsInt &lt;= <span class="number">127</span>) &#123; <span class="comment">// must cache</span></span><br><span class="line">        <span class="keyword">return</span> ShortCache.cache[sAsInt + offset];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Short</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ShortCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ShortCache</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Short cache[] = <span class="keyword">new</span> <span class="title class_">Short</span>[-(-<span class="number">128</span>) + <span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">            cache[i] = <span class="keyword">new</span> <span class="title class_">Short</span>((<span class="type">short</span>)(i - <span class="number">128</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Character-缓存源码">Character 缓存源码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Character <span class="title function_">valueOf</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c &lt;= <span class="number">127</span>) &#123; <span class="comment">// must cache</span></span><br><span class="line">      <span class="keyword">return</span> CharacterCache.cache[(<span class="type">int</span>)c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Character</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CharacterCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">CharacterCache</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Character cache[] = <span class="keyword">new</span> <span class="title class_">Character</span>[<span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">            cache[i] = <span class="keyword">new</span> <span class="title class_">Character</span>((<span class="type">char</span>)i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Byte-缓存源码">Byte 缓存源码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Byte <span class="title function_">valueOf</span><span class="params">(<span class="type">byte</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">return</span> ByteCache.cache[(<span class="type">int</span>)b + offset];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ByteCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ByteCache</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Byte cache[] = <span class="keyword">new</span> <span class="title class_">Byte</span>[-(-<span class="number">128</span>) + <span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">            cache[i] = <span class="keyword">new</span> <span class="title class_">Byte</span>((<span class="type">byte</span>)(i - <span class="number">128</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Boolean-缓存源码">Boolean 缓存源码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title function_">valueOf</span><span class="params">(<span class="type">boolean</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结">总结</h3>
<ol>
<li>Integer 和 Long、Short 会缓存-128~127 的数据</li>
<li>Character 会缓存 0~127 的数据</li>
<li>Byte 会缓存-128~127 的数据</li>
</ol>
<p>注意：两种浮点数类型的包装类 Float，Double 并没有实现常量池技术。</p>
<h2 id="其他">其他</h2>
<h3 id="Integer-和-Double-类型比较">Integer 和 Double 类型比较</h3>
<p>Integer、Double 不能直接进行比较，这包括：</p>
<ol>
<li>不能用 == 进行直接比较，因为它们是不同的数据类型</li>
<li>不能转为字符串进行比较，因为转为字符串后，浮点数带小数点，整数值不带，这样它们永远都不相等</li>
<li>不能使用 compareTo 方法进行比较，虽然它们都有 compareTo 方法，但该方法只能对相同类型进行比较</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">Double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">100.00</span>;</span><br><span class="line">System.out.println(i.doubleValue() == d.doubleValue());</span><br></pre></td></tr></table></figure>
<h3 id="逃逸分析">逃逸分析</h3>
<p>逃逸分析的基本行为就是分析对象的动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用</p>
<ol>
<li>方法逃逸：在一个方法体内，定义一个局部变量，而它可能被外部方法引用。例如：作为调用参数传递到其他方法中</li>
<li>线程逃逸：这个对象有可能被外部线程访问到。例如：赋值给类变量或可以在其他线程中访问的实例变量</li>
</ol>
<p><strong>为什么说是几乎所有对象实例都存在于堆中呢？</strong></p>
<p>这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存</p>
<p>注意：基本数据类型存放在栈中是一个常见的误区！基本数据类型的存储位置取决于它们的作用域和声明方式。如果它们是局部变量，那么它们会存放在栈中；如果它们是成员变量，那么它们会存放在堆/方法区/元空间中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">// 成员变量，存放在堆中</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 被 static 修饰的成员变量，JDK 1.7 及之前位于方法区，1.8 后存放于元空间，均不存放于堆中。</span></span><br><span class="line">    <span class="comment">// 变量属于类，不属于对象。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 局部变量，存放在栈中</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">40</span>; <span class="comment">// 编译错误，不能在方法中使用 static 修饰局部变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础（3-hashCode）</title>
    <url>/blog/2024/12/19/%E5%BF%83%E5%BE%97/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%EF%BC%883-hashCode%EF%BC%89/</url>
    <content><![CDATA[<h2 id="作用">作用</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 获取哈希码（散列码），这个哈希码的作用是确定该对象在哈希表中的索引位置</span></span><br></pre></td></tr></table></figure>
<p>注意：hashCode 的值保存在对象中，只有第一次调用时产生 hashCode，并保存在 hash 中</p>
<h2 id="特点">特点</h2>
<ol>
<li>相等（相同）的对象必须具有相等的哈希码（或者散列码）</li>
<li>如果两个对象的 hashCode 相等，它们不一定相等，可能不同对象的哈希码计算相同（哈希冲突）。</li>
<li>equals()方法被覆盖过，则 hashCode()方法也必须被覆盖（如果重写 equals 时没有重写 hashCode 方法的话，就可能导致 equals 方法判断是相等的两个对象，hashCode 值却不相等）</li>
</ol>
<h2 id="方法实现">方法实现</h2>
<p>实现 hashCode 方法时，应尽量确保：</p>
<ol>
<li>
<p>相等对象的哈希码相同：如通过对象的所有参与比较的字段来生成哈希码。</p>
</li>
<li>
<p>性能优化：避免使用过多的字段参与计算，选择合适的字段生成哈希值。</p>
</li>
</ol>
<p>通常的实现方式：</p>
<ol>
<li>使用对象的重要字段来计算哈希值，通常是 equals 方法中比较的字段。</li>
<li>使用素数和常数来混合哈希码值，减少哈希冲突的概率。</li>
</ol>
<h2 id="String-的-hashCode-计算方法">String 的 hashCode 计算方法</h2>
<p>选择 31 的理由：</p>
<ol>
<li>31 可以被 JVM 优化，31*i =（i &lt;&lt; 5）-i</li>
<li>31 是一个不大不小的质数，是作为 hashCode 乘子的优选质数之一</li>
</ol>
<ul>
<li>如果选择 2 时，哈希值会分布在一个较小的数值区间内，分布性不佳，最终可能会导致冲突率上升</li>
<li>如果选择 101 时，计算结果太大了，如果用 int 类型表示哈希值，结果会溢出，最终导致数值信息丢失</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> val[] = value;        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; value.length; ++i) &#123;</span><br><span class="line">            h = <span class="number">31</span>*h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">公式为：s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]</span></span><br><span class="line"><span class="comment">假设 n=3</span></span><br><span class="line"><span class="comment">i=0 -&gt; h = 31 * 0 + val[0]</span></span><br><span class="line"><span class="comment">i=1 -&gt; h = 31 * (31 * 0 + val[0]) + val[1]</span></span><br><span class="line"><span class="comment">i=2 -&gt; h = 31 * (31 * (31 * 0 + val[0]) + val[1]) + val[2]</span></span><br><span class="line"><span class="comment">       h = 31*31*31*0 + 31*31*val[0] + 31*val[1] + val[2]</span></span><br><span class="line"><span class="comment">       h = 31^(n-1)*val[0] + 31^(n-2)*val[1] + val[2]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="hashCode-和-equals-的联系">hashCode()和 equals()的联系</h2>
<p>如果你重写了 equals 方法，通常也需要重写 hashCode 方法，以确保遵循 Java 的规范：当两个对象通过 equals 判断相等时，它们的 hashCode 也必须相等。否则，哈希表中的查找可能会失败。</p>
<p><strong>为什么要重写 equals()？</strong></p>
<p>例如：当把对象加入 HashSet 时，HashSet 会先计算对象的 hashCode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashCode 值作比较，如果没有相符的 hashCode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashCode 值的对象，这时会调用 equals()方法来检查 hashCode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功；如果不同的话，就会重新散列到其他位置，这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础（4-String）</title>
    <url>/blog/2024/12/22/%E5%BF%83%E5%BE%97/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%EF%BC%884-String%EF%BC%89/</url>
    <content><![CDATA[<h2 id="String、StringBuffer-与-StringBuilder">String、StringBuffer 与 StringBuilder</h2>
<p><strong>区别</strong></p>
<p>运行速度快慢：StringBuilder &gt; StringBuffer &gt; String</p>
<ol>
<li>String：采用 final 修饰的字符数组进行字符串保存，因此不可变。如果对 String 类型对象修改，需要新建对象，将老字符和新增加的字符一并存进去</li>
<li>StringBuilder：采用无 final 修饰的字符数组进行保存，因此可变，但线程不安全</li>
<li>StringBuffer：采用无 final 修饰的字符数组进行保存，可理解为实现线程安全的 StringBuilder，其实比 StringBuilder 多了 synchronized 修饰符</li>
</ol>
<p>StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串，不过没有使用 final 和 private 关键字修饰</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line">    <span class="type">char</span>[] value;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count;	</span><br><span class="line"></span><br><span class="line">    AbstractStringBuilder() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AbstractStringBuilder(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        value = <span class="keyword">new</span> <span class="title class_">char</span>[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> AbstractStringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> appendNull();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">        ensureCapacityInternal(count + len);</span><br><span class="line">        str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">        count += len;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用场景</strong></p>
<ol>
<li>
<p>当需要频繁修改字符串时，建议使用 StringBuilder（性能较好）。</p>
</li>
<li>
<p>如果在多线程环境下使用，则可以选择 StringBuffer。</p>
</li>
</ol>
<p><strong>final 修饰 StringBuffer 后还可以 append 吗？</strong></p>
<p>可以，final 修饰的是一个引用变量，那么这个引用始终只能指向这个对象，但是这个对象内部的属性是可以变化的</p>
<h2 id="String-字符串修改实现原理">String 字符串修改实现原理</h2>
<p>当用 String 类型来对字符串进行修改时，其实现方法是首先创建一个 StringBuilder，其次调用 StringBuilder 的 append()方法，最后调用 StringBuilder 的 toString()方法把结果返回</p>
<h2 id="String-intern">String.intern()</h2>
<p>String.intern 是一个 Native 方法，底层调用 C++的 StringTable:: intern 方法</p>
<p>作用：当调用 intern 方法时，如果常量池中已经存在该字符串，则返回池中的字符串；否则将此字符串添加到常量池中，并返回字符串的引用</p>
<p>优点：使用 intern 方法可以提高内存使用效率，减少重复的字符串</p>
<h2 id="String-类的不可变性">String 类的不可变性</h2>
<p>String 类由 final 修饰，所以不能被继承</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>性能优化（字符串常量池的需要）：字符串常量池是 Java 堆内存中一个特殊的存储区域，当创建一个 String 对象时，假设此字符串值已经存在于常量池中，则不会创建一个新的对象，而是引用已经存在的对象。若字符串可变，基于常量池的 String.intern()方法也失效，每次创建新的字符串将在堆中开辟出新的空间，占据更多的内存</li>
<li>允许 String 对象缓存 HashCode：字符串不变性保证类 hash 码的唯一性，因此可以放心地进行缓存，意味着不必每次都去计算新的哈希码</li>
<li>安全性：例如：网络连接地址 URL 等，如果字符串是可变的，黑客就有可能改变字符串指向对象的值，那么会引起严重的安全问题</li>
<li>线程安全：在多线程中，只有不变的对象和值是线程安全的，可以在多个线程中共享数据。由于 String 的不可变，当一个线程修改了字符串的值，只会产生一个新的字符串对象，不会对其他线程的访问产生副作用，访问的都是同样的字符串数据，不需要任何同步操作</li>
</ol>
<h2 id="Java9-将-String-的底层实现由-char-改成了-byte">Java9 将 String 的底层实现由 char [] 改成了 byte []</h2>
<p>在 Java9 之后，String、StringBuilder 与 StringBuffer 的实现改用 byte 数组存储字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable,Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="meta">@Stable</span> <span class="comment">//表示变量最多被修改一次，称为“稳定的”。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line">    <span class="type">byte</span>[] value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 char [] 来表示 String 就导致了即使 String 中的字符只用一个字节就能表示，也得占用两个字节。仅仅将 char [] 优化为 byte [] 是不够的，还要配合 Latin-1 的编码方式，该编码方式是用单个字节来表示字符的。针对 JDK9 的 String 源码里，为了区别编码方式，追加了一个 coder 字段来区分，Java 会根据字符串的内容自动设置为相应的编码，要么 Latin-1 要么 UTF16</p>
<p><strong>为什么用 UTF-16 而不用 UTF-8？</strong></p>
<p>在 UTF-8 中，0-127 号的字符用 1 个字节来表示，使用和 ASCII 相同的编码，只有 128 号以上的字符才用 2 个、3 个或者 4 个字节来表示</p>
<ol>
<li>如果只有一个字节，那么最高的比特位为 0</li>
<li>如果有多个字节，那么第一个字节从最高位开始，连续有几个比特位的值为 1，就使用几个字节编码，剩下的字节均以 10 开头</li>
</ol>
<ul>
<li>0xxxxxxx：一个字节</li>
<li>110xxxxx 10xxxxxx：两个字节（开始两个 1）</li>
<li>1110xxxx 10xxxxxx 10xxxxxx：三个字节（开始三个 1）</li>
</ul>
<p>UTF-8 是变长的，对于 String 这种有随机访问方法的类来说，就很不方便。所谓的随机访问，就是 charAt、subString 这种方法，随便指定一个数字，String 就能给出结果。如果字符串中的每个字符占用的内存是不定长的，那么进行随机访问的时候，就需要从头开始数每个字符的长度，才能找到想要的字符</p>
<p><strong>UTF-16 使用 2 个或者 4 个字节来存储字符</strong></p>
<ol>
<li>对于 Unicode 编号范围在 0-FFFF 之间的字符，UTF-16 使用两个字节存储</li>
<li>对于 Unicode 编号范围在 10000-10FFFF 之间的字符，UTF-16 使用四个字节存储，具体来说就是：将字符编号的所有比特位分成两部分，较高的一些比特位用一个值介于 D800-DBFF 之间的双字节存储，较低的一些比特位（剩下的比特位）用一个值介于 DC00-DFFF 之间的双字节存储</li>
</ol>
<p>在 Java 中，一个字符（char）就是 2 个字节，占 4 个字节的字符，在 Java 里也是用两个 char 存储的，而 String 的各种操作，都是以 Java 的字符（char）为单位的，charAt 是取得第几个 char，subString 取的也是第几个到第几个 char 组成的子串，甚至 length 返回的都是 char 的个数。所以 UTF-16 在 Java 的世界里，就可以视为一个定长的编码</p>
<h2 id="拼接字符串">拼接字符串</h2>
<p><strong>采用+运算符时</strong></p>
<ol>
<li>如果拼接的都是字符串常量，则在编译时编译器会将其直接优化为一个完整的字符串，效率比较高</li>
<li>如果拼接的字符串中包含变量，则在编译时编译器采用 StringBuilder 对其进行优化，即自动创建 StringBuilder 实例并调用其 append()方法。引用的值在程序编译期是无法确定的，编译器无法对其进行优化</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;<span class="comment">//常量池中的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> str1 + str2; <span class="comment">//在堆上创建的新的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str5</span> <span class="operator">=</span> <span class="string">&quot;string&quot;</span>;<span class="comment">//常量池中的对象</span></span><br><span class="line">System.out.println(str3 == str4);<span class="comment">//false</span></span><br><span class="line">System.out.println(str3 == str5);<span class="comment">//true</span></span><br><span class="line">System.out.println(str4 == str5);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>字符串使用 final 关键字声明之后，可以让编译器当作常量来处理。被 final 关键字修饰之后的 String 会被编译器当作常量来处理，编译器在程序编译器就可以确定它的值，其效果就相当于访问常量</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="comment">// 下面两个表达式其实是等价的</span></span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;<span class="comment">// 常量池中的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> str1 + str2; <span class="comment">// 常量池中的对象</span></span><br><span class="line">System.out.println(c == d);<span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><strong>采用 String 类的 concat 方法时</strong></p>
<ol>
<li>concat 方法的拼接逻辑是：先创建一个足以容纳待拼接的两个字符串的字节数组，然后先后将两个字符串拼到这个数组里，最后将此数组转换为字符串</li>
<li>在拼接大量字符串的时候，concat 方法的效率低于 StringBuilder。但是只拼接 2 个字符串时，concat 方法的效率要优于 StringBuilder</li>
</ol>
<h2 id="String-str-“i”-与-String-str-new-String-“i”">String str = “i” 与 String str = new String(“i”)</h2>
<p>不一样，String str = “i” 的方式，Java 虚拟机会将其分配到常量池中；String str = new String(“i”)则会分配到堆内存中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        System.out.println(a == b);	<span class="comment">//true</span></span><br><span class="line">        System.out.println(a == c);	<span class="comment">//false</span></span><br><span class="line">        System.out.println(c == d);	<span class="comment">//false</span></span><br><span class="line">        System.out.println(c.equals(d));<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>在执行 String str1 = “abc” 的时候，JVM 会首先检查字符串常量池中是否已存在该字符串对象，如果已经存在，那么就不会再创建了，直接返回该字符串在字符串常量池中的内存地址；如果该字符串还不在字符串常量池中，那么就会在字符串常量池中创建该字符串对象然后再返回</li>
<li>String str3 = new String(“abc”)，则会创建一个新的对象，然后将新对象的地址值赋给 str3，虽然 str3 和 str1 的值相同但是地址值不同。当 JVM 遇到上述代码时，会先检索常量池中是否存在“abc”，如果不存在“abc”这个字符串，则会先在常量池中创建这个一个字符串。然后再执行 new 操作，会在堆内存中创建一个存储“abc”的 String 对象，对象的引用赋值给 str2。此过程创建了 2 个对象。当然，如果检索常量池时发现已经存在了对应的字符串，那么只会在堆内创建一个新的 String 对象，此过程只创建了 1 个对象。</li>
</ol>
<p>使用 new 会创建 1 或 2 个字符串，会多创建一个对象出来，占用更多的内存，所以一般建议使用直接量的方式创建字符串</p>
<h2 id="创建对象的个数">创建对象的个数</h2>
<ol>
<li>字面量+字面量</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>+<span class="string">&quot;def&quot;</span>;</span><br><span class="line"><span class="comment">//创建了1个对象。编译期已经把常量拼为 &quot;abcdef&quot; 放到常量池</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>字面量+对象+字面量</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span> + s1 + <span class="string">&quot;def&quot;</span>;</span><br><span class="line"><span class="comment">//创建了3个对象。常量池2个：abc、def，堆中1个：abcabcdef</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span> + s1 + <span class="string">&quot;def&quot;</span>; </span><br><span class="line"><span class="comment">//创建了2个对象，&quot;abc&quot;已经在池中了，直接取出，创建了一个&quot;def&quot;的String对象放入池中，创建一个&quot;abcabcdef&quot;的String对象放于堆中（不是常量池）</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>new String(“xx”)+new String(“xx”)</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="comment">//创建了4个对象。先在常量池创建一个&quot;abc&quot;对象，再在内存堆上创建一个&quot;abc&quot;对象，第二个new语句不在池中创建对象，只在内存堆上创建一个对象，两个字符串相加会在堆上创建一个对象</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>字面量+new String(“xx”)</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>+ <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;def&quot;</span>);</span><br><span class="line"><span class="comment">//创建了4个对象。先在常量池创建2个对象存储&quot;abc&quot;和&quot;def&quot;，new时再在内存堆上创建一个对象，两个字符串相加会在堆上创建一个对象</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础（5-类详解）</title>
    <url>/blog/2024/12/23/%E5%BF%83%E5%BE%97/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%EF%BC%885-%E7%B1%BB%E8%AF%A6%E8%A7%A3%EF%BC%89/</url>
    <content><![CDATA[<h2 id="Java-访问修饰符（访问权限）">Java 访问修饰符（访问权限）</h2>
<ol>
<li>default：<font style="color:rgb(0, 0, 0);"> 如果一个类、类属变量及方法没有用任何修饰符（即没有用 public、protected 及 private 中任何一种修饰），则其访问权限为 default（默认访问权限），</font> 在同一包内可见</li>
<li>private：在同一类内可见，不能修饰类</li>
<li>protected：对同一包内的类和所有包的子类可见，不能修饰类</li>
<li>public：对所有类可见</li>
</ol>
<h2 id="构造方法">构造方法</h2>
<p>特点：</p>
<ol>
<li>名字与类名相同</li>
<li>没有返回值，但不能用 void 声明构造函数</li>
<li>生成类的对象时自动执行，无需调用</li>
</ol>
<p>注意：</p>
<ol>
<li>如果一个类没有声明构造方法，也可以执行，因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法</li>
<li>Java 程序在执行子类的构造方法之前，如果没有用 super()来调用父类特定的构造方法，则会调用父类中 “没有参数的构造方法”</li>
<li>如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 super()来调用父类中特定的构造方法，则编译时将发生错误。解决方法是：在父类里加上一个不做事且没有参数的构造方法</li>
</ol>
<h2 id="super-关键字">super 关键字</h2>
<p>作用：</p>
<ol>
<li>访问父类的构造函数</li>
<li>访问父类的成员</li>
</ol>
<p>注意点：</p>
<ol>
<li>super()和 this()均需放在构造方法内第一行</li>
<li>调用 super()必须写在子类构造方法的第一行，否则编译不通过。每个子类的构造方法的第一条语句，都是隐含地调用 super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错</li>
<li>this 和 super 不能同时出现在一个构造函数里，因为 this 必然会调用其他的构造函数，其他的构造函数必然也会有 super 语句的存在，编译器不会通过</li>
<li>this()和 super()都指的是对象，所以均不可以在 static 环境中使用</li>
</ol>
<h2 id="static-关键字">static 关键字</h2>
<ol>
<li>
<p>静态变量：称为类变量，类所有的实例都共享静态变量，可以直接通过类名来访问它，静态变量在内存中只存在一份</p>
</li>
<li>
<p>静态方法：静态方法在类加载的时候就存在了，它不依赖于任何实例。静态方法必须有实现，它不能是抽象方法。只能访问所属类的静态字段和静态方法，方法中不能有 this 和 supper 关键字</p>
</li>
<li>
<p>静态语句块：静态语句块在类初始化时运行一次</p>
</li>
<li>
<p>静态内部类：非静态内部类依赖于外部类的实例，而静态内部类不需要。静态内部类不能访问外部类的非静态的变量和方法</p>
</li>
</ol>
<p>初始化顺序：静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序</p>
<h2 id="内部类">内部类</h2>
<p><strong>一个 Java 文件里可以有多个类吗（不含内部类）？</strong></p>
<ol>
<li>一个 Java 文件里可以有多个类，但最多只能有一个被 public 修饰的类</li>
<li>如果这个 Java 文件中包含 public 修饰的类，则这个类的名称必须和 Java 文件名一致</li>
</ol>
<h3 id="成员内部类">成员内部类</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//成员内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">String</span> <span class="variable">testStrInner</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">testInner</span><span class="params">()</span> &#123;</span><br><span class="line">            test1();</span><br><span class="line">            test2();</span><br><span class="line">            test3();<span class="comment">//成员内部类可以访问外部类所有的属性和方法。静态方法直接访问。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="静态内部类">静态内部类</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//静态内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">testStrInner</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testInner</span><span class="params">()</span> &#123;</span><br><span class="line">            test3();</span><br><span class="line">            <span class="type">String</span> <span class="variable">ss</span> <span class="operator">=</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>静态内部类可以包含静态成员，也可以包含非静态成员</li>
<li>静态内部类不能访问外部类的实例成员，只能访问它的静态成员</li>
<li>外部类的所有方法、初始化块都能访问其内部定义的静态内部类</li>
<li>在外部类的外部，也可以实例静态内部类，语法：外部类.内部类 变量名 = new 外部类.内部类构造方法()</li>
</ol>
<h3 id="匿名内部类">匿名内部类</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类  Animal </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bellow</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//动物吼叫的类型</span></span><br><span class="line">        System.out.println(<span class="string">&quot;动物吼叫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Demo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">        demo.getDogBellow(<span class="keyword">new</span> <span class="title class_">Animal</span>()&#123;</span><br><span class="line">            <span class="comment">//匿名内部类，重写父类方法。当然接口也是一样</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bellow</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;狗 汪汪汪。。。。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDogBellow</span><span class="params">(Animal animal)</span>&#123;</span><br><span class="line">        animal.bellow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="局部内部类">局部内部类</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bellow</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">bellowStr</span> <span class="operator">=</span> <span class="string">&quot;动物吼叫&quot;</span>;</span><br><span class="line">        System.out.println(bellowStr);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;<span class="comment">//局部内部类</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">dogBellowStr</span> <span class="operator">=</span> bellowStr + <span class="string">&quot;；狗 ：汪汪汪&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dogBellow</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(dogBellowStr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内部类作用">内部类作用</h3>
<ol>
<li>内部类可以很好地实现隐藏</li>
</ol>
<p>非内部类是不可以使用 private 和 protected 修饰的，但是内部类可以，从而达到隐藏的作用，同时也可以将一定逻辑关系的类组织在一起，增强可读性</p>
<ol start="2">
<li>间接的实现多继承</li>
</ol>
<p>每个内部类都能独立地继承一个接口的实现，所以无论外部类是否已经继承了某个接口的实现，对于内部类没有影响。如果没有内部类提供的可以继承多个具体的或抽象的类的能力，一些设计与编程问题就很难解决</p>
<h2 id="Java-代码块">Java 代码块</h2>
<p>执行顺序：</p>
<ol>
<li>父类静态变量（只执行一次，其他每次 new 对象都要执行）</li>
<li>父类静态代码块（只执行一次，其他每次 new 对象都要执行）</li>
<li>子类静态变量（只执行一次，其他每次 new 对象都要执行）</li>
<li>子类静态代码块（只执行一次，其他每次 new 对象都要执行）</li>
<li>父类非静态变量</li>
<li>父类非静态代码块</li>
<li>父类构造函数</li>
<li>子类非静态变量</li>
<li>子类非静态代码块</li>
<li>子类构造函数</li>
</ol>
<p>注意：静态变量和静态代码块谁先声明的先执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeBlock01</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类静态代码块执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类代码块执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CodeBlock01</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类构造函数执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeBlock02</span> <span class="keyword">extends</span> <span class="title class_">CodeBlock01</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类静态代码块执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类代码块执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CodeBlock02</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类构造函数执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">CodeBlock02</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果：</span></span><br><span class="line">父类静态代码块执行</span><br><span class="line">子类静态代码块执行</span><br><span class="line">父类代码块执行</span><br><span class="line">父类构造函数执行</span><br><span class="line">子类代码块执行</span><br><span class="line">子类构造函数执行</span><br></pre></td></tr></table></figure>
<h2 id="覆盖（重写）和重载">覆盖（重写）和重载</h2>
<table>
<thead>
<tr>
<th>区别</th>
<th>覆盖（Override）</th>
<th>重载（Overload）</th>
</tr>
</thead>
<tbody>
<tr>
<td>发生场所</td>
<td>在继承关系的子类和父类之间</td>
<td>在同一个类中</td>
</tr>
<tr>
<td>参数</td>
<td>与父类同名同参</td>
<td>与别的方法同名不同参</td>
</tr>
<tr>
<td>返回类型</td>
<td>子类与父类返回类型要一致</td>
<td>可以不同</td>
</tr>
<tr>
<td>权限修饰符</td>
<td>子类不能覆盖父类的 private 方法</td>
<td>无</td>
</tr>
<tr>
<td>次数限制</td>
<td>父类一个方法只能在子类覆盖一次</td>
<td>重写只要参数不同，可以多次</td>
</tr>
<tr>
<td></td>
<td>覆盖是针对父类方法的重写</td>
<td>同类中的方法均可重载</td>
</tr>
<tr>
<td>异常处理</td>
<td>重写要求子类比父类抛出更少的异常</td>
<td>无</td>
</tr>
</tbody>
</table>
<p>方法的重写要遵循“两同两小一大”</p>
<ol>
<li>“两同”：方法名相同、形参列表相同</li>
<li>“两小”：子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等</li>
<li>“一大”：子类的访问权限应比父类方法的访问权限更大或相等（例如：父类的方法是protected，子类不能将其修改为private，但可以改为public）</li>
</ol>
<h2 id="变量">变量</h2>
<h3 id="成员变量">成员变量</h3>
<p>成员变量是在类的范围里定义的变量，有默认初始值</p>
<h3 id="局部变量">局部变量</h3>
<ol>
<li>局部变量是在方法里定义的变量，没有默认初始值</li>
<li>局部变量存储于栈内存中，作用的范围结束，变量空间会自动地释放</li>
<li>局部变量不能被访问控制修饰符及 static 所修饰，但是，成员变量和局部变量都能被 final 所修饰</li>
</ol>
<h3 id="静态变量">静态变量</h3>
<ol>
<li>被 static 修饰的变量称为类变量，它属于类，存储于方法区中，生命周期与当前类相同，因此不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；</li>
<li>静态变量可以实现让多个对象共享内存</li>
</ol>
<h3 id="实例变量">实例变量</h3>
<ol>
<li>未被 static 修饰的成员变量叫实例变量，它存储于对象所在的堆内存中，生命周期与对象相同</li>
<li>属于某一实例，需要先创建对象，然后通过对象才能访问到它</li>
</ol>
<h2 id="静态方法和实例方法">静态方法和实例方法</h2>
<p><strong>静态方法为什么不能调用非静态成员？</strong></p>
<ol>
<li>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问</li>
<li>在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在非静态成员，属于非法操作</li>
</ol>
<p><strong>区别</strong></p>
<ol>
<li>调用方法：在外部调用静态方法时，可以使用类名.方法名的方式，也可以使用对象.方法名的方式，而实例方法只有后面这种方法，调用静态方法可以无需创建对象。一般不建议使用对象.方法名的方法来调用静态方法</li>
<li>访问类成员是否存在限制：静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制</li>
</ol>
<h2 id="抽象类和接口">抽象类和接口</h2>
<p>共同点：</p>
<ol>
<li>都不能被实例化</li>
<li>都可以包含抽象方法</li>
<li>都可以有默认实现的方法（Java8 可以用 default 关键字在接口中定义默认方法）</li>
</ol>
<p>区别：</p>
<ol>
<li>抽象类中可以定义构造函数，接口不能定义构造函数</li>
<li>抽象类中可以有抽象方法和具体方法，而接口中只能有抽象方法（public abstract）</li>
<li>抽象类中的成员权限可以是 public、default、protected（抽象类中抽象方法就是为了重写，所以不能被 private 修饰）。而接口中的成员只可以是 public（方法默认：public abstract，成员变量默认：public static final）</li>
<li>抽象类中可以包含静态方法，而接口中不可以包含静态方法</li>
</ol>
<p><strong>JDK8 后的改变</strong></p>
<ol>
<li>允许在接口中包含带有具体实现的方法，使用 default 修饰，这类方法是默认方法</li>
<li>接口中可以包含静态方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">NewInterface</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;staticMethod&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">defaultMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;defaultMethod&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getInfo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础（6-Java与C++）</title>
    <url>/blog/2024/12/24/%E5%BF%83%E5%BE%97/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%EF%BC%886-Java%E4%B8%8EC+%EF%BC%89/</url>
    <content><![CDATA[<h2 id="Java-与-C">Java 与 C++</h2>
<h3 id="区别">区别</h3>
<p>Java 和 C++都是面向对象的语言，都支持封装、继承和多态</p>
<ol>
<li>Java 不提供指针来直接访问内存，程序内存更加安全</li>
<li>Java 的类是单继承的，C++支持多重继承，虽然 Java 的类不可以多继承，但是接口可以多继承</li>
<li>Java 有自动内存管理垃圾回收机制（GC），不需要程序员手动释放无用内存</li>
<li>C++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，与 Java 最初的设计思想不符）</li>
</ol>
<h3 id="Java-单继承的原因">Java 单继承的原因</h3>
<ol>
<li>如果在一个子类继承的多个父类中拥有相同名字的实例变量，子类在引用该变量时将产生歧义，无法判断应该使用哪个父类的变量</li>
<li>如果在一个子类继承的多个父类中拥有相同方法，子类中又没有覆盖该方法，那么调用该方法时将产生歧义，无法判断应该调用哪个父类的方法</li>
</ol>
<h3 id="为什么接口可以多实现？">为什么接口可以多实现？</h3>
<p>在 Java8 之前接口是无法定义具体方法实现的，所以即使有多个接口必须子类自己实现，所以并不会发生歧义</p>
<p>Java8 之后出了默认方法，可能会出现歧义的情况，所以 Java 强制规定，如果多个接口内有相同的默认方法，子类必须重写这个方法，否则编译期就会报错</p>
<h2 id="面向对象和面向过程">面向对象和面向过程</h2>
<h3 id="概念">概念</h3>
<ol>
<li>面向过程 POP（步骤化）：分析出实现需求所需要的步骤，通过函数（方法）一步一步实现这些步骤，接着依次调用</li>
<li>面向对象 OOP（行为化）：把整个需求按照特点、功能划分，将这些存在共性的部分封装成类，创建对象不是为了完成某一个步骤，而是描述某个事物在解决问题的步骤中的行为</li>
</ol>
<h3 id="OOP-和-POP-的区别">OOP 和 POP 的区别</h3>
<ol>
<li>编程思路不同：面向过程以实现功能的函数开发为主，而面向对象要首先抽象出类、属性及其方法，然后通过实例化类、执行方法来完成功能</li>
<li>封装性：都具有封装性，但是面向过程封装的是功能，而面向对象封装的是数据和功能</li>
<li>面向对象具有继承性和多态性，而面向过程没有继承性和多态性</li>
</ol>
<h3 id="面向对象特点">面向对象特点</h3>
<ol>
<li>封装：把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息，但是可以提供一些可以被外界访问的方法来操作属性</li>
<li>继承：子类继承父类的属性和方法，它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展</li>
<li>多态：指一个类实例的相同方法在不同情形有不同表现形式，多态机制使具有不同内部结构的对象可以共享相同的外部接口</li>
</ol>
<p><strong>编译时多态（静态多态）</strong></p>
<p>在编译阶段确定方法的调用，主要是通过方法重载实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Integer: &quot;</span> + a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(<span class="type">double</span> a)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Double: &quot;</span> + a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(String a)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;String: &quot;</span> + a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Example</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Example</span>();</span><br><span class="line">        obj.display(<span class="number">5</span>);         <span class="comment">// 调用 display(int a)</span></span><br><span class="line">        obj.display(<span class="number">3.14</span>);      <span class="comment">// 调用 display(double a)</span></span><br><span class="line">        obj.display(<span class="string">&quot;Hello&quot;</span>);   <span class="comment">// 调用 display(String a)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行时多态（动态动态）</strong></p>
<p>在运行时确定方法的调用，主要是通过方法重写实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal makes a sound&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog barks&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cat meows&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">myDog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(); <span class="comment">// Animal reference but Dog object</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">myCat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(); <span class="comment">// Animal reference but Cat object</span></span><br><span class="line"></span><br><span class="line">        myDog.sound(); <span class="comment">// 输出: Dog barks</span></span><br><span class="line">        myCat.sound(); <span class="comment">// 输出: Cat meows</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础（7-泛型）</title>
    <url>/blog/2024/12/25/%E5%BF%83%E5%BE%97/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%EF%BC%887-%E6%B3%9B%E5%9E%8B%EF%BC%89/</url>
    <content><![CDATA[<h2 id="类型擦除">类型擦除</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="string">&quot;yes&quot;</span>); <span class="comment">// 加入string</span></span><br><span class="line">list.add(<span class="number">233</span>); <span class="comment">// 加入int</span></span><br></pre></td></tr></table></figure>
<p>Java 集合有个缺点：把一个对象“丢进”集合里之后，集合就会“忘记”这个对象的数据类型，当再次取出该对象时，该对象的编译类型就变成了 Object 类型，还需要进行强制类型转换。从 Java 5 开始，Java 引入了“参数化类型”的概念，允许程序在创建集合时指定集合元素的类型，Java 的参数类型被称为泛型。例如：List &lt; String &gt; 只能保存 String 类型的对象</p>
<p>泛型信息只存在于代码编译阶段，在进入 JVM 之前，与泛型相关的信息会被擦除掉。例如：在代码中定义的 List &lt; Object &gt;、List &lt; String &gt; 等类型，在编译之后都会变成 List。在泛型类被类型擦除的时候，之前泛型类中的类型参数部分如果没有指定上限，如 &lt; T &gt; 则会被转译成普通的 Object 类型，如果指定了上限如 &lt; T extends String &gt; 则类型参数就被替换成类型上限</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="number">12</span>);</span><br><span class="line"><span class="comment">//这里直接添加会报错</span></span><br><span class="line">list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line">Class&lt;? <span class="keyword">extends</span> <span class="title class_">List</span>&gt; clazz = list.getClass();</span><br><span class="line"><span class="type">Method</span> <span class="variable">add</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;add&quot;</span>, Object.class);</span><br><span class="line"><span class="comment">//但是通过反射添加是可以的，这就说明在运行期间所有的泛型信息都会被擦掉</span></span><br><span class="line">add.invoke(list, <span class="string">&quot;kl&quot;</span>);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>
<p><strong>为什么泛型的实现是类型擦除？</strong></p>
<p>主要原因是为了向下兼容，即兼容 Java5 之前的编译的 class 文件，例如：Java1.2 上正在跑的代码可以在 Java5 的 JRE 上运行</p>
<h2 id="常用的通配符">常用的通配符</h2>
<ol>
<li>?：表示不确定的 Java 类型</li>
<li>T（type）：表示具体的一个 Java 类型</li>
<li>K V（key value）：分别代表 Java 键值对中的 Key Value</li>
<li>E（element）：代表 Element</li>
</ol>
<h2 id="限定通配符和非限定通配符">限定通配符和非限定通配符</h2>
<ol>
<li>
<? extends T> 通过确保类型必须是 T 的子类来设定类型的上界
</li>
<li>
<? super T> 通过确保类型必须是 T 的父类来设定类型的下界
</li>
</ol>
<p><strong>List &lt;? extends T&gt; 和 List &lt;? super T&gt; 的区别</strong></p>
<ol>
<li>
<p>List &lt;? extends T&gt; 可以接收任何继承自 T 的类型的 List，通常用于读取操作，确保可以读取为 T 或 T 的子类的对象</p>
</li>
<li>
<p>List &lt;? super T&gt; 可以接收任何 T 的父类构成的 List，通常用于写入操作，确保可以安全地向泛型集合中插入 T 类型的对象</p>
</li>
</ol>
<p>注意：Array 不支持泛型，要用 List 代替 Array，因为 List 可以提供编译器的类型安全保证，而 Array 却不能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(List&lt;? extends Number&gt; list)</span> &#123;</span><br><span class="line">    <span class="type">Number</span> <span class="variable">num</span> <span class="operator">=</span> list.get(<span class="number">0</span>); <span class="comment">// 读取时是安全的，返回类型是 Number 或其子类</span></span><br><span class="line">    <span class="comment">// list.add(1); // 编译错误，不能往其中添加元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addToList</span><span class="params">(List&lt;? <span class="built_in">super</span> Integer&gt; list)</span> &#123;</span><br><span class="line">    list.add(<span class="number">1</span>); <span class="comment">// 可以安全地添加 Integer 类型的元素</span></span><br><span class="line">    <span class="comment">// Integer value = list.get(0); // 编译错误，不能安全地读取</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>PECS原则</strong></p>
<ol>
<li>Producer Extends：如果某个对象提供数据（即生产者），使用extends（上界限定符）</li>
<li>Consumer Super：如果某个对象使用数据（即消费者），使用super（下界限定符）</li>
</ol>
<h2 id="协变和逆变">协变和逆变</h2>
<ol>
<li>协变：子类型可以替换父类型</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">List&lt;? <span class="keyword">extends</span> <span class="title class_">Animal</span>&gt; animals;  <span class="comment">// 协变</span></span><br><span class="line">animals = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Dog&gt;();  <span class="comment">// 子类型（Dog）替换父类型（Animal）</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>逆变：父类型可以替换子类型</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">List&lt;? <span class="built_in">super</span> Dog&gt; dogs;       <span class="comment">// 逆变</span></span><br><span class="line">dogs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Animal&gt;();  <span class="comment">// 父类型（Animal）替换子类型（Dog）</span></span><br></pre></td></tr></table></figure>
<h2 id="使用案例">使用案例</h2>
<h3 id="泛型类">泛型类</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generic</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Generic</span><span class="params">(T key)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化泛型类</span></span><br><span class="line">Generic&lt;Integer&gt; genericInteger = <span class="keyword">new</span> <span class="title class_">Generic</span>&lt;Integer&gt;(<span class="number">123456</span>);</span><br></pre></td></tr></table></figure>
<h3 id="泛型接口">泛型接口</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Generator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不指定类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span> <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;String&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="泛型方法">泛型方法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(E[] inputArray)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (E element : inputArray) &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%s &quot;</span>, element);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建不同类型数组： Integer, Double 和 Character</span></span><br><span class="line">Integer[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">String[] stringArray = &#123; <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span> &#125;;</span><br><span class="line">printArray(intArray);</span><br><span class="line">printArray(stringArray);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础（8-其他）</title>
    <url>/blog/2025/01/29/%E5%BF%83%E5%BE%97/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%EF%BC%888-%E5%85%B6%E4%BB%96%EF%BC%89/</url>
    <content><![CDATA[<h2 id="JDK-和-JRE、JVM">JDK 和 JRE、JVM</h2>
<h3 id="区别">区别</h3>
<ol>
<li>JRE：Java 运行环境，提供了 Java 运行所需的环境，包含了 JVM、核心类库和其他支持运行 Java 程序的文件</li>
<li>JDK：Java 开发工具包，提供了 Java 的开发环境和运行环境。JDK 包含了 JRE，如果只运行 Java 程序，安装 JRE 即可，要编写 Java 程序需安装 JDK</li>
<li>JVM：Java 虚拟机，是整个 Java 实现跨平台的最核心的部分，能够运行以 Java 语言写作的软件程序。所有的 Java 程序会首先被编译为.class 的类文件，这种类文件可以在虚拟机上运行</li>
</ol>
<h3 id="字节码">字节码</h3>
<p>在 Java 中，JVM 可以理解的代码叫做字节码（即扩展名为.class 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方法，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以，Java 程序运行时相对来说还是高效的（不过，和 C++，Rust，Go 等语言还是有一定差距的），而且，由于字节码并不针对一种特定的机器，因此，Java 程序无需重新编译便可在多种不同操作系统的计算机上运行</p>
<p><img src="1.png" alt=""></p>
<p><img src="2.png" alt=""></p>
<h3 id="JIT">JIT</h3>
<p>.class-&gt; 机器码，在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的（也就是所谓的热点代码），所以后面引进了 JIT（just-in-time compilation）编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用</p>
<h2 id="引用和对象">引用和对象</h2>
<ol>
<li><font style="color:rgb(51, 51, 51);"> new Hero();：代表创建了一个 Hero 对象，但是也仅仅是创建了一个对象，没有办法访问它。</font></li>
<li><font style="color:rgb(51, 51, 51);"> Hero h = new Hero();：为了访问这个对象，会使用引用来代表这个对象，h 这个变量是 Hero 类型，又叫做引用。= 指的是 h 这个引用代表右侧创建的对象，在面向对象里，又叫做“指向”</font></li>
<li><font style="color:rgb(51, 51, 51);"> 一个对象引用可以指向 0 个或 1 个对象；一个对象可以有 n 个引用指向它 </font></li>
<li><font style="color:rgb(51, 51, 51);"> 对象的相等一般比较的是内存中存放的内容是否相等 </font></li>
<li><font style="color:rgb(51, 51, 51);"> 引用相等一般比较的是他们指向的内存地址是否相等 </font></li>
</ol>
<h3 id="创建对象的方法">创建对象的方法</h3>
<ol>
<li>使用 new 关键字</li>
<li>使用 Class 类的 newInstance 方法，该方法调用无参的构造器创建对象（反射）：Class.forName.newInstance()</li>
<li>使用 clone()方法</li>
<li>反序列化，例如：调用 ObjectInputStream 类的 readObject()方法</li>
</ol>
<h3 id="值传递和引用传递">值传递和引用传递</h3>
<ol>
<li>值传递是对基本型变量而言的，传递的是该变量的一个副本，改变副本不影响原变量</li>
<li>引用传递一般是对于对象型变量而言的，传递的是该对象地址的一个副本，并不是原对象本身，在方法中对其值进行改变的时候，他的地址没有变，值也就跟着改变了，对引用对象进行操作会同时改变原对象</li>
</ol>
<p>注意：Java 内的传递都是值传递</p>
<h3 id="传递基本类型参数">传递基本类型参数</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    swap(num1, num2);</span><br><span class="line">    System.out.println(<span class="string">&quot;num1 = &quot;</span> + num1);</span><br><span class="line">    System.out.println(<span class="string">&quot;num2 = &quot;</span> + num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">    System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">    System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="3.png" alt=""></p>
<p>a、b 相当于 num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身</p>
<h3 id="传递引用类型参数-1">传递引用类型参数 1</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">  System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">  change(arr);</span><br><span class="line">  System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">  <span class="comment">// 将数组的第一个元素变为0</span></span><br><span class="line">  array[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="4.png" alt=""></p>
<h3 id="传递引用类型参数-2">传递引用类型参数 2</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="comment">// 省略构造函数、Getter&amp;Setter方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">xiaoZhang</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小张&quot;</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">xiaoLi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小李&quot;</span>);</span><br><span class="line">    swap(xiaoZhang, xiaoLi);</span><br><span class="line">    System.out.println(<span class="string">&quot;xiaoZhang:&quot;</span> + xiaoZhang.getName());</span><br><span class="line">    System.out.println(<span class="string">&quot;xiaoLi:&quot;</span> + xiaoLi.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Person person1, Person person2)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">temp</span> <span class="operator">=</span> person1;</span><br><span class="line">    person1 = person2;</span><br><span class="line">    person2 = temp;</span><br><span class="line">    System.out.println(<span class="string">&quot;person1:&quot;</span> + person1.getName());</span><br><span class="line">    System.out.println(<span class="string">&quot;person2:&quot;</span> + person2.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="5.png" alt=""></p>
<p>swap 方法的参数 person1 和 person2 只是拷贝的实参 xiaoZhang 和 xiaoLi 的地址。因此，person1 和 person2 的互换只是拷贝的两个地址互换罢了，并不会影响到实参 xiaoZhang 和 xiaoLi</p>
<h2 id="克隆">克隆</h2>
<h3 id="为什么要克隆？">为什么要克隆？</h3>
<p>克隆的对象可能包含一些已经修改过的属性，而 new 出来的对象的属性都还是初始化时候的值，所以当需要一个新的对象来保存当前对象的“状态”就靠 clone 方法了，那么把这个对象的临时属性一个一个赋值给我新 new 的对象不也行吗？可以，但是操作麻烦，且 clone 是一个 native 方法，在底层实现的，效率快</p>
<h3 id="如何实现对象的克隆？">如何实现对象的克隆？</h3>
<ol>
<li>实现 Cloneable 接口（为标记接口），重写 Object 类中的 clone()方法（浅克隆）</li>
<li>实现 Serializable 接口，通过对象的序列化和反序列化实现克隆（深克隆）</li>
</ol>
<h3 id="深克隆和浅克隆">深克隆和浅克隆</h3>
<ol>
<li>浅克隆：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(Integer id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Student student;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, student=&quot;</span> + student +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">getStudent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> student;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStudent</span><span class="params">(Student student)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.student = student;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(Integer id, String name, Student student)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.student = student;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Person <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> (Person) <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">1</span>, <span class="string">&quot;stu&quot;</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">per1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1</span>, <span class="string">&quot;per&quot;</span>, stu);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">per2</span> <span class="operator">=</span> per1.clone();</span><br><span class="line">        System.out.println(per1);</span><br><span class="line">        System.out.println(per2);</span><br><span class="line">        System.out.println(per1.getStudent().getClass()==per2.getStudent().getClass());</span><br><span class="line"></span><br><span class="line">        per1.setName(<span class="string">&quot;person&quot;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu2</span> <span class="operator">=</span> per1.getStudent();</span><br><span class="line">        stu2.setName(<span class="string">&quot;stu2&quot;</span>);</span><br><span class="line">        System.out.println(per1);</span><br><span class="line">        System.out.println(per2);</span><br><span class="line">        System.out.println(per1.getStudent().getClass()==per2.getStudent().getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果为：</span></span><br><span class="line"><span class="comment">Person&#123;id=1, name=&#x27;per&#x27;, student=Student&#123;id=1, name=&#x27;stu&#x27;&#125;&#125;</span></span><br><span class="line"><span class="comment">Person&#123;id=1, name=&#x27;per&#x27;, student=Student&#123;id=1, name=&#x27;stu&#x27;&#125;&#125;</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">Person&#123;id=1, name=&#x27;person&#x27;, student=Student&#123;id=1, name=&#x27;stu2&#x27;&#125;&#125;</span></span><br><span class="line"><span class="comment">Person&#123;id=1, name=&#x27;per&#x27;, student=Student&#123;id=1, name=&#x27;stu2&#x27;&#125;&#125;</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>注意：克隆后的值变量会开辟新的内存地址，克隆对象修改值不会影响原来对象。引用类型只会存在一份内存地址，执行 Object 的 clone 方法拷贝的也是引用的复制（这部分的内存空间不一样），但是引用指向的内存空间是一样的，原对象修改变量或者浅拷贝修改引用变量都会引起双方的变化</p>
<ol start="2">
<li>深克隆：拷贝对象和原始对象的引用类型引用不同对象。深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Student student;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Teacher</span><span class="params">(String name, <span class="type">int</span> age, Student student)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.student = student;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 覆盖</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Teacher</span> <span class="variable">t</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t = (Teacher) <span class="built_in">super</span>.clone();</span><br><span class="line">            t.student = (Student)student.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">getStudent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> student;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStudent</span><span class="params">(Student student)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.student = student;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;学生1&quot;</span>, <span class="number">11</span>);</span><br><span class="line">        <span class="type">Teacher</span> <span class="variable">origin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;老师原对象&quot;</span>, <span class="number">23</span>, s);</span><br><span class="line">        System.out.println(<span class="string">&quot;克隆前的学生姓名：&quot;</span> + origin.getStudent().getName());</span><br><span class="line">        <span class="type">Teacher</span> <span class="variable">clone</span> <span class="operator">=</span> (Teacher) origin.clone();</span><br><span class="line">        <span class="comment">// 更改克隆后的学生信息 更改了姓名</span></span><br><span class="line">        clone.getStudent().setName(<span class="string">&quot;我是克隆对象更改后的学生2&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;克隆后的学生姓名：&quot;</span> + clone.getStudent().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">克隆前的学生姓名：学生1</span></span><br><span class="line"><span class="comment">克隆后的学生姓名：我是克隆对象更改后的学生2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="switch-语句">switch 语句</h2>
<p>在 switch(expr)中，expr 只能是一个整数表达式或者枚举常量。而整数表达式可以是 int 基本数据类型或者是 Integer 包装类型，由于 byte、short、char 都可以隐式转换为 int，而 long 和 String 类型都不符合 switch 的语法规定，并且不能被隐式地转换为 int 类型，所以它们都不能作用于 switch 语句中。JDK1.7 版本后 switch 就可以作用在 String 上了</p>
<h2 id="short-s1-1-s1-s1-1">short s1 = 1; s1 = s1+1;</h2>
<ol>
<li>对于 short s1 = 1; s1 = s1+1; 来说，在 s1+1 运算时会自动提升表达式的类型为 int，那么将 int 型值赋给 short 型变量，s1 会出现类型转换错误，应改为：s1 =(short)(s1+1)</li>
<li>对于 short s1 = 1; s1+= 1; 来说，+= 是 Java 语言规定的运算符，Java 编译器会对它进行特殊处理，因此可以正确编译</li>
</ol>
<p><strong>注意：(x+= i)不等于(x = x+i)</strong></p>
<ol>
<li>第一个表达式使用的是复合赋值操作符，复合赋值表达式自动地将所执行计算的结果转型为其左侧变量的类型，</li>
<li>如果结果的类型与该变量的类型相同，那么这个转型不会造成任何影响。</li>
<li>如果结果的类型比该变量的类型要宽，那么复合赋值操作符将悄悄地执行一个窄化原生类型转换</li>
</ol>
<h2 id="final、finally-和-finalize-的区别">final、finally 和 finalize 的区别</h2>
<ol>
<li>final 用于声明属性、方法和类，分别表示属性不可变、方法不可覆盖、类不可继承</li>
<li>finally 作为异常处理的一部分，只能在 try/catch 语句中使用，finally 附带一个语句块用来表示这个语句最终一定被执行，经常被用在需要释放资源的情况下</li>
<li>finalize 是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的 finalize()方法。当垃圾收集器准备好释放对象占用空间时，首先会调用 finalize()方法，并在下一次垃圾回收动作发生时真正回收对象占用的内存</li>
</ol>
<h2 id="BigDecimal">BigDecimal</h2>
<h3 id="为什么会出现-4-0-3-6-0-4000001-这种现象？">为什么会出现 4.0-3.6 = 0.4000001 这种现象？</h3>
<p>2 进制的小数无法精确的表示 10 进制小数，计算机在计算 10 进制小数的过程中要先转换为 2 进制进行计算，这个过程中出现了误差</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2.0f</span> - <span class="number">1.9f</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1.8f</span> - <span class="number">1.7f</span>;</span><br><span class="line">System.out.println(a);<span class="comment">// 0.100000024</span></span><br><span class="line">System.out.println(b);<span class="comment">// 0.099999905</span></span><br><span class="line">System.out.println(a == b);<span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="使用-BigDecimal-解决精度丢失">使用 BigDecimal 解决精度丢失</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">x</span> <span class="operator">=</span> a.subtract(b);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">y</span> <span class="operator">=</span> b.subtract(c);</span><br><span class="line"></span><br><span class="line">System.out.println(x); <span class="comment">/* 0.1 */</span></span><br><span class="line">System.out.println(y); <span class="comment">/* 0.1 */</span></span><br><span class="line">System.out.println(Objects.equals(x, y)); <span class="comment">/* true */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line">System.out.println(a.add(b));<span class="comment">// 1.9</span></span><br><span class="line">System.out.println(a.subtract(b));<span class="comment">// 0.1</span></span><br><span class="line">System.out.println(a.multiply(b));<span class="comment">// 0.90</span></span><br><span class="line">System.out.println(a.divide(b));<span class="comment">// 无法除尽，抛出 ArithmeticException 异常</span></span><br><span class="line">System.out.println(a.divide(b, <span class="number">2</span>, RoundingMode.HALF_UP));<span class="comment">// 1.11</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">RoundingMode</span> &#123;</span><br><span class="line">   <span class="comment">// 2.5 -&gt; 3 , 1.6 -&gt; 2</span></span><br><span class="line">   <span class="comment">// -1.6 -&gt; -2 , -2.5 -&gt; -3</span></span><br><span class="line">             UP(BigDecimal.ROUND_UP),</span><br><span class="line">   <span class="comment">// 2.5 -&gt; 2 , 1.6 -&gt; 1</span></span><br><span class="line">   <span class="comment">// -1.6 -&gt; -1 , -2.5 -&gt; -2</span></span><br><span class="line">             DOWN(BigDecimal.ROUND_DOWN),</span><br><span class="line">             <span class="comment">// 2.5 -&gt; 3 , 1.6 -&gt; 2</span></span><br><span class="line">   <span class="comment">// -1.6 -&gt; -1 , -2.5 -&gt; -2</span></span><br><span class="line">             CEILING(BigDecimal.ROUND_CEILING),</span><br><span class="line">             <span class="comment">// 2.5 -&gt; 2 , 1.6 -&gt; 1</span></span><br><span class="line">   <span class="comment">// -1.6 -&gt; -2 , -2.5 -&gt; -3</span></span><br><span class="line">             FLOOR(BigDecimal.ROUND_FLOOR),</span><br><span class="line">       <span class="comment">// 2.5 -&gt; 3 , 1.6 -&gt; 2</span></span><br><span class="line">   <span class="comment">// -1.6 -&gt; -2 , -2.5 -&gt; -3</span></span><br><span class="line">             HALF_UP(BigDecimal.ROUND_HALF_UP),</span><br><span class="line">   <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础（反射）</title>
    <url>/blog/2025/01/13/%E5%BF%83%E5%BE%97/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8F%8D%E5%B0%84%EF%BC%89/</url>
    <content><![CDATA[<h2 id="什么是反射？">什么是反射？</h2>
<ol>
<li>Java 反射机制的核心是在程序运行时动态加载类并获取类的详细信息，从而操作类或对象的属性或方法，本质是 JVM 得到 class 对象之后，从而获取对象的各种信息</li>
<li>Java 属于先编译再运行的语言，程序中对象的类型在编译期就确定下来了，而当程序在运行时可能需要动态加载某些类，这些类因为之前用不到，所以没有加载到 JVM。通过反射可以在运行时动态地创建对象并调用其属性，不需要提前在编译期知道运行的对象是谁</li>
</ol>
<h2 id="为什么需要反射？">为什么需要反射？</h2>
<ol>
<li>在编译阶段不知道哪个类名，要在运行期从配置文件读取类名，这时候就没有硬编码</li>
</ol>
<p>例如：项目底层有时用 MySQL，有时用 Oracle，需要动态地根据实际情况加载驱动类，假设 <code>com.java.dbtest.mysqlConnection</code>，<code>com.java.dbtest.oracleConnection</code> 要用这两个类，这时候程序就写得比较动态化，通过 <code>Class tc = Class.forName(&quot;com.java.dbtest.TestConnection&quot;);</code> 类的全类名让 JVM 在服务器中找到并加载这个类，而如果是 Oracle，则传入的参数就变成另一个了。</p>
<ol start="2">
<li>Java 程序中的对象在运行时可以表现为两种类型，即编译时类型和运行时类型。</li>
</ol>
<p>例如 <code>Person p = new Student();</code> ，这行代码将会生成一个 p 变量，该变量的编译时类型为 Person，运行时类型为 Student。有时程序在运行时接收到外部传入的一个对象，该对象的编译时类型是 Object，但程序又需要调用该对象的运行时类型的方法，这就要求程序需要在运行时发现对象和类的真实信息</p>
<ul>
<li>假设在编译时和运行时都完全知道类型的具体信息，在这种情况下，可以先使用 instanceof 运算符进行判断，再利用强制类型转换将其转换成其运行时类型的变量即可。</li>
<li>编译时根本无法预知该对象和类可能属于哪些类，程序只依靠运行时信息来发现该对象和类的真实信息，这就必须使用反射。</li>
</ul>
<h2 id="使用场景">使用场景</h2>
<ol>
<li>不能明确接口调用哪个函数，需要根据传入的参数在运行时决定</li>
<li>不能明确传入函数的参数类型，需要在运行时处理任意对象</li>
<li>用 JDBC 连接数据库时使用 Class.forName()通过反射加载数据库的驱动程序</li>
<li>Spring 框架也用到反射机制</li>
</ol>
<p>Spring 通过 XML 配置装载 Bean 的过程：</p>
<ul>
<li>将程序内所有 XML 或 Properties 配置文件加载入内存中</li>
<li>Java 类里面解析 XML 或 Properties 里面的内容，得到对应实体类的字节码字符串以及相关的属性信息</li>
<li>使用反射机制，根据这个字符串获得某个类的 Class 实例</li>
<li>动态配置实例的属性</li>
</ul>
<h2 id="类加载器">类加载器</h2>
<p>ClassLoader：负责加载类的对象</p>
<p>ClassLoader 中的两个方法：</p>
<ol>
<li>static ClassLoader getSystemClassLoader()：返回用于委派的系统类加载器</li>
<li>ClassLoader getParent()：返回父类加载器进行委派</li>
</ol>
<p>Java 运行时具有以下内置类加载器：</p>
<ol>
<li>Bootstrap class loader：虚拟机的内置类加载器，通常表示为 null，并且没有父加载器</li>
<li>Platform class loader：平台类加载器可以看到所有平台类，平台类包括由平台类加载器或其祖先定义的 Java  SE 平台 API，其实现类和 JDK 特定的运行时类</li>
<li>System class loader：应用程序类加载器，系统类加载器通常用于定义应用程序类路径，模块路径和 JDK 特定工具上的类</li>
</ol>
<p>类加载器的继承关系：System 的父加载器为 Platform，而 Platform 的父加载器为 Bootstrap</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">systemClassLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">    System.out.println(systemClassLoader);</span><br><span class="line"></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">parent</span> <span class="operator">=</span> systemClassLoader.getParent();</span><br><span class="line">    System.out.println(parent);</span><br><span class="line"></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">parent1</span> <span class="operator">=</span> parent.getParent();</span><br><span class="line">    System.out.println(parent1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用案例">使用案例</h2>
<h3 id="获取-Class-对象的方式">获取 Class 对象的方式</h3>
<ol>
<li>Class.forName(“全类名”)：将字节码文件加载进内存，返回 class 对象</li>
<li>类型.class：通过类名的属性 class 获取</li>
<li>对象.getClass()：getClass()方法在 Object 类中定义</li>
<li>类型.TYPE</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name=<span class="string">&quot;学生&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Teacher</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name=<span class="string">&quot;老师&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">aClass</span> <span class="operator">=</span> person.getClass();</span><br><span class="line">        System.out.println(aClass);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">aClass1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.reflect.Student&quot;</span>);</span><br><span class="line">        System.out.println(aClass1);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">aClass2</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        System.out.println(aClass2);</span><br><span class="line"></span><br><span class="line">        System.out.println(aClass == aClass1);</span><br><span class="line">        System.out.println(aClass == aClass2);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">type</span> <span class="operator">=</span> Integer.TYPE;</span><br><span class="line">        System.out.println(type);</span><br><span class="line">        </span><br><span class="line">        <span class="type">Class</span> <span class="variable">integerClass</span> <span class="operator">=</span> Integer.class;</span><br><span class="line">        System.out.println(integerClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结论：同一个字节码文件（*.class）在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的 Class 对象都是同一个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只要元素类型与维度一样，就是同一个class</span></span><br><span class="line"><span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span>[] b = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100</span>];</span><br><span class="line">System.out.println(a.getClass().hashCode());</span><br><span class="line">System.out.println(b.getClass().hashCode());</span><br></pre></td></tr></table></figure>
<h3 id="获取成员变量">获取成员变量</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">public</span> String b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃&quot;</span>+s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Field：成员变量</p>
<ol>
<li>Field [] getFields()：获取所有 public 修饰的成员变量</li>
<li>Field getField(String name)：获取指定名称的 public 修饰的成员变量</li>
<li>Field [] getDeclaredFields()：获取所有的成员变量，不考虑修饰符</li>
<li>Field getDeclaredField(String name)：获取指定名称的成员变量，不考虑修饰符</li>
<li>void set(Object obj, Object value)：设置值</li>
<li>get(Object obj)：获取值</li>
<li>setAccessible(true)：暴力反射（忽略访问权限修饰符的安全检查）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">personClass</span> <span class="operator">=</span> Person.class;</span><br><span class="line">    Field[] fields = personClass.getFields();</span><br><span class="line">    <span class="keyword">for</span> (Field field:fields)&#123;</span><br><span class="line">        System.out.println(field);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Field</span> <span class="variable">a</span> <span class="operator">=</span> personClass.getField(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    System.out.println(a);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> a.get(person);</span><br><span class="line">    System.out.println(o);</span><br><span class="line">	System.out.println(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    a.set(person,<span class="number">12</span>);</span><br><span class="line">    System.out.println(person);</span><br><span class="line">    System.out.println(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Field[] declaredFields = personClass.getDeclaredFields();</span><br><span class="line">    <span class="keyword">for</span> (Field field:declaredFields)&#123;</span><br><span class="line">        System.out.println(field);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Field</span> <span class="variable">a1</span> <span class="operator">=</span> personClass.getDeclaredField(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    a1.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> a1.get(person);</span><br><span class="line">    System.out.println(o1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取构造方法">获取构造方法</h3>
<p>Constructor：构造方法</p>
<ol>
<li>Constructor &lt;?&gt; []  getConstructors()</li>
<li>Constructor &lt; T &gt;  getConstructor(类 &lt;?&gt;…  parameterTypes)</li>
<li>Constructor &lt; T &gt;  getDeclaredConstructor(类 &lt;?&gt;…  parameterTypes)</li>
<li>Constructor &lt;?&gt; []  getDeclaredConstructors()</li>
</ol>
<h3 id="创建对象">创建对象</h3>
<p>T  newInstance(Object…  initargs)</p>
<p>如果使用空参数构造方法创建对象，操作可以简化：Class 对象.newInstance()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">personClass</span> <span class="operator">=</span> Person.class;</span><br><span class="line">    <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> personClass.getConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">    System.out.println(constructor);</span><br><span class="line">    </span><br><span class="line">    <span class="type">Object</span> <span class="variable">dad</span> <span class="operator">=</span> constructor.newInstance(<span class="string">&quot;dad&quot;</span>, <span class="number">12</span>);</span><br><span class="line">    System.out.println(dad);</span><br><span class="line">    System.out.println(<span class="string">&quot;---------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Constructor</span> <span class="variable">constructor1</span> <span class="operator">=</span> personClass.getConstructor();</span><br><span class="line">    System.out.println(constructor1);</span><br><span class="line">    </span><br><span class="line">    <span class="type">Object</span> <span class="variable">dad1</span> <span class="operator">=</span> constructor1.newInstance();</span><br><span class="line">    System.out.println(dad1);</span><br><span class="line">    System.out.println(<span class="string">&quot;----------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> personClass.newInstance();</span><br><span class="line">    System.out.println(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取成员方法">获取成员方法</h3>
<p>Method：方法对象</p>
<ol>
<li>Method []  getMethods()：获取所有 public 修饰的方法</li>
<li>Method getMethod(String name, 类 &lt;?&gt;…  parameterTypes)</li>
<li>Method [] getDeclaredMethods()</li>
<li>Method getDeclaredMethod(String name, 类 &lt;?&gt;…  parameterTypes)</li>
</ol>
<h3 id="执行方法">执行方法</h3>
<p>Object  invoke(Object  obj，Object…  args)</p>
<h3 id="获取方法名称">获取方法名称</h3>
<p>String  getName()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">personClass</span> <span class="operator">=</span> Person.class;</span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> personClass.getMethod(<span class="string">&quot;eat&quot;</span>);</span><br><span class="line">    System.out.println(method);</span><br><span class="line">    </span><br><span class="line">    Person person=<span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    method.invoke(person);</span><br><span class="line">    </span><br><span class="line">    <span class="type">Method</span> <span class="variable">eat</span> <span class="operator">=</span> personClass.getMethod(<span class="string">&quot;eat&quot;</span>, String.class);</span><br><span class="line">    eat.invoke(person,<span class="string">&quot;饭&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Method[] methods = personClass.getMethods();</span><br><span class="line">    <span class="keyword">for</span> (Method method1:methods)&#123;</span><br><span class="line">        System.out.println(method1);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> method1.getName();</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;------------------&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> personClass.getName();</span><br><span class="line">    System.out.println(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取类名">获取类名</h3>
<ol>
<li>String  getName()：获取包名+类名</li>
<li>String  getSimpleName()：获取类名</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">aClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.reflect.Person&quot;</span>);</span><br><span class="line">        <span class="comment">//获取包名+类名</span></span><br><span class="line">        System.out.println(aClass.getName());</span><br><span class="line">        <span class="comment">//获取类名</span></span><br><span class="line">        System.out.println(aClass.getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="反射效率">反射效率</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test07</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">        User user=<span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">            user.getName();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> end=System.currentTimeMillis();</span><br><span class="line">        System.out.println(end-start);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        User user=<span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">aClass</span> <span class="operator">=</span> user.getClass();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">getName</span> <span class="operator">=</span> aClass.getDeclaredMethod(<span class="string">&quot;getName&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">            getName.invoke(user,<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> end=System.currentTimeMillis();</span><br><span class="line">        System.out.println(end-start);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        User user=<span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">aClass</span> <span class="operator">=</span> user.getClass();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">getName</span> <span class="operator">=</span> aClass.getDeclaredMethod(<span class="string">&quot;getName&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        getName.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">            getName.invoke(user,<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> end=System.currentTimeMillis();</span><br><span class="line">        System.out.println(end-start);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InvocationTargetException, NoSuchMethodException, IllegalAccessException &#123;</span><br><span class="line">        test01();</span><br><span class="line">        test02();</span><br><span class="line">        test03();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：设置 setAccessible()能使加快速率</p>
<h3 id="获取父类类型">获取父类类型</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">aClass1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.reflect.Student&quot;</span>);</span><br><span class="line">System.out.println(aClass1);</span><br><span class="line"></span><br><span class="line"><span class="type">Class</span> <span class="variable">superclass</span> <span class="operator">=</span> aClass1.getSuperclass();</span><br><span class="line">System.out.println(superclass);</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ol>
<li>.getClass().getResource(fileName)：表示只会在当前调用类所在的同一路径下查找该 fileName 文件</li>
<li>.getClass().getClassLoader().getResource(fileName)：表示只会在根目录下（/）查找该文件</li>
<li>fileName 如果前面加“/”，如“/fileName”，则表示绝对路径，取/目录下的该文件；</li>
<li>fileName 如果前面没有加“/”，如“fileName”，则表示相对路径，取与调用类同一路径下的该文件</li>
<li>如果路径中包含包名，getClass().getResource(“com/xxx/1.xml”); 包名的层级使用“/”隔开，而非“.”</li>
</ol>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础（IO流）</title>
    <url>/blog/2025/01/12/%E5%BF%83%E5%BE%97/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%EF%BC%88IO%E6%B5%81%EF%BC%89/</url>
    <content><![CDATA[<h2 id="IO-流分类">IO 流分类</h2>
<table>
<thead>
<tr>
<th>分类</th>
<th>字节输入流</th>
<th>字节输出流</th>
<th>字符输入流</th>
<th>字符输出流</th>
</tr>
</thead>
<tbody>
<tr>
<td>抽象基类</td>
<td>InputStream</td>
<td>OutputStream</td>
<td>Reader</td>
<td>Writer</td>
</tr>
<tr>
<td>访问文件</td>
<td>FileInputStream</td>
<td>FileOutputStream</td>
<td>FileReader</td>
<td>FileWriter</td>
</tr>
<tr>
<td>访问数组</td>
<td>ByteArrayInputStream</td>
<td>ByteArrayOutputStream</td>
<td>CharArrayReader</td>
<td>CharArrayWriter</td>
</tr>
<tr>
<td>访问管道</td>
<td>PipedInputStream</td>
<td>PipedOutputStream</td>
<td>PipedReader</td>
<td>PipedWriter</td>
</tr>
<tr>
<td>访问字符串</td>
<td></td>
<td></td>
<td>StringReader</td>
<td>StringWriter</td>
</tr>
<tr>
<td>缓冲流</td>
<td>BufferedInputStream</td>
<td>BufferedOutputStream</td>
<td>BufferedReader</td>
<td>BufferedWriter</td>
</tr>
<tr>
<td>转换流</td>
<td></td>
<td></td>
<td>InputStreamReader</td>
<td>OutputStreamWriter</td>
</tr>
<tr>
<td>对象流</td>
<td>ObjectInputStream</td>
<td>ObjectOutputStream</td>
<td></td>
<td></td>
</tr>
<tr>
<td>打印流</td>
<td></td>
<td>PrintStream</td>
<td></td>
<td>PrintWriter</td>
</tr>
<tr>
<td>推回输入流</td>
<td>PushbackInputStream</td>
<td></td>
<td>PushbackReader</td>
<td></td>
</tr>
<tr>
<td>特殊流</td>
<td>DataInputStream</td>
<td>DataOutputStream</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="字节流和字符流的区别">字节流和字符流的区别</h2>
<p>字节流按 8 位传输，以字节为单位输入输出数据，字符流按 16 位传输，以字符为单位输入输出数据。但不管文件读写还是网络发送接收，信息的最小存储单元都是字节</p>
<table>
<thead>
<tr>
<th>项</th>
<th>字节流</th>
<th>字符流</th>
</tr>
</thead>
<tbody>
<tr>
<td>操作基本单元</td>
<td>字节</td>
<td>字符</td>
</tr>
<tr>
<td>是否使用缓冲</td>
<td>否</td>
<td>是<br />若频繁对一个资源进行 IO 操作，会先把需要操作的数据暂时放入内存中，以后直接从内存中读取数据，这样可以避免多次的 IO 操作，提高效率</td>
</tr>
<tr>
<td>存在位置</td>
<td>可存在于文件、内存中<br />硬盘中的所有文件都是以字节形式存在的</td>
<td>只存在于内存中</td>
</tr>
<tr>
<td>使用场景</td>
<td>适合操作文本文件之外的文件<br />例如：图片、音频、视频</td>
<td>适合操作文本文件时使用（效率高，因为有缓存）</td>
</tr>
<tr>
<td>Java 相关类</td>
<td>InputStream、OutputStream</td>
<td>Reader、Writer</td>
</tr>
</tbody>
</table>
<h2 id="Java-序列化">Java 序列化</h2>
<ol>
<li>对象的序列化（Serialize），是指将对象转换为字节流的过程</li>
<li>对象的反序列化（Deserialize），则是指将字节流转换为对象的过程</li>
</ol>
<p>作用：序列化机制可以将对象转换成字节序列，这些字节序列可以保存在磁盘上，也可以在网络中传输，并允许程序将这些字节序列再次恢复成原来的对象。</p>
<h2 id="Serializable-接口">Serializable 接口</h2>
<p>若对象要支持序列化机制，则它的类需要实现 Serializable 接口，该接口是一个标记接口，它没有提供任何方法，只是标明类是可以序列化的（除了 String、数组和枚举之外，如果实现了这个接口就走 writerOrdinaryObject，否则序列化就抛出异常）。</p>
<p><strong>序列化实现方式</strong></p>
<p>若要实现序列化，则需要使用对象流 ObjectInputStream 和 ObjectOutputStream。其中，在序列化时需要调用 ObjectOutputStream 对象的 writeObject()方法，以输出对象序列。在反序列化时需要调用 OjectInputStream 对象的 readObject()方法，将对象序列恢复为对象</p>
<p><strong>Serializable 接口为什么需要定义 serialVersionUID 变量？</strong></p>
<p>serialVersionUID 代表序列化的版本，通过定义类的序列化版本，在反序列化时，只要对象中所存的版本和当前类的版本一致，就允许做恢复数据的操作，否则将会抛出序列化版本不一致的错误</p>
<p>serialVersionUID 的值并不重要，无论是 1L 还是 idea 自动生成的，只要序列化的时候对象的 serialVersionUID 和反序列化的时候对象的 serialVersionUID 一致的话就行</p>
<p>如果不定义序列化版本，在反序列化时可能出现冲突的情况：</p>
<ol>
<li>创建该类的实例，并将这个实例序列化，保存在磁盘上</li>
<li>升级这个类，例如：增加、删除、修改这个类的成员变量</li>
<li>反序列化该类的实例，即从磁盘上恢复修改之前保存的数据</li>
</ol>
<p>在第 3 步恢复数据的时候，当前的类已经和序列化的数据的格式产生了冲突，可能会发生各种意想不到的问题。增加了序列化版本之后，在这种情况下则可以抛出异常，以提示这种矛盾的存在，提高数据的安全性</p>
<h2 id="transient-关键字">transient 关键字</h2>
<p>作用：阻止实例中那些用此关键字修饰的变量序列化，当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复（即对于不想进行序列化的字段，可以使用 transient 关键字修饰）</p>
<p><strong>注意</strong></p>
<ol>
<li>transient 只能修饰变量，不能修饰类和方法</li>
<li>transient 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 int 类型，那么反序列化后结果就是 0</li>
<li>static 变量属于类而不属于任何对象，所以无论有没有 transient 关键字修饰，均不会被序列化</li>
</ol>
<h2 id="怎么用流打开一个大文件？">怎么用流打开一个大文件？</h2>
<p>打开大文件，应避免直接将文件中的数据全部读取到内存中，可以采取分次读取的方式</p>
<ol>
<li>使用缓冲流。缓冲流内部维护了一个缓冲区，通过与缓冲区的交互，减少与设备的交互次数。使用缓冲输入流时，它每次会读取一批数据将缓冲区填满，每次调用读取方法并不是直接从设备取值，而是从缓冲区取值，当缓冲区为空时，它会再一次读取数据，将缓冲区填满。使用缓冲输出流时，每次调用写入方法并不是直接写入到设备，而是写入缓冲区，当缓冲区填满时它会自动刷入设备</li>
<li>使用 NIO。NIO 采用内存映射文件的方式来处理输入/输出，NIO 将文件或文件的一段区域映射到内存中，这样就可以像访问内存一样来访问文件了（这种方式模拟了操作系统上的虚拟内存的概念），通过这种方式来进行输入/输出比传统的输入/输出要快得多</li>
</ol>
<h2 id="获取用键盘输入常用的方法">获取用键盘输入常用的方法</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span>  <span class="operator">=</span> input.nextLine();</span><br><span class="line">input.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> input.readLine();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础（异常）</title>
    <url>/blog/2025/01/16/%E5%BF%83%E5%BE%97/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%EF%BC%88%E5%BC%82%E5%B8%B8%EF%BC%89/</url>
    <content><![CDATA[<p><img src="2.png" alt=""></p>
<h2 id="Throwable-常用方法">Throwable 常用方法</h2>
<ol>
<li>String getMessage()：返回异常发生时的简要描述</li>
<li>String toString()：返回异常发生时的详细信息</li>
<li>String getLocalizedMessage()：返回异常对象的本地化信息。使用 Throwable 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 getMessage()返回的结果相同</li>
<li>void printStackTrace()：在控制台上打印 Throwable 对象封装的异常信息</li>
</ol>
<h2 id="Error-和-Exception-的区别">Error 和 Exception 的区别</h2>
<ol>
<li>Error 类：表示严重的错误，一般是指与虚拟机相关的问题，如：内存耗尽（OutOfMemoryError）、栈溢出（StackOverflowError）、系统崩溃、虚拟机错误等，这类错误将会导致应用程序中断，仅靠程序本身无法恢复和预防</li>
<li>Exception 类：表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。分为 Unchecked Exception（运行时异常，可以不处理）和 Checked Exception（检查时异常，必须处理）</li>
</ol>
<p><strong>运行时异常</strong></p>
<p>Java 编译器不会检查它，当程序中出现此类错误时，即使没有对异常进行显式处理，也能够编译通过</p>
<table>
<thead>
<tr>
<th>异常</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ArithmeticException</td>
<td>算数运算异常，由于除数为 0 引起的异常</td>
</tr>
<tr>
<td>ClassCastException</td>
<td>当试图将对象强制转换为不是实例的子类时，抛出该异常</td>
</tr>
<tr>
<td>ArrayStoreException</td>
<td>由于数组存储空间不够引起的异常</td>
</tr>
<tr>
<td>IndexOutOfBoundsException</td>
<td>指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出</td>
</tr>
<tr>
<td>ConcurrentModificationException</td>
<td>并发修改异常</td>
</tr>
<tr>
<td>NullPointerException</td>
<td>当应用程序试图访问空对象时，则抛出该异常</td>
</tr>
</tbody>
</table>
<p><strong>检查时异常（编译时异常）</strong></p>
<p>非 RuntimeException 及其子类的异常，都属于 Exception 及其子类。这类异常，是程序必须进行处理的异常，否则不能被编译，即需要显式处理</p>
<table>
<thead>
<tr>
<th>异常</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>SQLException</td>
<td>提供关于数据库访问错误或其他错误信息的异常</td>
</tr>
<tr>
<td>FileNotFoundException</td>
<td>当试图打开指定路径名表示的文件失败时，抛出此异常</td>
</tr>
<tr>
<td>IOException</td>
<td>当发生某种 I/O 异常时，抛出此异常。此类是失败或中断的 I/O 操作生成的异常的通用类</td>
</tr>
<tr>
<td>IllegalArgumentException</td>
<td>抛出的异常表明向方法传递了一个不合法或不正确的参数</td>
</tr>
<tr>
<td>ClassNotFoundExcepton</td>
<td>找不到具有指定名称的类的定义</td>
</tr>
</tbody>
</table>
<h2 id="throw-和-throws-的区别">throw 和 throws 的区别</h2>
<ol>
<li>throw：在方法体内部，表示抛出异常，由方法体内部的语句处理；throw 是具体向外抛出异常的动作，所以它抛出的是一个异常实例</li>
<li>throws：在方法声明后面，表示如果抛出异常，由该方法的调用者来进行异常的处理；表示出现异常的可能性，并不一定会发生这种异常</li>
</ol>
<h2 id="try-catch-finally">try-catch-finally</h2>
<h3 id="finally-代码块是否一定会执行？">finally 代码块是否一定会执行？</h3>
<p>当遇到下面情况不会执行：</p>
<ol>
<li>当程序在进入 try 语句块之前就出现异常时会直接结束</li>
<li>当程序在 try 块中强制退出时，如使用 System.exit(0)，也不会执行 finally 块中的代码</li>
</ol>
<p>注意：</p>
<ol>
<li>当有异常发生时，catch 和 finally 进行处理后程序就结束了；</li>
<li>当没有异常发生时，在执行完 finally 中的代码后，后面代码会继续执行；</li>
<li>当 try/catch 语句块中有 return 时，finally 语句块中的代码会在 return 之前执行；程序在执行到 return 时会首先将返回值存储在一个指定的位置，其次去执行 finally，最后在返回</li>
<li>当 try/catch/finally 块中都有 return 时，finally 块中的 return 语句会覆盖 try/catch 模块中的 return 语句。对基本数据类型，在 finally 块中改变 return 的值没有任何影响，直接覆盖掉；对引用类型有影响的，返回的是在 finally 对前面 return 语句返回对象的修改值</li>
</ol>
<h3 id="try-catch-finally-中哪个部分可以省略？">try-catch-finally 中哪个部分可以省略？</h3>
<p>可以的情况：</p>
<ol>
<li>try-catch</li>
<li>try-finally</li>
<li>try-catch-finally</li>
</ol>
<p>注意：可以省略 catch 或 finally，但是 catch 和 finally 不可以同时省略</p>
<h2 id="try-with-resources">try-with-resources</h2>
<ol>
<li>适用范围（资源的定义）：任何实现 java.lang.AutoCloseable 或者 java.io.Closeable 的对象</li>
<li>关闭资源和 finally 块的执行顺序：在 try-with-resources 语句中，任何 catch 或 finally 块在声明的资源关闭后运行</li>
</ol>
<p><strong>使用 try-catch-finally 需要手动关闭资源</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取文本文件的内容</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    scanner = <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D://read.txt&quot;</span>));</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (scanner != <span class="literal">null</span>) &#123;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用 Java7 之后的 try-with-resources 改造</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>))) &#123;</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException fnfe) &#123;</span><br><span class="line">    fnfe.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过使用分号分隔，可以在 try-with-resources 块中声明多个资源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">BufferedInputStream</span> <span class="variable">bin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>)));</span><br><span class="line">    <span class="type">BufferedOutputStream</span> <span class="variable">bout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;out.txt&quot;</span>)))) &#123;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="keyword">while</span> ((b = bin.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        bout.write(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他">其他</h2>
<h3 id="主线程可以捕获到子线程的异常吗？">主线程可以捕获到子线程的异常吗？</h3>
<ol>
<li>线程设计的理念：“线程的问题应该线程自己本身来解决，而不要委托到外部”</li>
<li>正常情况下，如果不做特殊的处理，在主线程中是不能够捕获到子线程中的异常的。如果想要在主线程中捕获子线程的异常，可以使用 Thread 的静态方法 <code>Thread.setDefaultUncaughtExceptionHandler(new MyUncaughtExceptionHandle());</code></li>
</ol>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>List（1-ArrayList）</title>
    <url>/blog/2024/12/09/%E5%BF%83%E5%BE%97/Java%E9%9B%86%E5%90%88/List%EF%BC%881-ArrayList%EF%BC%89/</url>
    <content><![CDATA[<h2 id="属性和接口">属性和接口</h2>
<ol>
<li>RandomAccess 是一个标志接口，表明实现这个接口的 List 集合是支持快速随机访问的。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问</li>
<li>ArrayList 实现了 Cloneable 接口，即覆盖了函数 clone()，能被克隆</li>
<li>ArrayList 实现了 Serializable 接口，这意味着 ArrayList 支持序列化，能通过序列化去传输</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt; </span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;</span><br><span class="line">    <span class="comment">// 默认初始容量大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空数组（用于空实例）。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于默认大小空实例的共享空数组实例。</span></span><br><span class="line">    <span class="comment">//我们把它从 EMPTY_ELEMENTDATA 数组中区分出来，以知道在添加第一个元素时容量需要增加多少。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存 ArrayList 数据的数组</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ArrayList 所包含的元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要分配的最大数组大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>RandomAccess 接口</strong></p>
<p>RandomAccess 接口中什么都没有定义，RandomAccess 接口不过是一个标识罢了，标识实现这个接口的类具有随机访问功能。在 binarySearch()方法中，它会判断传入的 list 是否 RandomAccess 的实例，如果是，调用 indexedBinarySearch()方法，如果不是，那么调用 iteratorBinarySearch()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(List&lt;? extends Comparable&lt;? <span class="built_in">super</span> T&gt;&gt; list, T key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)</span><br><span class="line">        <span class="keyword">return</span> Collections.indexedBinarySearch(list, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> Collections.iteratorBinarySearch(list, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">int</span> <span class="title function_">indexedBinarySearch</span><span class="params">(List&lt;? extends Comparable&lt;? <span class="built_in">super</span> T&gt;&gt; list, T key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> list.size()-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (low + high) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        Comparable&lt;? <span class="built_in">super</span> T&gt; midVal = list.get(mid);</span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> midVal.compareTo(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid; <span class="comment">// key found</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -(low + <span class="number">1</span>);  <span class="comment">// key not found</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">int</span> <span class="title function_">iteratorBinarySearch</span><span class="params">(List&lt;? extends Comparable&lt;? <span class="built_in">super</span> T&gt;&gt; list, T key)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> list.size()-<span class="number">1</span>;</span><br><span class="line">    ListIterator&lt;? <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> T&gt;&gt; i = list.listIterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (low + high) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        Comparable&lt;? <span class="built_in">super</span> T&gt; midVal = get(i, mid);</span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> midVal.compareTo(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid; <span class="comment">// key found</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -(low + <span class="number">1</span>);  <span class="comment">// key not found</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>为何 LinkedList 却没实现这个接口？</strong></p>
<p>ArrayList 用 for 循环遍历比 iterator 迭代器遍历快，LinkedList 用 iterator 迭代器遍历比 for 循环遍历快。做项目时，应该考虑到 List 集合的不同子类采用不同的遍历方式，能够提高性能</p>
<h2 id="构造方法">构造方法</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认构造函数，使用初始容量 10 构造一个空列表(无参数构造)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 带初始容量参数的构造函数。（用户自己指定容量）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建 initialCapacity 大小的数组</span></span><br><span class="line">        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建空数组</span></span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 初始容量小于 0，抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+ initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造包含指定 collection 元素的列表，这些元素利用该集合的迭代器按顺序返回</span></span><br><span class="line"><span class="comment"> * 如果指定的集合为 null，throws NullPointerException。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object [] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>当 ArrayList 的容量为 0 时，此时添加元素的话，需要扩容，三种构造方法创建的 ArrayList 在扩容时略有不同</li>
</ol>
<ul>
<li>无参构造，创建 ArrayList 后容量为 0，添加第一个元素后，容量变为 10，此后若需要扩容，则正常扩容</li>
<li>传容量构造，当参数为 0 时，创建 ArrayList 后容量为 0，添加第一个元素后，容量为 1，此时 ArrayList 是满的，下次添加元素时需正常扩容</li>
<li>传列表构造，当列表为空时，创建 ArrayList 后容量为 0，添加第一个元素后，容量为 1，此时 ArrayList 是满的，下次添加元素时需正常扩容</li>
</ul>
<ol start="2">
<li>当 ArrayList 的容量大于 0，并且 ArrayList 是满的，此时添加元素的话，进行正常扩容，每次扩容到原来的 1.5 倍</li>
</ol>
<h2 id="扩容机制">扩容机制</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 扩容的入口方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算最小容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">         <span class="comment">// 获取默认的容量和传入参数的较大值</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否需要扩容</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 调用 grow 方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容的核心方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// oldCapacity 为旧容量，newCapacity 为新容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="comment">// 将 oldCapacity 右移一位，其效果相当于 oldCapacity /2，</span></span><br><span class="line">    <span class="comment">// 位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的 1.5 倍，</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查新容量是否大于最小需要容量，若小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果新容量大于 MAX_ARRAY_SIZE, 进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span></span><br><span class="line">    <span class="comment">// 如果 minCapacity 大于最大容量，则新容量则为 `Integer.MAX_VALUE`，</span></span><br><span class="line">    <span class="comment">// 否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// 扩容</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">    <span class="comment">// 如果最小容量超过 MAX_ARRAY_SIZE，则将数组容量扩容至 Integer.MAX_VALUE</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE :MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 ArrayList 中，当空间用完，其会按照原数组空间的 1.5 倍进行扩容</p>
<ol>
<li>判断当前是否为空数组（即无参构造），如果是则比较 ArrayList 默认初始化的容量和传入参数大小，获取较大值（即扩容后的最小容量值）</li>
<li>判断最小容量值是否比原数组的元素个数大，是则进行扩容</li>
<li>使用位运算将原数组进行 1.5 倍扩容，然后判断扩容后的数量是否比最小容量值要小，是则将新数组的元素个数大小设置为最小容量值</li>
<li>如果新容量大于 Integer.MAX_VALUE - 8，则设置为 Integer.MAX_VALUE，否则为 Integer.MAX_VALUE - 8</li>
</ol>
<p><strong>为什么是 Integer.MAX_VALUE - 8？</strong></p>
<p>数组有点特殊性，数组对象要额外存储数组元素长度在头部，少了这 8 个长度可能与此有关。有些虚拟机会在数组中保存 header words 头部字，尝试分配大于 MAX_ARRAY_SIZE 长度的数组会导致 OOM （换句话说，超过了该虚拟机的数组长度限制）。</p>
<h2 id="插入">插入</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在元素序列尾部插入</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 检测是否需要扩容</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">// 2. 将新元素插入序列尾部</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在元素序列 index 位置处插入</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    <span class="comment">// 1. 检测是否需要扩容</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">// 2. 将 index 及其之后的所有元素都向后移一位</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);</span><br><span class="line">    <span class="comment">// 3. 将新元素插入至 index 处</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheckForAdd</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在尾部插入，只需 2 个步骤：</p>
<ol>
<li>检测数组是否有足够的空间插入</li>
<li>将新元素插入至序列尾部</li>
</ol>
<p>在元素序列指定位置（假设该位置合理）插入，需要 3 个步骤：</p>
<ol>
<li>检测数组是否有足够的空间</li>
<li>将 index 及其之后的所有元素向后一位</li>
<li>将新元素插入至 index 处</li>
</ol>
<h2 id="删除">删除</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除指定位置的元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 返回被删除的元素值</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 将 index + 1 及之后的元素向前移动一位，覆盖被删除值</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    <span class="comment">// 将最后一个元素置空，并将 size 值减 1                </span></span><br><span class="line">    elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">E <span class="title function_">elementData</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除指定元素，若元素重复，则只删除下标最小的元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历数组，查找要删除元素的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速删除，不做边界检查，也不返回删除的元素值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fastRemove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除一个元素步骤：</p>
<ol>
<li>获取指定位置 index 处的元素值</li>
<li>将 index+1 及之后的元素向前移动一位</li>
<li>将最后一个元素置空，并将 size 值减 1</li>
<li>返回被删除值，完成删除操作</li>
</ol>
<h3 id="使用注意">使用注意</h3>
<p>遍历集合删除时，不要在 foreach 循环里进行元素的 remove/add 操作，remove 元素请使用 Iterator 方法，如果是并发操作，需要对 Iterator 对象加锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">   list.add(<span class="string">&quot;add&quot;</span>);</span><br><span class="line">   list.add(<span class="string">&quot;delete&quot;</span>);</span><br><span class="line">   list.add(<span class="string">&quot;delete&quot;</span>);</span><br><span class="line">   list.add(<span class="string">&quot;update&quot;</span>);</span><br><span class="line">   list.add(<span class="string">&quot;query&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="fori-删除">fori 删除</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//顺序删除（会漏删）</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foriDelete</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;delete&quot;</span>.equals(list.get(i)))&#123;</span><br><span class="line">            list.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;顺序删除之后的结果为--&gt;&quot;</span>+list.toString());</span><br><span class="line">    <span class="comment">//顺序删除之后的结果为--&gt; [add, delete, update, query]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//倒序删除</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foriDelete</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> list.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;delete&quot;</span>.equals(list.get(i)))&#123;</span><br><span class="line">            list.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;倒序删除之后的结果为--&gt;&quot;</span>+list.toString());</span><br><span class="line">    <span class="comment">//倒序删除之后的结果为--&gt; [add, update, query]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ArrayList 在进行遍历的时候，如果删除某个元素，则后续的元素需要整体往前移动，当循环到 i = 1 的时候，找到了第 1 个 delete 字符串，然后删除，第 2 个 delete 以及之后的字符串会向前移动，这个时候第 2 个 delete 就在原数组的 1 位置了。当循环到 i = 2 的时候，正好把原来位置的 delete 给略过去了，导致漏删</p>
<h3 id="foreach-删除">foreach 删除</h3>
<p>删除一个元素后停止遍历可正常，多个元素删除有 CME 问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foreachDelete</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(String s:list)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.equals(<span class="string">&quot;delete&quot;</span>))&#123;</span><br><span class="line">            list.remove(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;foreach删除之后的结果为--&gt;&quot;</span>+list.toString());</span><br><span class="line">    <span class="comment">//删除出错：java.util.ConcurrentModificationException</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>foreach 的原理其实是编译器会将其编译为迭代器 Iterator 的形式进行遍历，以下是对.class 文件反编译之后的代码。与真正的使用迭代器遍历的方式有点不同，删除的时候不是使用迭代器的 remove 方法，而是用的 ArrayList 的 remove 方法。</p>
<p>产生异常的原因：ArrayList 本身不是线程安全的，在使用迭代器遍历查询的时候，会有一个检查机制，来确保一个线程在遍历的时候，其他线程不会删除该集合中的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foreachDelete</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">var1</span> <span class="operator">=</span> list.iterator();</span><br><span class="line">    <span class="keyword">while</span>(var1.hasNext()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String)var1.next();</span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">&quot;delete&quot;</span>)) &#123;</span><br><span class="line">            list.remove(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 并发修改检测，检测不通过则抛出异常</span></span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        cursor = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**确保 List 在同一时刻不会有多个线程进行删除**/</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 foreach 方式删除元素的时候，调用 ArrayList 的 remove 方法如下：</p>
<p>当在第一次找到 delete 字符串，并进行删除的时候，会对 modCount++。如果没有停止该遍历，则在下次循环的时候，会校验 modCount 与 expectedModCount 是否相等。若不等，则抛出并发修改异常。foreach 循环删除元素是可以的，但是只能删除一个元素，并立即停止遍历，在 remove 下加上 break 即可</p>
<h3 id="iterator-删除">iterator 删除</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">iteratorDelete</span><span class="params">()</span>&#123;</span><br><span class="line">    Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> it.next();</span><br><span class="line">        <span class="keyword">if</span>(x.equals(<span class="string">&quot;delete&quot;</span>))&#123;</span><br><span class="line">            it.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;iterator删除之后的结果为--&gt;&quot;</span>+list.toString());</span><br><span class="line">    <span class="comment">//iterator 删除之后的结果为--&gt; [add, update, query]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可正常删除，ArrayList 在使用迭代器 Iterator 进行删除的时候，逻辑如下：在进行删除的时候，会将 modCount 赋值给 expectedModCount，所以不会导致两者不相等，只要不是数组越界，就不会报出 ConcurrentModificationException 了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">    checkForComodification();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ArrayList.<span class="built_in">this</span>.remove(lastRet);</span><br><span class="line">        cursor = lastRet;</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他">其他</h2>
<h3 id="trimToSize">trimToSize</h3>
<p>底层的 Object 数组是有一个最大容量的，假如容量为 10，但是只存放了 3 个元素，调用 trimToSize 就会将数组压缩为一个容量为 3 的新数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将数组容量缩小至元素数量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trimToSize</span><span class="params">()</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">        elementData = (size == <span class="number">0</span>) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ensureCapacity">ensureCapacity</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由 minimum capacity 参数指定的元素数。</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>   minCapacity   所需的最小容量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minExpand</span> <span class="operator">=</span> (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) ? <span class="number">0</span> : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最好在 add 大量元素之前用 ensureCapacity 方法，以减少扩容机制增量重新分配的次数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnsureCapacityTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">10000000</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//list.ensureCapacity(N);</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;使用ensureCapacity方法前：&quot;</span>+(endTime - startTime));</span><br><span class="line">        <span class="comment">//System.out.println(&quot;使用 ensureCapacity 方法后：&quot;+(endTime1 - startTime1));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// 使用 ensureCapacity 方法前：2158</span></span><br><span class="line"><span class="comment">// 使用 ensureCapacity 方法后：1773</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>List（2-LinkedList）</title>
    <url>/blog/2024/12/10/%E5%BF%83%E5%BE%97/Java%E9%9B%86%E5%90%88/List%EF%BC%882-LinkedList%EF%BC%89/</url>
    <content><![CDATA[<h2 id="属性和接口">属性和接口</h2>
<p>LinkedList 是双向链表，可通过头和尾节点遍历查询指定的数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSequentialList</span>&lt;E&gt; </span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//表示链表的长度</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//链表的第一个节点</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line">    <span class="comment">//链表的最后一个节点</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">        <span class="comment">//数据域</span></span><br><span class="line">        E item;</span><br><span class="line">        <span class="comment">//指向下一个节点</span></span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        <span class="comment">//指向上一个节点</span></span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造方法</span></span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            <span class="built_in">this</span>.item = element;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">            <span class="built_in">this</span>.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="构造方法">构造方法</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传入集合时，会调用 addAll 方法初始化链表信息</p>
<h2 id="插入">插入</h2>
<ol>
<li>从头部或尾部插入元素</li>
</ol>
<p><img src="1.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从链表尾部插入元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">//e 的前驱节点为 l，后继节点为 null</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">//如果头节点为 null，则设置为新节点</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从链表头部插入元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    linkFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">linkFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(<span class="literal">null</span>, e, f);</span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">null</span>)</span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        f.prev = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从链表尾部插入元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>从指定位置插入元素</li>
</ol>
<p><img src="2.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    <span class="comment">//判断 index 下标是否越界</span></span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断插入的位置</span></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkPositionIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isPositionIndex(index))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isPositionIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> &#123;</span><br><span class="line">    <span class="comment">//找到 succ 的上一个节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="comment">//新节点插入到前继节点 pred, 后继节点 succ 之间</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(pred, e, succ);</span><br><span class="line">    <span class="comment">//后继节点的 prev 指向新节点</span></span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="comment">//前继节点 pred 为空，则新节点作为首节点 first，否则把前一个节点的 next 指向新节点</span></span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="literal">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node&lt;E&gt; <span class="title function_">node</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">//如果 index &lt; size/2，从前半部分找</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查找">查找</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">//判断 index 下标是否越界</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkElementIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isElementIndex(index))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isElementIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt; size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除">删除</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">//判断 index 下标是否越界</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">E <span class="title function_">unlink</span><span class="params">(Node&lt;E&gt; x)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//prev 为空，说明移除的节点是头节点</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//next 为空，说明移除的节点是尾结点</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item = <span class="literal">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>List（3-CopyOnWriteArrayList）</title>
    <url>/blog/2024/12/11/%E5%BF%83%E5%BE%97/Java%E9%9B%86%E5%90%88/List%EF%BC%883-CopyOnWriteArrayList%EF%BC%89/</url>
    <content><![CDATA[<h2 id="实现原理">实现原理</h2>
<p>CopyOnWriteArrayList 允许线程并发访问读操作，这个时候是没有加锁限制的，性能较高。而写操作的时候，则首先将容器复制一份，然后再新的副本上执行写操作，这个时候写操作是上锁的，结束之后再将原容器的引用指向新容器。</p>
<p>注意：在上锁执行写操作的过程中，如果有需要读操作，会作用在原容器上。因此上锁的写操作不会影响到并发访问的读操作</p>
<h2 id="属性和接口">属性和接口</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    <span class="comment">//互斥锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">transient</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//底层存储数据数组，只能通过 getArray/setArray 访问设置，volatile 动态数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setArray</span><span class="params">(Object[] a)</span> &#123;</span><br><span class="line">        array = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="构造方法">构造方法</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CopyOnWriteArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    setArray(<span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入 Collection 集合对象，将集合中元素存入 CopyOnWriteArrayList</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CopyOnWriteArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    Object[] elements;</span><br><span class="line">    <span class="keyword">if</span> (c.getClass() == CopyOnWriteArrayList.class)</span><br><span class="line">        elements = ((CopyOnWriteArrayList&lt;?&gt;)c).getArray();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        elements = c.toArray();</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object [] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elements.getClass() != Object[].class)</span><br><span class="line">            elements = Arrays.copyOf(elements, elements.length, Object[].class);</span><br><span class="line">    &#125;</span><br><span class="line">    setArray(elements);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CopyOnWriteArrayList</span><span class="params">(E[] toCopyIn)</span> &#123;</span><br><span class="line">    setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入">插入</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">//获得互斥锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取原始数组</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">//用新的拷贝数组代替原始数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    <span class="comment">//互斥锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//原始数组</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">        <span class="comment">//检查 index 有效性</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt; len || index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;Index: &quot;</span>+index+<span class="string">&quot;, Size: &quot;</span>+len);</span><br><span class="line">        <span class="comment">//拷贝数组</span></span><br><span class="line">        Object[] newElements;</span><br><span class="line">        <span class="comment">//从 index 到数组末尾要向后移动一位数组元素的个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> len - index;</span><br><span class="line">        <span class="comment">//如果 index == length，直接把原数组复制到新数组</span></span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">            newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//否则分成两段复制，原始数组 index 前面的元素位置一一对应赋值到新数组，原数组 index 开始的元素复制到</span></span><br><span class="line">        <span class="comment">//新数组 index+1 到 length+1，相当于依次后移。空出来的 index 就是新元素插入的位置</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            newElements = <span class="keyword">new</span> <span class="title class_">Object</span>[len + <span class="number">1</span>];</span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">            System.arraycopy(elements, index, newElements, index + <span class="number">1</span>, numMoved);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//插入新元素</span></span><br><span class="line">        newElements[index] = element;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>在写入过程中使用了互斥锁，所以同一时间只有一个线程在修改 CopyOnWriteArrayList</li>
<li>增加元素并不是直接在原数组操作，而是在原数组的拷贝数组上添加元素的，添加完元素再调用 setArray 方法用新数组代替原始数组</li>
</ol>
<h2 id="删除">删除</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据下标删除元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">        <span class="comment">//数组 index 处要移除的元素</span></span><br><span class="line">        <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> get(elements, index);</span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> len - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">            setArray(Arrays.copyOf(elements, len - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Object[] newElements = <span class="keyword">new</span> <span class="title class_">Object</span>[len - <span class="number">1</span>];</span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">            System.arraycopy(elements, index + <span class="number">1</span>, newElements, index, numMoved);</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据元素删除</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    Object[] snapshot = getArray();</span><br><span class="line">    <span class="comment">//查找指定元素下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> indexOf(o, snapshot, <span class="number">0</span>, snapshot.length);</span><br><span class="line">    <span class="keyword">return</span> (index &lt; <span class="number">0</span>) ? <span class="literal">false</span> : remove(o, snapshot, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o, Object[] elements, <span class="type">int</span> index, <span class="type">int</span> fence)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; fence; i++)</span><br><span class="line">            <span class="keyword">if</span> (elements[i] == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; fence; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elements[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o, Object[] snapshot, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] current = getArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> current.length;</span><br><span class="line">        <span class="comment">//判断当前数组元素是否相同，如果不相同则重新查找元素的下标</span></span><br><span class="line">        <span class="keyword">if</span> (snapshot != current) findIndex: &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">prefix</span> <span class="operator">=</span> Math.min(index, len);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prefix; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (current[i] != snapshot[i] &amp;&amp; eq(o, current[i])) &#123;</span><br><span class="line">                    index = i;</span><br><span class="line">                    <span class="keyword">break</span> findIndex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index &gt;= len)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (current[index] == o)</span><br><span class="line">                <span class="keyword">break</span> findIndex;</span><br><span class="line">            index = indexOf(o, current, index, len);</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Object[] newElements = <span class="keyword">new</span> <span class="title class_">Object</span>[len - <span class="number">1</span>];</span><br><span class="line">        System.arraycopy(current, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">        System.arraycopy(current, index + <span class="number">1</span>, newElements, index, len - index - <span class="number">1</span>);</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据指定范围删除删除</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">removeRange</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span> || toIndex &gt; len || toIndex &lt; fromIndex)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">newlen</span> <span class="operator">=</span> len - (toIndex - fromIndex);</span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> len - toIndex;</span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">            setArray(Arrays.copyOf(elements, newlen));</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Object[] newElements = <span class="keyword">new</span> <span class="title class_">Object</span>[newlen];</span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, fromIndex);</span><br><span class="line">            System.arraycopy(elements, toIndex, newElements, fromIndex, numMoved);</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：根据元素进行删除时，第一次获取元素下标后，拿到锁后会重新判断元素的下标（防止此时数组元素的顺序被修改而删错其他元素）</p>
<h2 id="查找">查找</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">private</span> E <span class="title function_">get</span><span class="params">(Object[] a, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">//返回数组 index 处位置</span></span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="优缺点">优缺点</h2>
<ol>
<li>优点：读操作性能很高，因为无需任何同步措施，比较适用于读多写少的并发场景。在遍历传统的 List 时，若中途有别的线程对其进行修改，则会抛出 ConcurrentModificationException 异常。而 CopyOnWriteArrayList 由于其“读写分离”的思想，遍历和修改操作分别作用在不同的 List 容器，所以在使用迭代器进行遍历时候，也就不会抛出 ConcurrentModificationException 异常</li>
<li>缺点：一是内存占用问题，每次执行写操作都要将原容器拷贝一份，数据量大时，对内存压力较大，可能会引起频繁 GC。二是无法保证实时性，Vector 对于读写操作均加锁操作，可以保证读和写的一致性。而 CopyOnWriteArrayList 由于其实现策略的原因，写和读分别作用在新老不同容器上，在写操作执行过程中，读不会阻塞但读取到的却是老容器的数据</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Map（1-HashMap）</title>
    <url>/blog/2025/01/20/%E5%BF%83%E5%BE%97/Java%E9%9B%86%E5%90%88/Map%EF%BC%881-HashMap%EF%BC%89/</url>
    <content><![CDATA[<h2 id="底层原理">底层原理</h2>
<h3 id="实现方式">实现方式</h3>
<ol>
<li>JDK1.7：Entry 数组+链表</li>
<li>JDK1.8：Node 数组+链表/红黑树，当链表上的元素个数超过 8 个并且数组长度 &gt;= 64 时自动转化为红黑树，节点变成树节点。Entry 和 Node 都包含 key、value、hash、next 属性</li>
</ol>
<p><img src="1.png" alt=""></p>
<h3 id="JDK7-与-JDK8-区别">JDK7 与 JDK8 区别</h3>
<ol>
<li>
<p>JDK8 中添加了红黑树，当链表长度 &gt;= 8 且数组长度 &gt;= 64 的时候链表会变成红黑树</p>
</li>
<li>
<p>链表新节点插入链表的顺序不同（JDK7 是插入头结点，多线程进行扩容时会出现死循环，JDK8 因为要把链表变成红黑树所以采用插入尾结点，不会死循环）</p>
</li>
</ol>
<ul>
<li>假设在下标为 1 处有一个长度为 2 的链表，如果再次插入一个节点，就需要 resize()扩容。</li>
</ul>
<p><img src="6.png" alt=""></p>
<ul>
<li>此时两个线程 A 和 B 执行 put()操作，A 线程先执行，执行完 transfer () 中的 Entry &lt;K,V&gt; next = e.next 被挂起，此时 e 指针指向 5，next 指向 7，如图所示。</li>
</ul>
<p><img src="7.png" alt=""></p>
<ul>
<li>此时线程 B 执行，将数组扩大两倍，链表仍散列在下标为 1 处，由于使用了头插法，节点位置将会交换，如图所示。</li>
</ul>
<p><img src="8.png" alt=""></p>
<ul>
<li>这时候线程 A 又执行，因为原先 e 指向 5，next 执行 7，继续执行下一条语句 e.next = newTable [i]，这时会出现 5 指向 7 的情况，如图所示。</li>
</ul>
<p><img src="9.png" alt=""></p>
<ol start="3">
<li>hash 算法简化（JDK8）</li>
</ol>
<ul>
<li>JDK1.7 的 HashMap 的 hash 方法源码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">int</span> h)</span> &#123;</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>JDK1.8 的 HashMap 的 hash 方法源码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算键的 hash 值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JDK7 中因为要让链表不要过长，所以进行了多次的异或和位运算，JDK8 中因为链表长度超过等于 8 会转红黑树，所以可以稍微减少元素的散列性，从而避免很多异或和位运算操作</p>
<ol start="4">
<li>resize 扩容机制的逻辑修改</li>
</ol>
<p>在扩容之前，key 取余之后留下了 n 位。扩容之后，容量变为 2 倍，所以 key 取余得到的就有 n+1 位。</p>
<p>在这 n+1 位里面，如果第 1 位是 0，那么扩容前后这个 key 的位置还是在相同的位置（因为 hash 相同，并且余数的第 1 位是 0，和之前 n 位的时候一样，所以余数还是一样，位置就一样了）；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">loTail.next = <span class="literal">null</span>;</span><br><span class="line">newTab[j] = loHead;</span><br></pre></td></tr></table></figure>
<p>如果这 n+1 位的第一位是 1，那么就和之前的不同，那么这个 key 就应该放在之前的位置再加上之前整个数组的长度的位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hiTail.next = <span class="literal">null</span>;</span><br><span class="line">newTab[j + oldCap] = hiHead;</span><br></pre></td></tr></table></figure>
<h2 id="属性和接口">属性和接口</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line">    <span class="comment">// HashMap 默认的初始容量是 16</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 最大容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// 默认的填充因子</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数小于这个值时树转链表</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 桶中结构转化为红黑树对应的 table 的最小容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line">    <span class="comment">// 存储元素的数组，总是 2 的幂次倍</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;k,v&gt;[] table;</span><br><span class="line">    <span class="comment">// 存放具体元素的集</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;</span><br><span class="line">    <span class="comment">// 存放元素的个数，注意这个不等于数组的长度。</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">// 每次扩容和更改 map 结构的计数器</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line">    <span class="comment">// 当前 HashMap 所能容纳键值对数量的最大值(容量*填充因子)，超过这个值，则需扩容</span></span><br><span class="line">    <span class="type">int</span> threshold;</span><br><span class="line">    <span class="comment">// 加载因子</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="构造方法">构造方法</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> + loadFactor);</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>HashMap 的负载因子（loadFactor）为何默认是 0.75？</strong></p>
<ol>
<li>当负载因子是 1.0 时，意味着只有当数组的所有值全部填充了，才会发生扩容，此时会出现大量的 hash 冲突，底层的红黑树变得异常复杂，对于查询效率极其不利</li>
<li>当负载因子是 0.5 时，意味着当数组中的元素达到了一半就开始扩容，填充的元素少了，hash 冲突也会减少，那么底层的链表长度或者是红黑树的高度就会降低，查询效率就会增加。此时空间利用率就会大大地降低，原本存储 1M 的数据，现在意味着需要 2M 的空间</li>
<li>当负载因子是 0.75 时，空间利用率比较高，而且避免了相当多的 hash 冲突，使得底层链表或者是红黑树的高度比较低，提升了空间效率</li>
</ol>
<h2 id="查找">查找</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">    <span class="comment">// 1. 定位键值对所在桶的位置</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// 1. 检查第一个节点</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 2. 如果 first 是 TreeNode 类型，则调用黑红树查找方法</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// 3. 如果 first 不是 TreeNode 类型，对链表进行查找</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>判断数组是否为空且长度是否为 0，定位键值所在桶的位置</li>
<li>检查第一个节点，如果相等就直接返回，不相等则执行下面的操作</li>
<li>如果 first 是 TreeNode 类型，则调用红黑树查找方法，否则对链表进行查找</li>
</ol>
<p><strong>位运算取模</strong></p>
<p><code>first = tab [(n-1)&amp;hash]</code>：算出桶在桶数组中的位置，length 总是 2 的幂，等价于对 length 取余，使用%没有位运算效率高</p>
<p><img src="12.png" alt=""></p>
<h2 id="插入">插入</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// 初始化桶数组 table，table 被延迟到插入新数据时再进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 如果桶中不包含键值对节点引用，则将新键值对节点的引用存入桶中即可</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 如果键的值以及节点 hash 等于链表中的第一个键值对节点时，则将 e 指向该键值对</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 如果桶中的引用类型为 TreeNode，则调用红黑树的插入方法</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)  </span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 对链表进行遍历，并统计链表长度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 链表中不包含要插入的键值对节点时，则将该节点接在链表的最后</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 如果链表长度大于或等于树化阈值，则进行树化操作</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 条件为 true，表示当前链表包含要插入的键值对，终止遍历</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断要插入的键值对是否存在 HashMap 中</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="comment">// onlyIfAbsent 表示是否仅在 oldValue 为 null 的情况下更新键值对的值</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 键值对数量超过阈值时，则进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>首次扩容：先判断数组是否为空，若数组为空则进行第一次扩容</li>
<li>计算索引：通过 hash 算法，计算键值对在数组中的索引</li>
<li>插入数据</li>
</ol>
<ul>
<li>如果当前位置元素为空，则直接插入数据</li>
<li>如果当前位置元素非空，且 key 已存在，则直接覆盖其 value</li>
<li>如果当前位置元素非空，且 key 不存在，则将数据链到链表末端</li>
<li>若链表长度 &gt;= 8 且数组长度 &gt;= 64，则将链表转换成红黑树，并将数据插入树中</li>
</ul>
<ol start="4">
<li>再次扩容：如果数组中元素个数超过阈值，则再次进行扩容操作</li>
</ol>
<p><img src="13.png" alt=""></p>
<h2 id="扩容机制">扩容机制</h2>
<h3 id="哈希表计算">哈希表计算</h3>
<p>下面这个方法保证了 HashMap 总是使用 2 的幂作为哈希表的大小</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 找到大于或等于 cap 的最小 2 的幂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="10.png" alt=""></p>
<h3 id="扩容方法">扩容方法</h3>
<ol>
<li>在 HashMap 中，桶数组的长度均是 2 的幂，阈值大小为桶数组长度与负载因子的乘积（threshold = capacity*loadFactor ），当 HashMap 中的键值对数量超过阈值时，进行扩容</li>
<li>HashMap 按当前桶数组长度的 2 倍进行扩容，阈值也变为原来的 2 倍（如果计算过程中，阈值溢出归零，则按阈值公式重新计算）。扩容之后，要重新计算键值对的位置，并把它们移动到合适的位置上去</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果 table 不为空，表明已经初始化过了</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当 table 容量超过容量最大值，则不再扩容</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 按旧容量和阈值的 2 倍计算新容量和阈值的大小</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 调用 HashMap(int)和 HashMap(int, float)构造方法时会产生这种情况</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 初始化时，将 threshold 的值赋值给 newCap，</span></span><br><span class="line"><span class="comment">         * HashMap 使用 threshold 变量暂时保存 initialCapacity 参数的值</span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               </span><br><span class="line">        <span class="comment">// 调用 HashMap()构造方法会产生这种情况</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 调用无参构造方法时，桶数组容量为默认容量，阈值为默认容量与默认负载因子乘积</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 特殊处理：第一个条件分支未计算 newThr 或嵌套分支在计算过程中导致 newThr 溢出归零</span></span><br><span class="line">    <span class="comment">// newThr 为 0 时，按阈值计算公式进行计算</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="comment">// 创建新的桶数组，桶数组的初始化也是在这里完成的</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果旧的桶数组不为空，则遍历桶数组，并将键值对映射到新的桶数组中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// 重新映射时，需要对红黑树进行拆分</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="comment">// 遍历链表，并将链表节点按原顺序进行分组</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 将分组后的链表映射到新桶中</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>扩容逻辑</strong></p>
<ol>
<li>计算新桶数组的容量 newCap 和新阈值 newThr</li>
<li>根据计算出的 newCap 创建新的桶数组，桶数组 table 也是在这里进行初始化的</li>
<li>将键值对节点重新映射到新的桶数组里，如果节点是 TreeNode 类型，则需要拆分红黑树；如果是普通节点，则节点按原顺序进行分组</li>
</ol>
<p><strong>注意</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 当 table 容量超过容量最大值，则不再扩容</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span> oldTab;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 按旧容量和阈值的 2 倍计算新容量和阈值的大小</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">             oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">        newThr = oldThr &lt;&lt; <span class="number">1</span>; </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 调用 HashMap(int)和 HashMap(int, float)构造方法时会产生这种情况</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 初始化时，将 threshold 的值赋值给 newCap，</span></span><br><span class="line"><span class="comment">     * HashMap 使用 threshold 变量暂时保存 initialCapacity 参数的值</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    newCap = oldThr;</span><br><span class="line"><span class="keyword">else</span> &#123;               </span><br><span class="line">    <span class="comment">// 调用 HashMap()构造方法会产生这种情况</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 调用无参构造方法时，桶数组容量为默认容量，阈值为默认容量与默认负载因子乘积</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">    newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新阈值 newThr = oldThr &lt;&lt; 1，移位可能会导致溢出</p>
<p>移位导致的溢出情况：当 loadFactor 小数位为 0，整数位可被 2 整除且大于等于 8 时，在某次计算中就可能导致 newThr 溢出归零</p>
<p><img src="11.png" alt=""></p>
<h2 id="删除">删除</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">   Node&lt;K,V&gt; e;</span><br><span class="line">   <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object key, Object value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="literal">true</span>, <span class="literal">true</span>) != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value,</span></span><br><span class="line"><span class="params">                            <span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, index;</span><br><span class="line">    <span class="comment">//当 table 不为空，并且 hash 对应的桶不为空时</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="literal">null</span>, e; K k; V v;</span><br><span class="line">        <span class="comment">//桶中的头节点就是我们要删除的节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">//用 node 记录要删除的头节点</span></span><br><span class="line">            node = p;</span><br><span class="line">        <span class="comment">//头节点不是要删除的节点，并且头节点之后还有节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//头节点为树节点，则进入树查找要删除的节点</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">//头节点为链表节点</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//遍历链表</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="comment">//hash 值相等，并且 key 地址相等或者 equals</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                         <span class="comment">//node 记录要删除的节点</span></span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//p 保存当前遍历到的节点</span></span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//我们要找的节点不为空</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">//在树中删除节点</span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="built_in">this</span>, tab, movable);</span><br><span class="line">            <span class="comment">//我们要删除的是头节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="comment">//不是头节点，将当前节点指向删除节点的下一个节点</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他">其他</h2>
<h3 id="get-能否判断元素是否在-map-中？">get 能否判断元素是否在 map 中？</h3>
<p>HashMap 的 get 函数的返回值不能判断一个 key 是否包含在 map 中，因为 HashMap 中允许 key 为 null，也允许 value 为 null</p>
<h3 id="为什么用红黑树而不用-B-树？">为什么用红黑树而不用 B 树？</h3>
<p>HashMap 本来是数组+链表的形式，链表由于其查找慢的特点，所以需要被查找效率更高的树结构来替换。如果使用 B/B+树的话，在数据量不是很多的情况下，数据都会“挤在”一个结点里面，这个时候遍历效率就退化成了链表</p>
<h3 id="什么时候转为红黑树？">什么时候转为红黑树？</h3>
<ol>
<li>在链表长度大于 8 并且表的长度大于 64 的时候会转化红黑树</li>
<li>如果当前链表长度大于 8 但表的长度小于 64 时，会先进行扩容</li>
</ol>
<p>binCount 从 0 开始计算，大于等于 7 则触发 treeifyBin（树化方法）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 并且如果 链表的长度 大于 8 会尝试调用  treeifyBin 方法</span></span><br><span class="line">    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">        treeifyBin(tab, hash);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 如果表的长度小于 64 会先扩容！！！ 否则 扩容</span></span><br><span class="line">    <span class="comment">// MIN_TREEIFY_CAPACITY = 64;</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>为什么是链表长度为 8？</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* <span class="number">0</span>:    <span class="number">0.60653066</span></span><br><span class="line">* <span class="number">1</span>:    <span class="number">0.30326533</span></span><br><span class="line">* <span class="number">2</span>:    <span class="number">0.07581633</span></span><br><span class="line">* <span class="number">3</span>:    <span class="number">0.01263606</span></span><br><span class="line">* <span class="number">4</span>:    <span class="number">0.00157952</span></span><br><span class="line">* <span class="number">5</span>:    <span class="number">0.00015795</span></span><br><span class="line">* <span class="number">6</span>:    <span class="number">0.00001316</span></span><br><span class="line">* <span class="number">7</span>:    <span class="number">0.00000094</span></span><br><span class="line">* <span class="number">8</span>:    <span class="number">0.00000006</span></span><br><span class="line">* more: less than <span class="number">1</span> in ten million</span><br></pre></td></tr></table></figure>
<p>当 hashCode 离散性很好的时候，树形 bin 用到的概率非常小，因为数据均匀分布在每个 bin 中，几乎不会有 bin 中链表长度会达到阈值，在理想情况下随机 hashCode 算法下所有 bin 节点的分布频率会遵循泊松分布，一个 bin 中链表长度达到 8 个元素的概率为 0.00000006，几乎是不可能事件</p>
<p>但是在随机 hashCode 下，离散性可能会变差，JDK 又不能阻止用户实现这种不好的 hash 算法，因此就可能导致不均匀的数据分布。链表长度超过 8 转为红黑树的设计，更多的是为了防止用户自己实现了不好的哈希算法时而导致链表过长，从而导致查询效率低</p>
<p><strong>为什么要数组长度大于等于 64？</strong></p>
<ol>
<li>避免频繁地树化</li>
<li>减少内存占用</li>
</ol>
<p>在数组比较小时如果出现红黑树结构，反而会降低效率，而红黑树需要进行左旋右旋、变色这些操作来保持平衡，同时数组长度小于 64 时，搜索时间相对要快些，总之是为了加快搜索速度，提高性能</p>
<p>红黑树相比链表需要更多的内存，尤其是在节点较少的情况下，红黑树的额外指针和结构占用更大。为了节省内存，HashMap 选择只有在数组容量达到一定规模后才树化，防止红黑树在小规模数据中带来额外的内存负担。</p>
<p><strong>转换为红黑树的操作</strong></p>
<p>先比较 key 的 hash 值决定插入方向，如果 hash 值相等的话，再比较 compare 方法，如果 key 所属对象没有直接实现 Comparable 接口，或者 compare 方法返回 0，执行 tieBreakOrder，比较两个 key 所属 Class 的 name，如果还相等，即两个对象是同一个类型，那么调用本地方法为两个对象生成 hashCode，再进行比较，hashCode 相等的话返回-1</p>
<h3 id="什么时候转为链表？">什么时候转为链表？</h3>
<p>若桶中元素小于等于 6 时，树结构还原成链表形式。红黑树的平均查找长度是 log(n)，长度为 8，查找长度为 log(8)= 3；链表的平均查找长度为 n/2，当长度为 8 时，平均查找长度为 8/2 = 4，这才有转换成树的必要</p>
<p><strong>选择 6 和 8 的原因</strong></p>
<p>中间有个差值 7 可以防止链表和树之间频繁的转换。如果涉及成链表个数超过 8 则链表转换为树结构，链表个数小于 8 则树结构转换成链表，如果一个 hashMap 不停的插入、删除元素，链表个数在 8 左右徘徊，就会频繁地发生树转链表、链表转树，效率很低</p>
<h3 id="线程不安全">线程不安全</h3>
<ol>
<li>put 数据覆盖：多线程同时执行 put 操作，如果计算出来的索引位置是相同的，那会造成前一个 key 被后一个 key 覆盖，从而导致元素的丢失。此问题在 JDK1.7 和 JDK1.8 中都存在</li>
<li>put 和 get 并发时，可能导致 get 为 null：线程 1 进行 put 时，因为元素个数超出 threshold 而导致扩容（new 一个新的 hash 表），线程 2 此时 get，有可能导致读出为 null（新 hash 表还没有值）。此问题在 JDK1.7 和 JDK1.8 中都存在</li>
<li>扩容死循环：JDK1.7 中的 HashMap 使用头插法插入元素，在多线程的环境下，扩容的时候有可能导致环形链表的出现，形成死循环。因此 JDK1.8 使用尾插法插入元素，在扩容时会保持链表元素原本的顺序，不会出现环形链表的问题</li>
</ol>
<h3 id="遍历">遍历</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span> &#123;</span><br><span class="line">    Set&lt;K&gt; ks = keySet;</span><br><span class="line">    <span class="keyword">if</span> (ks == <span class="literal">null</span>) &#123;</span><br><span class="line">        ks = <span class="keyword">new</span> <span class="title class_">KeySet</span>();</span><br><span class="line">        keySet = ks;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 键集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">KeySet</span> <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;K&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>                 &#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>               &#123; HashMap.<span class="built_in">this</span>.clear(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;K&gt; <span class="title function_">iterator</span><span class="params">()</span>     &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">KeyIterator</span>(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123; <span class="keyword">return</span> containsKey(o); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 键迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">KeyIterator</span> <span class="keyword">extends</span> <span class="title class_">HashIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;K&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">next</span><span class="params">()</span> &#123; <span class="keyword">return</span> nextNode().key; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">HashIterator</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; next;        <span class="comment">// next entry to return</span></span><br><span class="line">    Node&lt;K,V&gt; current;     <span class="comment">// current entry</span></span><br><span class="line">    <span class="type">int</span> expectedModCount;  <span class="comment">// for fast-fail</span></span><br><span class="line">    <span class="type">int</span> index;             <span class="comment">// current slot</span></span><br><span class="line"></span><br><span class="line">    HashIterator() &#123;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">        Node&lt;K,V&gt;[] t = table;</span><br><span class="line">        current = next = <span class="literal">null</span>;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry </span></span><br><span class="line">            <span class="comment">// 寻找第一个包含链表节点引用的桶</span></span><br><span class="line">            <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> next != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">nextNode</span><span class="params">()</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] t;</span><br><span class="line">        Node&lt;K,V&gt; e = next;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        <span class="keyword">if</span> ((next = (current = e).next) == <span class="literal">null</span> &amp;&amp; (t = table) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 寻找下一个包含链表节点引用的桶</span></span><br><span class="line">            <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">    map.put(i, i);</span><br><span class="line">&#125;</span><br><span class="line">Set&lt;Integer&gt; keySet = map.keySet();</span><br><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (Integer i : keySet) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> map.get(i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(System.currentTimeMillis() - start);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Iterator&lt;Integer&gt; iterator = map.keySet().iterator();</span><br><span class="line">start = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(System.currentTimeMillis() - start);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Set&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = map.entrySet();</span><br><span class="line">start = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : entries) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(System.currentTimeMillis() - start);</span><br></pre></td></tr></table></figure>
<p>keySet 和 entrySet 的区别：</p>
<ol>
<li>keySet：返回的是只存放 key 值的 Set 集合，使用迭代器方式遍历 Set 集合，使用 get 方法获取键对应的值时就需要遍历 Map 集合</li>
<li>entrySet：返回的是存放了映射关系的 Set 集合（一个映射关系就是一个键-值对），即把 key-value 作为一个整体一对一地存放到 Set 集合当中，然后使用迭代器方式遍历该 Set 集合就可以取出 Map 中存放的键值对</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Map（2-Hashtable）</title>
    <url>/blog/2025/01/23/%E5%BF%83%E5%BE%97/Java%E9%9B%86%E5%90%88/Map%EF%BC%882-Hashtable%EF%BC%89/</url>
    <content><![CDATA[<h2 id="属性和接口">属性和接口</h2>
<p>底层是基于数组+链表实现的，无序，且键和值都不允许为 null，Hashtable 是线程安全的（基于 synchronized 实现）</p>
<p><img src="1.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hashtable</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Dictionary</span>&lt;K,V&gt; </span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    <span class="comment">//存储键值对Entry的哈希桶数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;?,?&gt;[] table;</span><br><span class="line">    <span class="comment">//哈希桶数组table中存放的键值对Entry数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="comment">//哈希桶数组table扩容阈值，threshold=capacity(数组容量) * loadFactor(加载因子)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> threshold;</span><br><span class="line">    <span class="comment">//加载因子</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> loadFactor;</span><br><span class="line">    <span class="comment">//Hashtable结构性修改次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">modCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Entry&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="title function_">Entry</span><span class="params">(<span class="type">int</span> hash, K key, V value, Entry&lt;K,V&gt; next)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.hash = hash;</span><br><span class="line">            <span class="built_in">this</span>.key =  key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="构造方法">构造方法</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Hashtable</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="number">11</span>, <span class="number">0.75f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Hashtable</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, <span class="number">0.75f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Hashtable</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="comment">//如果自定义初始容量小于0，则抛IllegalArgumentException</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+ initialCapacity);</span><br><span class="line">                                           </span><br><span class="line">    <span class="comment">//如果自定义的加载因子小于0或者为非数值类型，则抛IllegalArgumentException</span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Load: &quot;</span>+loadFactor);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果自定义初始容量等于0，则使用1作为Hashtable的初始容量</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity==<span class="number">0</span>)</span><br><span class="line">        initialCapacity = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">//新建一个指定容量的Entry数组</span></span><br><span class="line">    table = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;?,?&gt;[initialCapacity];</span><br><span class="line">    <span class="comment">//计算扩容阈值</span></span><br><span class="line">    threshold = (<span class="type">int</span>)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入">插入</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="comment">//判断value是否为null，确保不存在null值</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确定该键是否存在于哈希桶数组中</span></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="comment">//获取键的哈希值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">    <span class="comment">//计算键key在哈希桶数组table中的存储下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="comment">//将table数组index位置的值转换为Entry类型的数据</span></span><br><span class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="comment">//如果index位置的键值对entry不为空，则遍历链表，找到键相同的Entry键值对</span></span><br><span class="line">    <span class="keyword">for</span>(; entry != <span class="literal">null</span> ; entry = entry.next) &#123;</span><br><span class="line">        <span class="comment">//如果Hashtable中原来的键值对的哈希值等于待插入的键值对的哈希值</span></span><br><span class="line">        <span class="comment">//并且两个键值对对应的键key相等，则覆盖原来的键值对的值，无需插入</span></span><br><span class="line">        <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">            <span class="comment">//保存旧值</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">old</span> <span class="operator">=</span> entry.value;</span><br><span class="line">            <span class="comment">//覆盖旧值</span></span><br><span class="line">            entry.value = value;</span><br><span class="line">            <span class="comment">//返回旧值</span></span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//哈希桶数组中不存在相同的键，调用addEntry()方法实现添加</span></span><br><span class="line">    addEntry(hash, key, value, index);</span><br><span class="line">    <span class="comment">//添加新的键值对成功，返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">//结构性修改次数+1</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//获取哈希桶数组table</span></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="comment">//如果哈希桶数组中Entry键值对的数量大于扩容阈值threshold</span></span><br><span class="line">    <span class="comment">//则调用rehash()进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt;= threshold) &#123;</span><br><span class="line">        <span class="comment">// Rehash the table if the threshold is exceeded</span></span><br><span class="line">        rehash();</span><br><span class="line">        <span class="comment">//获取扩容后哈希桶数组table</span></span><br><span class="line">        tab = table;</span><br><span class="line">        <span class="comment">//重新获取键的哈希值</span></span><br><span class="line">        hash = key.hashCode();</span><br><span class="line">        <span class="comment">//重新计算key在新的哈希桶数组中的下标index</span></span><br><span class="line">        index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="comment">//将index位置的值的类型转换为Entry&lt;K,V&gt;类型</span></span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index];</span><br><span class="line">    <span class="comment">//新建一个Entry键值对，并将其存储到哈希表中index位置处</span></span><br><span class="line">    tab[index] = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, e);</span><br><span class="line">    <span class="comment">//哈希桶数组中键值对数量+1</span></span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>判断 value 是否为 null，不为空则执行下面的操作</li>
<li>计算键的哈希值，通过哈希值获取在哈希桶数组的下标</li>
<li>将 table 数组 index 位置的值转换为 Entry 类型的数据</li>
<li>如果 index 位置的键值对 entry 不为空，则遍历链表，找到键相同的 Entry 键值对进行替换；</li>
<li>如果没有，则调用 addEntry 进行添加，要先判断是否需要扩容（如果哈希桶数组中 Entry 键值对的数量大于扩容阈值 threshold，则调用 rehash()进行扩容）</li>
</ol>
<h2 id="删除">删除</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">    <span class="comment">// 计算哈希桶的下标位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="keyword">for</span>(Entry&lt;K,V&gt; prev = <span class="literal">null</span> ; e != <span class="literal">null</span> ; prev = e, e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            modCount++;</span><br><span class="line">            <span class="comment">// 判断是否为头节点，是则将头节点指向下一节点</span></span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="literal">null</span>) &#123;</span><br><span class="line">                prev.next = e.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tab[index] = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            count--;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            e.value = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查找">查找</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="literal">null</span> ; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> (V)e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩容方法">扩容方法</h2>
<p>扩容公式：（当前哈希桶数组的容量*2）+1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">rehash</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> table.length;</span><br><span class="line">    Entry&lt;?,?&gt;[] oldMap = table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算新的数组容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//如果新数组的容量大于Hashtable的最大容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果原来数组的容量已经等于最大容量则结束扩容</span></span><br><span class="line">        <span class="keyword">if</span> (oldCapacity == MAX_ARRAY_SIZE)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//否则，原数组还未达最大允许容量，则将最大容量作为扩容后的新容量</span></span><br><span class="line">        newCapacity = MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新建容量为上面计算的newCapacity的Entry数组</span></span><br><span class="line">    Entry&lt;?,?&gt;[] newMap = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;?,?&gt;[newCapacity];</span><br><span class="line">    <span class="comment">//结构修改性次数+1</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//重新计算扩容阈值</span></span><br><span class="line">    threshold = (<span class="type">int</span>)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//将扩容后的entry数组赋值给table</span></span><br><span class="line">    table = newMap;</span><br><span class="line">    <span class="comment">//遍历原来的哈希桶数组，将原来数组中的键值对重新定位到新数组中    </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> oldCapacity ; i-- &gt; <span class="number">0</span> ;) &#123;</span><br><span class="line">        <span class="comment">//遍历链表</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != <span class="literal">null</span> ; ) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = old;</span><br><span class="line">            old = old.next;</span><br><span class="line">            <span class="comment">//重新计算键值对在新数组的索引下标</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (e.hash &amp; <span class="number">0x7FFFFFFF</span>) % newCapacity;</span><br><span class="line">            e.next = (Entry&lt;K,V&gt;)newMap[index];</span><br><span class="line">            newMap[index] = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Map（3-LinkedHashMap）</title>
    <url>/blog/2025/01/25/%E5%BF%83%E5%BE%97/Java%E9%9B%86%E5%90%88/Map%EF%BC%883-LinkedHashMap%EF%BC%89/</url>
    <content><![CDATA[<h2 id="接口和属性">接口和属性</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="comment">//双链表头节点</span></span><br><span class="line">    <span class="keyword">transient</span> Entry&lt;K,V&gt; head;</span><br><span class="line">    <span class="comment">//双链表尾节点</span></span><br><span class="line">    <span class="keyword">transient</span> Entry&lt;K,V&gt; tail;</span><br><span class="line">    <span class="comment">//为true则表示按照基于访问的顺序来排列，意思就是最近使用的entry，放在链表的最末尾，</span></span><br><span class="line">    <span class="comment">//为false表示按照基于插入的顺序来排列，后插入的放在链表末尾，不指定默认为false</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> accessOrder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>.Node&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="comment">//双链表前继、后继节点</span></span><br><span class="line">        Entry&lt;K,V&gt; before, after;</span><br><span class="line">        Entry(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="built_in">super</span>(hash, key, value, next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="构造方法">构造方法</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指定accessOrder的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">boolean</span> accessOrder)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    <span class="built_in">this</span>.accessOrder = accessOrder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按照默认值初始化</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    accessOrder = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    accessOrder = <span class="literal">false</span>;</span><br><span class="line">    putMapEntries(m, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定初始化时的容量</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(initialCapacity);</span><br><span class="line">    accessOrder = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定初始化时的容量，和扩容的加载因子</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    accessOrder = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入">插入</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HashMap 中实现</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap 中实现</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;...&#125;</span><br><span class="line">    <span class="comment">// 通过节点 hash 定位节点所在的桶位置，并检测桶中是否包含节点引用</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>) &#123;...&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) &#123;...&#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 遍历链表，并统计链表长度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 未在单链表中找到要插入的节点，将新节点接在单链表的后面</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) &#123;...&#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 插入的节点已经存在于单链表中</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>) &#123;...&#125;</span><br><span class="line">            afterNodeAccess(e);    <span class="comment">// 回调方法，后续说明</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold) &#123;...&#125;</span><br><span class="line">    afterNodeInsertion(evict);    <span class="comment">// 回调方法，后续说明</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LinkedHashMap 重写了 newNode 和回调方法 afterNodeAccess、afterNodeInsertion</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在构建新节点时，构建的是LinkedHashMap.Entry 不再是Node.</span></span><br><span class="line">Node&lt;K,V&gt; <span class="title function_">newNode</span><span class="params">(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将新增的节点，连接在链表的尾部</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">linkNodeLast</span><span class="params">(Entry&lt;K,V&gt; p)</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    tail = p;</span><br><span class="line">    <span class="comment">//若集合是空的</span></span><br><span class="line">    <span class="keyword">if</span> (last == <span class="literal">null</span>)</span><br><span class="line">        head = p;</span><br><span class="line">    <span class="comment">//新节点插到链表顶部</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//仅仅在accessOrder为true时进行，把当前访问的元素移动到链表尾部</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> &#123; <span class="comment">// move node to last</span></span><br><span class="line">    Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="comment">//当accessOrder的值为true，且e不是尾节点</span></span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        <span class="comment">//将e赋值临时节点p， b是e的前一个节点， a是e的后一个节点</span></span><br><span class="line">        Entry&lt;K,V&gt; p = (Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        <span class="comment">//设置p的后一个节点为null，因为执行后p在链表末尾，after肯定为null</span></span><br><span class="line">        p.after = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//p的前一个节点不存在，p就是头节点，那么把p放到最后，a就是头节点</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="comment">//p的前一个节点存在，p放到最后，b的后一个节点指向a</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="comment">//p的后一个节点存在，p放到最后，a的前一个节点指向a</span></span><br><span class="line">        <span class="keyword">if</span> (a != <span class="literal">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="comment">//p的后一个节点不存在</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="comment">//只有一个p节点</span></span><br><span class="line">        <span class="keyword">if</span> (last == <span class="literal">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="comment">//last不为空，把p放到last节点后面</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//p为尾节点</span></span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//回调函数，新节点插入之后回调，根据evict和accessOrder判断是否需要删除最老/早插入的节点。</span></span><br><span class="line"><span class="comment">//如果实现LruCache会用到这个方法。</span></span><br><span class="line"><span class="comment">//removeEldestEntry制定删除规则，JDK8中默认返回false</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeInsertion</span><span class="params">(<span class="type">boolean</span> evict)</span> &#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="literal">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>LinkedHashMap 如何实现 LRU 缓存？</strong></p>
<p>将 accessOrder 设置为 true 并重写 removeEldestEntry 方法当链表大小超过容量时返回 true，使得每次访问一个元素时，该元素会被移动到链表的末尾。一旦插入操作让 removeEldestEntry 返回 true 时，视为缓存已满，LinkedHashMap 就会将链表首元素移除，由此我们就能实现一个 LRU 缓存。</p>
<h2 id="删除">删除</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HashMap 中实现</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap 中实现</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value, <span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, index;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="literal">null</span>, e; K k; V v;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) &#123;...&#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 遍历单链表，寻找要删除的节点，并赋值给 node 变量</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode) &#123;...&#125;</span><br><span class="line">            <span class="comment">// 将要删除的节点从单链表中移除</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);    <span class="comment">// 调用删除回调方法进行后续操作</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LinkedHashMap 中覆写</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> &#123; <span class="comment">// unlink</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    <span class="comment">// 将 p 节点的前驱后后继引用置空</span></span><br><span class="line">    p.before = p.after = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// b 为 null，表明 p 是头节点</span></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">null</span>)</span><br><span class="line">        head = a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        b.after = a;</span><br><span class="line">    <span class="comment">// a 为 null，表明 p 是尾节点</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span>)</span><br><span class="line">        tail = b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a.before = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>根据 hash 定位到桶位置</li>
<li>遍历链表或调用红黑树相关的删除方法</li>
<li>从 LinkedHashMap 维护的双链表中移除要删除的节点</li>
</ol>
<h2 id="查找">查找</h2>
<p>默认情况下，LinkedHashMap 是按插入顺序维护链表，不过我们可以在初始化 LinkedHashMap，指定 accessOrder 参数为 true，即可让它按访问顺序维护链表，当我们调用 get/getOrDefault/replace 等方法时，只要将这些方法访问的节点移动到链表的尾部即可（其前驱和后继也会跟着更新）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LinkedHashMap 中覆写</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 如果 accessOrder 为 true，则调用 afterNodeAccess 将被访问节点移动到链表最后</span></span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> &#123;</span><br><span class="line">   Node&lt;K,V&gt; e;</span><br><span class="line">   <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="literal">null</span>)</span><br><span class="line">       <span class="keyword">return</span> defaultValue;</span><br><span class="line">   <span class="keyword">if</span> (accessOrder)</span><br><span class="line">       afterNodeAccess(e);</span><br><span class="line">   <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> &#123; <span class="comment">// move node to last</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="literal">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="literal">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>访问键值为 3 的节点前</li>
</ol>
<p><img src="3.png" alt=""></p>
<ol start="2">
<li>访问后，键值为 3 的节点将会被移动到双向链表的最后位置，其前驱和后继也会跟着更新</li>
</ol>
<p><img src="4.png" alt=""></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Map（4-ConcurrentHashMap）</title>
    <url>/blog/2025/01/27/%E5%BF%83%E5%BE%97/Java%E9%9B%86%E5%90%88/Map%EF%BC%884-ConcurrentHashMap%EF%BC%89/</url>
    <content><![CDATA[<h2 id="ConcurrentHashMap1-7">ConcurrentHashMap1.7</h2>
<h3 id="属性和接口">属性和接口</h3>
<p>ConcurrentHashMap1.7 采用了数组+Segment+分段锁的方式实现，即 ConcurrentHashMap 把哈希桶数组切分成小数组（Segment），每个小数组有 n 个 HashEntry 组成</p>
<p>一个 ConcurrentHashMap 里包含一个 Segment 数组，Segment 的个数一旦初始化就不能改变。 Segment 数组的大小默认是 16，也就是说默认可以同时支持 16 个线程并发写。</p>
<p>Segment 的结构和 HashMap 类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个 HashEntry 数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 的锁。也就是说，对同一 Segment 的并发写入会被阻塞，不同 Segment 的写入是可以并发执行的。</p>
<p><img src="1.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentHashMap</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K, V&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">ConcurrentMap</span>&lt;K, V&gt;, Serializable &#123;</span><br><span class="line">	<span class="comment">//默认的初始容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line">	<span class="comment">//默认加载因子</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line">	<span class="comment">//默认的并发度，也就是默认的Segment数组长度</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CONCURRENCY_LEVEL</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line">    <span class="comment">//最大容量，ConcurrentMap最大容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">	<span class="comment">//每个segment中table数组的长度,必须是2^n,最小为2</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_SEGMENT_TABLE_CAPACITY</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">	<span class="comment">//允许最大segment数量,用于限定concurrencyLevel的边界,必须是2^n</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_SEGMENTS</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">16</span>; <span class="comment">// slightly conservative</span></span><br><span class="line">	<span class="comment">//在size方法和containsValue方法，会优先采用乐观的方式不加锁，直到重试次数达到2，</span></span><br><span class="line">	<span class="comment">//才会对所有Segment加锁，这个值的设定，是为了避免无限次的重试</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RETRIES_BEFORE_LOCK</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Segment</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.segment的读操作不需要加锁，但需要volatile读</span></span><br><span class="line"><span class="comment">    2.当进行扩容时(调用reHash方法)，需要拷贝原始数据，在拷贝数据上操作，保证在扩容完成前读操作仍可以在原始数据上进行。</span></span><br><span class="line"><span class="comment">    3.只有引起数据变化的操作需要加锁。</span></span><br><span class="line"><span class="comment">    4.scanAndLock(删除、替换)/scanAndLockForPut(新增)两个方法提供了获取锁的途径，是通过自旋锁实现的。</span></span><br><span class="line"><span class="comment">    5.在等待获取锁的过程中，两个方法都会对目标数据进行查找，每次查找都会与上次查找的结果对比，虽然查找结果不会被调用它的方法使用，但是这样做可以减少后续操作可能的cache miss。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     自旋锁的等待次数上限，多处理器时64次，单处理器时1次。</span></span><br><span class="line"><span class="comment">     每次等待都会进行查询操作，当等待次数超过上限时，不再自旋，调用lock方法等待获取锁。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_SCAN_RETRIES</span> <span class="operator">=</span></span><br><span class="line">        Runtime.getRuntime().availableProcessors() &gt; <span class="number">1</span> ? <span class="number">64</span> : <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//segment中的hash表，与hashMap结构相同，表中每个元素都是一个链表。</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表中元素个数</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录数据变化操作的次数。</span></span><br><span class="line">    <span class="comment">//这一数值主要为Map的isEmpty和size方法提供同步操作检查，这两个方法没有为全表加锁。</span></span><br><span class="line">    <span class="comment">//在统计segment.count前后，都会统计segment.modCount，如果前后两次值发生变化，</span></span><br><span class="line">    <span class="comment">//可以判断在统计count期间有segment发生了其它操作。</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//容量阈值，超过这一数值后segment将进行扩容，容量变为原来的两倍,threshold = loadFactor*table.length</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载因子</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line">    Segment(<span class="type">float</span> lf, <span class="type">int</span> threshold, HashEntry&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">        <span class="built_in">this</span>.loadFactor = lf;</span><br><span class="line">        <span class="built_in">this</span>.threshold = threshold;</span><br><span class="line">        <span class="built_in">this</span>.table = tab;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">HashEntry</span>&lt;K,V&gt; &#123; </span><br><span class="line">   <span class="keyword">final</span> K key;                       <span class="comment">// 声明 key 为 final 型</span></span><br><span class="line">   <span class="keyword">final</span> <span class="type">int</span> hash;                   <span class="comment">// 声明 hash 值为 final 型 </span></span><br><span class="line">   <span class="keyword">volatile</span> V value;                 <span class="comment">// 声明 value 为 volatile 型</span></span><br><span class="line">   <span class="keyword">final</span> HashEntry&lt;K,V&gt; next;      <span class="comment">// 声明 next 为 final 型 </span></span><br><span class="line"></span><br><span class="line">   HashEntry(K key, <span class="type">int</span> hash, HashEntry&lt;K,V&gt; next, V value) &#123; </span><br><span class="line">       <span class="built_in">this</span>.key = key; </span><br><span class="line">       <span class="built_in">this</span>.hash = hash; </span><br><span class="line">       <span class="built_in">this</span>.next = next; </span><br><span class="line">       <span class="built_in">this</span>.value = value; </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构造方法">构造方法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过指定的容量，加载因子和并发等级创建一个新的ConcurrentHashMap</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity,<span class="type">float</span> loadFactor, <span class="type">int</span> concurrencyLevel)</span> &#123;</span><br><span class="line">    <span class="comment">// 参数校验</span></span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="comment">// 校验并发级别大小，大于 1&lt;&lt;16，重置为 65536</span></span><br><span class="line">    <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">        concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">    <span class="comment">// 下面即通过并发等级来确定Segment的大小</span></span><br><span class="line">    <span class="comment">// sshift用来记录向左按位移动的次数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sshift</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ssize用来记录Segment数组的大小</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ssize</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 这个循环可以找到 concurrencyLevel 之上最近的 2的次方值</span></span><br><span class="line">    <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">        ++sshift;</span><br><span class="line">        ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录段偏移量</span></span><br><span class="line">    <span class="built_in">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">    <span class="comment">// 记录段掩码</span></span><br><span class="line">    <span class="built_in">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 设置容量</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">// c = 容量 / ssize ，默认 16 / 16 = 1，这里是计算每个 Segment 中的类似于 HashMap 的容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> initialCapacity / ssize;</span><br><span class="line">    <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">        ++c;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">    <span class="comment">//Segment 中的类似于 HashMap 的容量至少是2或者2的倍数</span></span><br><span class="line">    <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">        cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 创建 Segment 数组，设置 segments[0]</span></span><br><span class="line">    Segment&lt;K,V&gt; s0 = <span class="keyword">new</span> <span class="title class_">Segment</span>&lt;K,V&gt;(loadFactor, (<span class="type">int</span>)(cap * loadFactor),</span><br><span class="line">                         (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">HashEntry</span>[cap]);</span><br><span class="line">    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Segment</span>[ssize];</span><br><span class="line">    UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">    <span class="built_in">this</span>.segments = ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>进行参数校验，成功则进行下面的操作</li>
<li>校验并发级别 concurrencyLevel 大小，如果大于最大值，重置为最大值，无参构造默认值是 16</li>
<li>寻找并发级别 concurrencyLevel 之上最近的 2 的幂次方值（ssize），作为初始化容量大小，默认是 16</li>
<li>记录 segmentShift 偏移量（segmentShift），这个值为【容量 = 2 的 N 次方】中的 N，在后面 put 时计算位置时会用到。默认是 32-sshift = 28</li>
<li>记录 segmentMask 段掩码（segmentMark = 2^n-1），默认是 ssize-1 = 16-1 = 15</li>
<li>计算每个 Segment 中的类似于 HashMap 的容量 c</li>
<li>Segment 中的类似于 HashMap 的容量 c 必须是 2 的倍数，计算出大于 c 的 2 的 n 次方（cap）</li>
<li>初始化 segment [0]，默认大小为 2，负载因子为 0.75，扩容阈值为 2 *0.75 = 1.5（cap* loadFactor），插入第二个值才会进行扩容</li>
</ol>
<h3 id="插入">插入</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    <span class="comment">// hash 值无符号右移 28位（初始化时获得），然后与 segmentMask=15 做与运算</span></span><br><span class="line">    <span class="comment">// 其实也就是把高4位与segmentMask（1111）做与运算</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="literal">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">        <span class="comment">// 如果查找到的 Segment 为空，初始化</span></span><br><span class="line">        s = ensureSegment(j);</span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Segment&lt;K,V&gt; <span class="title function_">ensureSegment</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] ss = <span class="built_in">this</span>.segments;</span><br><span class="line">    <span class="type">long</span> <span class="variable">u</span> <span class="operator">=</span> (k &lt;&lt; SSHIFT) + SBASE; <span class="comment">// raw offset</span></span><br><span class="line">    Segment&lt;K,V&gt; seg;</span><br><span class="line">    <span class="comment">// 判断 u 位置的 Segment 是否为null</span></span><br><span class="line">    <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="literal">null</span>) &#123;</span><br><span class="line">        Segment&lt;K,V&gt; proto = ss[<span class="number">0</span>]; <span class="comment">// use segment 0 as prototype</span></span><br><span class="line">        <span class="comment">// 获取segment[0] 里的 HashEntry&lt;K,V&gt; 初始化长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> proto.table.length;</span><br><span class="line">        <span class="comment">// 获取segment[0] 里的 hash 表里的扩容负载因子，所有的 segment 的 loadFactor 是相同的</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">lf</span> <span class="operator">=</span> proto.loadFactor;</span><br><span class="line">        <span class="comment">// 计算扩容阀值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">threshold</span> <span class="operator">=</span> (<span class="type">int</span>)(cap * lf);</span><br><span class="line">        <span class="comment">// 创建一个 cap 容量的 HashEntry 数组</span></span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">HashEntry</span>[cap];</span><br><span class="line">        <span class="comment">// 再次检查 u 位置的 Segment 是否为null，因为这时可能有其他线程进行了操作</span></span><br><span class="line">        <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="literal">null</span>) &#123; <span class="comment">// recheck</span></span><br><span class="line">            Segment&lt;K,V&gt; s = <span class="keyword">new</span> <span class="title class_">Segment</span>&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line">            <span class="comment">// 自旋检查 u 位置的 Segment 是否为null</span></span><br><span class="line">            <span class="keyword">while</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 使用CAS 赋值，只会成功一次</span></span><br><span class="line">                <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(ss, u, <span class="literal">null</span>, seg = s))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> seg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>计算要 put 的 key 的位置，获取指定位置的 Segment</li>
<li>如果指定位置的 Segment 为空，则初始化这个 Segment</li>
<li>Segment.put 插入 key，value 值</li>
</ol>
<p>初始化 Segment 流程：</p>
<ol>
<li>检查计算得到的位置的 Segment 是否为 null</li>
<li>为 null 则继续初始化，使用 Segment [0] 的容量和负载因子创建一个 cap 容量的 HashEntry 数组</li>
<li>再次检查计算得到的指定位置的 Segment 是否为 null，因为这时可能有其他线程进行了操作</li>
<li>为 null 则使用创建的 HashEntry 数组初始化这个 Segment</li>
<li>自旋判断计算得到的指定位置的 Segment 是否为 null，是的话使用 CAS 在这个位置赋值为 Segment</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">put</span><span class="params">(K key, <span class="type">int</span> hash, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取 ReentrantLock 独占锁，获取不到，scanAndLockForPut 获取。</span></span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="literal">null</span> : scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="comment">// 计算要put的数据位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        <span class="comment">// CAS 获取 index 坐标的值</span></span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 检查是否 key 已经存在，如果存在，则遍历链表寻找位置，找到后替换 value</span></span><br><span class="line">                K k;</span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key || (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//node不为null,设置node的next为first，node为当前链表的头节点</span></span><br><span class="line">                <span class="keyword">if</span> (node != <span class="literal">null</span>)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//node为null,创建头节点,指定next为first，node为当前链表的头节点</span></span><br><span class="line">                    node = <span class="keyword">new</span> <span class="title class_">HashEntry</span>&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> count + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 容量大于扩容阀值，小于最大容量，进行扩容</span></span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// index 位置赋值 node，node 可能是一个元素，也可能是一个链表的表头</span></span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果指定的 Segment 不为空，由于 Segment 继承了 ReentrantLock，所以 Segment 内部可以很方便地获取锁</p>
<ol>
<li>tryLock()获取锁，获取不到使用 scanAndLockForPut 方法继续获取</li>
<li>计算 put 的数据要放入的 index 位置，然后获取这个位置上的 HashEntry</li>
<li>遍历 put 新元素，因为这里获取的 HashEntry 可能是一个空元素，也可能是链表已存在，所以要区别对待</li>
</ol>
<p>如果这个位置上的 HashEntry 不存在：</p>
<ul>
<li>如果当前容量大于扩容阈值，小于最大容量，进行扩容</li>
<li>直接头插法插入</li>
</ul>
<p>如果这个位置上的 HashEntry 存在：</p>
<ul>
<li>判断链表当前元素 key 和 hash 值是否和要 put 的 key 和 hash 值一致，一致则替换值；不一致则获取链表下一个节点，直到发现相同进行值替换，或者链表里没有相同的</li>
</ul>
<ol start="4">
<li>如果要插入的位置之前已经存在，替换后返回旧值，否则返回 null</li>
</ol>
<p><strong>scanAndLockForPut（自旋）</strong></p>
<p>在不超过最大重试次数 MAX_SCAN_RETRIES 通过 CAS 获取锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title function_">scanAndLockForPut</span><span class="params">(K key, <span class="type">int</span> hash, V value)</span> &#123;</span><br><span class="line">    <span class="comment">//first,e:键值对的hash值定位到数组tab的第一个键值对</span></span><br><span class="line">    HashEntry&lt;K,V&gt; first = entryForHash(<span class="built_in">this</span>, hash);</span><br><span class="line">    HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">    HashEntry&lt;K,V&gt; node = <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">retries</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// negative while locating node</span></span><br><span class="line">    <span class="comment">//线程尝试通过CAS获取锁</span></span><br><span class="line">    <span class="keyword">while</span> (!tryLock()) &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; f; <span class="comment">// to recheck first below</span></span><br><span class="line">        <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//当e==null或key.equals(e.key)时retry=0，走出这个分支</span></span><br><span class="line">            <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="comment">// speculatively create node</span></span><br><span class="line">                    <span class="comment">//初始化键值对，next指向null</span></span><br><span class="line">                    node = <span class="keyword">new</span> <span class="title class_">HashEntry</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (key.equals(e.key))</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                e = e.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//超过最大自旋次数，阻塞</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//头节点发生变化，重新遍历</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; (f = entryForHash(<span class="built_in">this</span>, hash)) != first) &#123;</span><br><span class="line">            e = first = f; <span class="comment">// re-traverse if entry changed</span></span><br><span class="line">            retries = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="rehash（扩容）">rehash（扩容）</h3>
<p>ConcurrentHahsMap 的扩容只会扩容到原来的两倍。老数组里的数据移动到新的数组时，位置要么不变，要么变为 index+oldSize，参数里的 node 会在扩容之后使用链表头插法插入到指定位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rehash</span><span class="params">(HashEntry&lt;K,V&gt; node)</span> &#123;</span><br><span class="line">    HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">    <span class="comment">// 老容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> oldTable.length;</span><br><span class="line">    <span class="comment">// 新容量，扩大两倍</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 新的扩容阀值 </span></span><br><span class="line">    threshold = (<span class="type">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    <span class="comment">// 创建新的数组</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] newTable = (HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> <span class="title class_">HashEntry</span>[newCapacity];</span><br><span class="line">    <span class="comment">// 新的掩码，默认2扩容后是4，-1是3，二进制就是11。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sizeMask</span> <span class="operator">=</span> newCapacity - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">        <span class="comment">// 遍历老数组</span></span><br><span class="line">        HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="comment">// 计算元素在新数组的索引</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> e.hash &amp; sizeMask;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="literal">null</span>) </span><br><span class="line">                <span class="comment">// 如果当前位置还不是链表，只是一个元素，直接赋值</span></span><br><span class="line">                newTable[idx] = e;</span><br><span class="line">            <span class="keyword">else</span> &#123; </span><br><span class="line">                <span class="comment">// 如果是链表了</span></span><br><span class="line">                HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">                <span class="type">int</span> <span class="variable">lastIdx</span> <span class="operator">=</span> idx;</span><br><span class="line">                <span class="comment">// 新的位置只可能是不便或者是老的位置+老的容量。</span></span><br><span class="line">                <span class="comment">// 遍历结束后，lastRun 后面的元素位置都是相同的</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next; last != <span class="literal">null</span>; last = last.next) &#123;</span><br><span class="line">                    <span class="comment">// k是单链表元素在新数组的位置</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> last.hash &amp; sizeMask;</span><br><span class="line">                    <span class="comment">// lastRun是最后一个扩容后不在原桶处的Entry</span></span><br><span class="line">                    <span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">                        lastIdx = k;</span><br><span class="line">                        lastRun = last;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// lastRun 后面的元素位置都是相同的，直接作为链表赋值到新位置。</span></span><br><span class="line">                newTable[lastIdx] = lastRun;</span><br><span class="line">                <span class="comment">// Clone remaining nodes</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                    <span class="comment">// 遍历剩余元素，头插法到指定 k 位置。</span></span><br><span class="line">                    <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> p.value;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> p.hash;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> h &amp; sizeMask;</span><br><span class="line">                    HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                    newTable[k] = <span class="keyword">new</span> <span class="title class_">HashEntry</span>&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 头插法插入新的节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nodeIndex</span> <span class="operator">=</span> node.hash &amp; sizeMask; <span class="comment">// add the new node</span></span><br><span class="line">    node.setNext(newTable[nodeIndex]);</span><br><span class="line">    newTable[nodeIndex] = node;</span><br><span class="line">    table = newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查找">查找</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    <span class="type">long</span> <span class="variable">u</span> <span class="operator">=</span> (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    <span class="comment">// 计算得到 key 的存放位置</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        (tab = s.table) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">                 (tab, ((<span class="type">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">             e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">            <span class="comment">// 如果是链表，遍历查找到相同 key 的 value。</span></span><br><span class="line">            K k;</span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>通过 key 值的 hash 值定位到对应 Segment 对象，再通过 hash 值定位到具体的 entry 对象</li>
<li>遍历链表，通过 equals 取出数据</li>
<li>由于 HashEntry 中的 value 属性是用 volatile 关键字修饰的，保证了内存可见性，所以每次获取时都是最新值，整个过程不需要加锁</li>
</ol>
<h3 id="删除">删除</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    Segment&lt;K,V&gt; s = segmentForHash(hash);</span><br><span class="line">    <span class="keyword">return</span> s == <span class="literal">null</span> ? <span class="literal">null</span> : s.remove(key, hash, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">remove</span><span class="params">(Object key, <span class="type">int</span> hash, Object value)</span> &#123;</span><br><span class="line">    <span class="comment">//获取同步锁</span></span><br><span class="line">    <span class="keyword">if</span> (!tryLock())</span><br><span class="line">        scanAndLock(key, hash);</span><br><span class="line">    <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        HashEntry&lt;K,V&gt; e = entryAt(tab, index);</span><br><span class="line">        <span class="comment">//遍历链表用来保存当前链表节点的前一个节点</span></span><br><span class="line">        HashEntry&lt;K,V&gt; pred = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            K k;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="comment">//找到key对应的键值对</span></span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> e.value;</span><br><span class="line">                <span class="comment">//键值对的值与传入的value相等</span></span><br><span class="line">                <span class="keyword">if</span> (value == <span class="literal">null</span> || value == v || value.equals(v)) &#123;</span><br><span class="line">                    <span class="comment">//当前元素为头节点，把当前元素的下一个节点设为头节点</span></span><br><span class="line">                    <span class="keyword">if</span> (pred == <span class="literal">null</span>)</span><br><span class="line">                        setEntryAt(tab, index, next);</span><br><span class="line">                    <span class="comment">//不是头节点，把当前链表节点的前一个节点的next指向当前节点的下一个节点</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        pred.setNext(next);</span><br><span class="line">                    ++modCount;</span><br><span class="line">                    --count;</span><br><span class="line">                    oldValue = v;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pred = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>scanAndLock（自旋）</strong></p>
<p>扫描是否含有指定的 key 并且获取同步锁，当方法执行完毕，即跳出循环成功获取到同步锁，跳出循环的方式：</p>
<ol>
<li>tryLock 方法尝试获取独占锁成功</li>
<li>尝试获取超过最大自旋次数 MAX_SCAN_RETRIES 线程堵塞，当线程从等待队列中被唤醒获取到锁跳出循环</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">scanAndLock</span><span class="params">(Object key, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">    <span class="comment">// similar to but simpler than scanAndLockForPut</span></span><br><span class="line">    HashEntry&lt;K,V&gt; first = entryForHash(<span class="built_in">this</span>, hash);</span><br><span class="line">    HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">    <span class="type">int</span> <span class="variable">retries</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!tryLock()) &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; f;</span><br><span class="line">        <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="literal">null</span> || key.equals(e.key))</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                e = e.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; (f = entryForHash(<span class="built_in">this</span>, hash)) != first) &#123;</span><br><span class="line">            e = first = f;</span><br><span class="line">            retries = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ConcurrentHashMap1-8">ConcurrentHashMap1.8</h2>
<h3 id="属性和接口-2">属性和接口</h3>
<p>ConcurrentHashMap 采用了数组+链表+红黑树的实现方法，内部大量采用 CAS 操作，只需要这个链表头节点（红黑树的根节点），就不会影响其他的哈希桶数组元素的读写</p>
<p><img src="2.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentHashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">ConcurrentMap</span>&lt;K,V&gt;, Serializable &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// node数组最大容量：2^30=1073741824</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// 默认初始值，必须是2的幂数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line">    <span class="comment">// 数组可能最大值，需要与toArray（）相关方法关联</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 并发级别，遗留下来的，为兼容以前的版本</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CONCURRENCY_LEVEL</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line">    <span class="comment">// 负载因子</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line">    <span class="comment">// 链表转红黑树阀值,&gt; 8 链表转换为红黑树</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 树转链表阀值，小于等于6（tranfer时，lc、hc=0两个计数器分别++记录原bin、新binTreeNode数量，&lt;=UNTREEIFY_THRESHOLD 则untreeify(lo)）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 最小树容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TRANSFER_STRIDE</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">RESIZE_STAMP_BITS</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line">    <span class="comment">// 2^15-1，help resize的最大线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_RESIZERS</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 32-16=16，sizeCtl中记录size大小的偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RESIZE_STAMP_SHIFT</span> <span class="operator">=</span> <span class="number">32</span> - RESIZE_STAMP_BITS;</span><br><span class="line">    <span class="comment">// forwarding nodes的hash值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOVED</span>     <span class="operator">=</span> -<span class="number">1</span>; </span><br><span class="line">    <span class="comment">// 树根节点的hash值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEBIN</span>   <span class="operator">=</span> -<span class="number">2</span>; </span><br><span class="line">    <span class="comment">// ReservationNode的hash值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RESERVED</span>  <span class="operator">=</span> -<span class="number">3</span>; </span><br><span class="line">    <span class="comment">// 可用处理器数量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NCPU</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line">    <span class="comment">// 存放node的数组</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line">    <span class="comment">// 扩容总进度</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> transferIndex;</span><br><span class="line">    <span class="comment">// 转移的时候用的数组</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">    <span class="comment">// 控制标识符，用来控制table的初始化和扩容的操作，不同的值有不同的含义</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> sizeCtl;</span><br><span class="line">    <span class="comment">// 该属性保存着整个哈希表中存储的所有的结点的个数总和，有点类似于 HashMap 的 size 属性。</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">long</span> baseCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构造方法-2">构造方法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.sizeCtl = DEFAULT_CAPACITY;</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, loadFactor, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">int</span> concurrencyLevel)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   </span><br><span class="line">        initialCapacity = concurrencyLevel;  </span><br><span class="line">    <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> (<span class="type">long</span>)(<span class="number">1.0</span> + (<span class="type">long</span>)initialCapacity / loadFactor);</span><br><span class="line">    <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> (size &gt;= (<span class="type">long</span>)MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((<span class="type">int</span>)size);</span><br><span class="line">    <span class="comment">//初始化时根据这个值作为桶数组table的长度</span></span><br><span class="line">    <span class="built_in">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调用构造方法创建 ConcurrentHashMap 对象时，只是根据传入参数计算桶数组初始长度赋值给 sizeCtl，并没有初始化 table 数组，只有在插入元素时才用 initTable 方法进行延迟加载</p>
<p><strong>initTable（初始化）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="type">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//　如果 sizeCtl &lt; 0 ,说明另外的线程执行CAS 成功，正在进行初始化。</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 让出 CPU 使用权</span></span><br><span class="line">            Thread.<span class="keyword">yield</span>(); </span><br><span class="line">        <span class="comment">// sizeCtl设为-1，由当前线程负责桶数组的初始化</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 得出数组的大小</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">// 计算数组中可用的大小：实际大小n*0.75（加载因子）</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConcurrentHashMap 的初始化是通过自旋和 CAS 操作完成的。里面需要注意的是变量 sizeCtl，它的值决定着当前的初始化状态</p>
<ol>
<li>sizeCtl =-1：表示有线程正在进行真正的初始化操作</li>
<li>sizeCtl =-(1+nThreads)：表示有 nThreads 个线程正在扩容操作</li>
<li>sizeCtl &gt; 0：如果 table 数组还没有初始化，这就是初始化的长度；如果已经初始化了，sizeCtl 是 table 数组长度的 0.75 倍，代表扩容阈值</li>
<li>sizeCtl = 0：默认值，此时在真正的初始化操作中使用默认容量</li>
</ol>
<h3 id="插入-2">插入</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="comment">// key 和 value 不能为空</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        <span class="comment">// f = 目标位置元素</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;<span class="comment">// fh 后面存放目标位置的元素 hash 值</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 数组桶为空，初始化数组桶（自旋+CAS)</span></span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 桶内为空，CAS 放入，不加锁，成功了就直接 break 跳出</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>,<span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//桶里的节点是ForwardingNode,ConcurrentHashMap处于扩容阶段，让当前线程帮助扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 使用 synchronized 加锁加入节点</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">// 说明是链表</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// 循环加入新的或者覆盖节点</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        <span class="comment">// 红黑树</span></span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//检查是否需要把链表转为红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新ConcurrentHashMap中存放键值对个数</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>根据 key 计算出 hashCode，判断下面的 4 种情况</li>
</ol>
<ul>
<li>判断是否需要进行初始化，如果桶数组为空，初始化桶数组（CAS+自旋，即执行 initTable 方法）</li>
<li>判断当前 key 定位出的 Node，如果桶数组中的元素为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋，保证成功</li>
<li>如果当前位置的 hashCode = MOVED（-1），说明其他线程在扩容，则需要进行扩容</li>
<li>如果都不满足，则利用 synchronized 锁写入数据</li>
</ul>
<ol start="2">
<li>如果数量大于 TREEIFY_THRESHOLD 则要执行树化方法，在 treeifyBin 中会首先判断当前数组长度 &gt;= 64 时才会将链表转换为红黑树</li>
<li>判断是否需要扩容，如果超过了临界值就需要扩容</li>
</ol>
<h3 id="触发扩容的情况">触发扩容的情况</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//新增元素时，也就是在调用 putVal 方法后，为了通用，增加了个 check 入参，用于指定是否可能会出现扩容的情况</span></span><br><span class="line"><span class="comment">//check &gt;= 0 即为可能出现扩容的情况，例如 putVal方法中的调用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">addCount</span><span class="params">(<span class="type">long</span> x, <span class="type">int</span> check)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="type">int</span> n, sc;</span><br><span class="line">        <span class="comment">//检查当前集合元素个数 s 是否达到扩容阈值 sizeCtl ，扩容时 sizeCtl 为负数，依旧成立，同时还得满足数组非空且数组长度不能大于允许的数组最大长度这两个条件才能继续</span></span><br><span class="line">        <span class="comment">//这个 while 循环除了判断是否达到阈值从而进行扩容操作之外还有一个作用就是当一条线程完成自己的迁移任务后，如果集合还在扩容，则会继续循环，继续加入扩容大军，申请后面的迁移任务</span></span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="type">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> resizeStamp(n);</span><br><span class="line">            <span class="comment">// sc &lt; 0 说明集合正在扩容当中</span></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//判断扩容是否结束或者并发扩容线程数是否已达最大值，如果是的话直接结束while循环</span></span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> || sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="literal">null</span> || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//扩容还未结束，并且允许扩容线程加入，此时加入扩容大军中</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果集合还未处于扩容状态中，则进入扩容方法，并首先初始化 nextTab 数组，也就是新数组</span></span><br><span class="line">            <span class="comment">//(rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2 为首个扩容线程所设置的特定值，后面扩容时会根据线程是否为这个值来确定是否为最后一个线程</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="literal">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//扩容状态下其他线程对集合进行插入、修改、删除、合并、compute等操作时遇到 ForwardingNode 节点会调用该帮助扩容方法 (ForwardingNode 后面介绍)</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; <span class="type">int</span> sc;</span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="literal">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp; (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> resizeStamp(tab.length);</span><br><span class="line">        <span class="comment">//此处的 while 循环是上面 addCount 方法的简版，可以参考上面的注释</span></span><br><span class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp; (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//putAll批量插入或者插入节点后发现链表长度达到8个或以上，但数组长度为64以下时触发的扩容会调用到这个方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">tryPresize</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ? MAXIMUM_CAPACITY : tableSizeFor(size + (size &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> sc;</span><br><span class="line">    <span class="comment">//如果不满足条件，也就是 sizeCtl &lt; 0 ，说明有其他线程正在扩容当中，这里也就不需要自己去扩容了，结束该方法</span></span><br><span class="line">    <span class="keyword">while</span> ((sc = sizeCtl) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab = table; <span class="type">int</span> n;</span><br><span class="line">        <span class="comment">//如果数组初始化则进行初始化，这个选项主要是为批量插入操作方法 putAll 提供的</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">            n = (sc &gt; c) ? sc : c;</span><br><span class="line">            <span class="comment">//初始化时将 sizeCtl 设置为 -1 ，保证单线程初始化</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (table == tab) &#123;</span><br><span class="line">                        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                        table = nt;</span><br><span class="line">                        sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//初始化完成后 sizeCtl 用于记录当前集合的负载容量值，也就是触发集合扩容的阈值</span></span><br><span class="line">                    sizeCtl = sc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//插入节点后发现链表长度达到8个或以上，但数组长度为64以下时触发的扩容会进入到下面这个 else if 分支</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tab == table) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> resizeStamp(n);</span><br><span class="line">            <span class="comment">//下面的内容基本跟上面 addCount 方法的 while 循环内部一致，可以参考上面的注释</span></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                Node&lt;K,V&gt;[] nt;</span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> || sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="literal">null</span> || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>在调用 addCount 方法增加集合元素计数后发现当前集合元素个数到达扩容阈值时就会触发扩容</li>
<li>扩容状态下其他线程对集合进行插入、修改、删除、合并、compute 等操作时遇到 ForwardingNode 节点会触发扩容</li>
<li>putAll 批量插入或者插入节点后发现存在链表长度达到 8 个以上，但数组长度为 64 以下时会触发扩容</li>
</ol>
<h3 id="扩容方法">扩容方法</h3>
<p>调用该扩容方法的地方：</p>
<ol>
<li>addCount：向集合中插入新数据后更新容量计数时发现到达扩容阈值而触发的扩容</li>
<li>helpTransfer：扩容状态下其他线程对集合进行插入、修改、删除、合并、compute 等操作时遇到 ForwardingNode 节点时触发的扩容</li>
<li>tryPresize：putAll 批量插入或者插入后发现链表长度达到 8 个或以上，但数组长度为 64 以下时触发的扩容</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> tab.length, stride;</span><br><span class="line">    <span class="comment">//计算每条线程处理的桶个数，每条线程处理的桶数量一样，如果CPU为单核，则使用一条线程处理所有桶</span></span><br><span class="line">    <span class="comment">//每条线程至少处理16个桶，如果计算出来的结果少于16，则一条线程处理16个桶</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="literal">null</span>) &#123;            <span class="comment">// 初始化新数组(原数组长度的2倍)</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        <span class="comment">//将 transferIndex 指向最右边的桶，也就是数组索引下标最大的位置</span></span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">nextn</span> <span class="operator">=</span> nextTab.length;</span><br><span class="line">    <span class="comment">//新建一个占位对象，该占位对象的 hash 值为 -1 该占位对象存在时表示集合正在扩容状态，key、value、next 属性均为 null ，nextTable 属性指向扩容后的数组</span></span><br><span class="line">    <span class="comment">//该占位对象主要有两个用途：</span></span><br><span class="line">    <span class="comment">//   1、占位作用，用于标识数组该位置的桶已经迁移完毕，处于扩容中的状态。</span></span><br><span class="line">    <span class="comment">//   2、作为一个转发的作用，扩容期间如果遇到查询操作，遇到转发节点，会把该查询操作转发到新的数组上去，不会阻塞查询操作。</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> <span class="title class_">ForwardingNode</span>&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="comment">//该标识用于控制是否继续处理下一个桶，为 true 则表示已经处理完当前桶，可以继续迁移下一个桶的数据</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">advance</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//该标识用于控制扩容何时结束，该标识还有一个用途是最后一个扩容线程会负责重新检查一遍数组查看是否有遗漏的桶</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">finishing</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">    <span class="comment">//这个循环用于处理一个 stride 长度的任务，i 后面会被赋值为该 stride 内最大的下标，而 bound 后面会被赋值为该 stride 内最小的下标</span></span><br><span class="line">    <span class="comment">//通过循环不断减小 i 的值，从右往左依次迁移桶上面的数据，直到 i 小于 bound 时结束该次长度为 stride 的迁移任务</span></span><br><span class="line">    <span class="comment">//结束这次的任务后会通过外层 addCount、helpTransfer、tryPresize 方法的 while 循环达到继续领取其他任务的效果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> fh;</span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="type">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="comment">//每处理完一个hash桶就将 bound 进行减 1 操作</span></span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//transferIndex &lt;= 0 说明数组的hash桶已被线程分配完毕，没有了待分配的hash桶，将 i 设置为 -1 ，后面的代码根据这个数值退出当前线的扩容操作</span></span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//只有首次进入for循环才会进入这个判断里面去，设置 bound 和 i 的值，也就是领取到的迁移任务的数组区间</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, TRANSFERINDEX, nextIndex, nextBound = (nextIndex &gt; stride ? nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="type">int</span> sc;</span><br><span class="line">            <span class="comment">//扩容结束后做后续工作，将 nextTable 设置为 null，表示扩容已结束，将 table 指向新数组，sizeCtl 设置为扩容阈值</span></span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                nextTable = <span class="literal">null</span>;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//每当一条线程扩容结束就会更新一次 sizeCtl 的值，进行减 1 操作</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//(sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT 成立，说明该线程不是扩容大军里面的最后一条线程，直接return回到上层while循环</span></span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="comment">//(sc - 2) == resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT 说明这条线程是最后一条扩容线程</span></span><br><span class="line">                <span class="comment">//之所以能用这个来判断是否是最后一条线程，因为第一条扩容线程进行了如下操作：</span></span><br><span class="line">                <span class="comment">//    U.compareAndSwapInt(this, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)</span></span><br><span class="line">                <span class="comment">//除了修改结束标识之外，还得设置 i = n; 以便重新检查一遍数组，防止有遗漏未成功迁移的桶</span></span><br><span class="line">                finishing = advance = <span class="literal">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">//遇到数组上空的位置直接放置一个占位对象，以便查询操作的转发和标识当前处于扩容状态</span></span><br><span class="line">            advance = casTabAt(tab, i, <span class="literal">null</span>, fwd);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">//数组上遇到hash值为MOVED，也就是 -1 的位置，说明该位置已经被其他线程迁移过了，将 advance 设置为 true ，以便继续往下一个桶检查并进行迁移操作</span></span><br><span class="line">            advance = <span class="literal">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    <span class="comment">//该节点为链表结构</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">runBit</span> <span class="operator">=</span> fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="comment">//遍历整条链表，找出 lastRun 节点</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="literal">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//根据 lastRun 节点的高位标识(0 或 1)，首先将 lastRun设置为 ln 或者 hn 链的末尾部分节点，后续的节点使用头插法拼接</span></span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//使用高位和低位两条链表进行迁移，使用头插法拼接链表</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">ph</span> <span class="operator">=</span> p.hash; <span class="type">K</span> <span class="variable">pk</span> <span class="operator">=</span> p.key; <span class="type">V</span> <span class="variable">pv</span> <span class="operator">=</span> p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//setTabAt方法调用的是 Unsafe 类的 putObjectVolatile 方法</span></span><br><span class="line">                        <span class="comment">//使用 volatile 方式的 putObjectVolatile 方法，能够将数据直接更新回主内存，并使得其他线程工作内存的对应变量失效，达到各线程数据及时同步的效果</span></span><br><span class="line">                        <span class="comment">//使用 volatile 的方式将 ln 链设置到新数组下标为 i 的位置上</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        <span class="comment">//使用 volatile 的方式将 hn 链设置到新数组下标为 i + n(n为原数组长度) 的位置上</span></span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">//迁移完成后使用 volatile 的方式将占位对象设置到该 hash 桶上，该占位对象的用途是标识该hash桶已被处理过，以及查询请求的转发作用</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        <span class="comment">//advance 设置为 true 表示当前 hash 桶已处理完，可以继续处理下一个 hash 桶</span></span><br><span class="line">                        advance = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//该节点为红黑树结构</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        <span class="comment">//lo 为低位链表头结点，loTail 为低位链表尾结点，hi 和 hiTail 为高位链表头尾结点</span></span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">lc</span> <span class="operator">=</span> <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="comment">//同样也是使用高位和低位两条链表进行迁移</span></span><br><span class="line">                        <span class="comment">//使用for循环以链表方式遍历整棵红黑树，使用尾插法拼接 ln 和 hn 链表</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> e.hash;</span><br><span class="line">                            <span class="comment">//这里面形成的是以 TreeNode 为节点的链表</span></span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="literal">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="literal">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//形成中间链表后会先判断是否需要转换为红黑树：</span></span><br><span class="line">                        <span class="comment">//1、如果符合条件则直接将 TreeNode 链表转为红黑树，再设置到新数组中去</span></span><br><span class="line">                        <span class="comment">//2、如果不符合条件则将 TreeNode 转换为普通的 Node 节点，再将该普通链表设置到新数组中去</span></span><br><span class="line">                        <span class="comment">//(hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t 这行代码的用意在于，如果原来的红黑树没有被拆分成两份，那么迁移后它依旧是红黑树，可以直接使用原来的 TreeBin 对象</span></span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                        (hc != <span class="number">0</span>) ? <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                        (lc != <span class="number">0</span>) ? <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        <span class="comment">//setTabAt方法调用的是 Unsafe 类的 putObjectVolatile 方法</span></span><br><span class="line">                        <span class="comment">//使用 volatile 方式的 putObjectVolatile 方法，能够将数据直接更新回主内存，并使得其他线程工作内存的对应变量失效，达到各线程数据及时同步的效果</span></span><br><span class="line">                        <span class="comment">//使用 volatile 的方式将 ln 链设置到新数组下标为 i 的位置上</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        <span class="comment">//使用 volatile 的方式将 hn 链设置到新数组下标为 i + n(n为原数组长度) 的位置上</span></span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">//迁移完成后使用 volatile 的方式将占位对象设置到该 hash 桶上，该占位对象的用途是标识该hash桶已被处理过，以及查询请求的转发作用</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        <span class="comment">//advance 设置为 true 表示当前 hash 桶已处理完，可以继续处理下一个 hash 桶</span></span><br><span class="line">                        advance = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>扩容期间在未迁移到的 hash 桶插入数据会发生什么？</li>
</ol>
<p>只要插入的位置扩容线程还未迁移到，就可以插入，当迁移到该插入的位置时，就会阻塞等待插入操作完成再继续迁移</p>
<ol start="2">
<li>正在迁移的 hash 桶遇到 get 操作会发生什么？</li>
</ol>
<p>在扩容过程期间形成的 hn 和 ln 链是使用的类似于复制引用的方式，即 ln 和 hn 链是复制出来的，而非原来的链表迁移过去的，所以原来 hash 桶上的链表并没有受到影响，因此从迁移开始到迁移结束这段时间都是可以正常访问原数组 hash 桶上面的链表，迁移结束后放置上 fwd，往后的询问请求就直接转发到扩容后的数组去了</p>
<ol start="3">
<li>如果 lastRun 节点正好在一条全部都为高位或者都为低位的链表上，会不会形成死循环？</li>
</ol>
<p>在数组长度为 64 之前会导致一直扩容，但是到了 64 或者以上后就会转换为红黑树，因此不会一直死循环</p>
<ol start="4">
<li>扩容后 ln 和 hn 链不用经过 hash 取模运算，分别被直接放置在新数组的 i 和 n+1 的位置上，那么如何保证这种方式依旧可以用过 h&amp;(n-1)正确算出 hash 桶的位置？</li>
</ol>
<p>如果 fh&amp;(n-1)= i，那么扩容之后的 hash 计算方法应该是 fh&amp;(2n-1)，因此 n 是 2 的幂次方数组，所以如果 n = 16，n-1 就是 1111（二进制），那么 2n-1 就是 11111（二进制），所以说如果 fh 的第 5 位不是 1 的话，fh&amp;n = 0 可得出 fh&amp;(2n-1)== fh&amp;(n-1)= i；如果是 1 的话，fh&amp;n = n 可得出 fh&amp;(2n-1)= i+n</p>
<h3 id="查找-2">查找</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="type">int</span> n, eh; K ek;</span><br><span class="line">    <span class="comment">// key 所在的 hash 位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果指定位置元素存在，头结点hash值相同</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="comment">// key hash 值相等，key值相同，直接返回元素 value</span></span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 头结点hash值小于0，说明正在扩容或者是红黑树，find查找</span></span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="literal">null</span> ? p.val : <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 是链表，遍历查找</span></span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>根据 hash 值计算位置</li>
<li>查找到指定位置，如果头节点就是要找的，直接返回它的 value</li>
<li>如果头节点 hash 值小于 0，说明正在扩容或者是红黑树，find 查找</li>
<li>如果是链表，遍历查找</li>
</ol>
<h3 id="为什么不支持-Key-或-Value-为-null？">为什么不支持 Key 或 Value 为 null？</h3>
<ol>
<li>
<p>避免歧义：在多线程环境下，get(key)方法如果返回 null，不知道这个 null 是代表 key 不存在或者是值本来就是 null;</p>
</li>
<li>
<p>简化实现：如果允许 null，代码里面就需要频繁的去判断 null 到底是代表 key 不存在或者是值本来就是 null</p>
</li>
</ol>
<p><strong>HashMap 为什么可以?</strong></p>
<p>HashMap 设计的初衷是单线程，它有 containsKey 方法可以判断 key 是否存在。ConcurrentHashMap 不能用 containsKey，因为多线程环境下也会有歧义。比如：刚判断完 key 不存在，然后就有一个线程插入了这个 key</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Set（1-HashSet）</title>
    <url>/blog/2025/01/26/%E5%BF%83%E5%BE%97/Java%E9%9B%86%E5%90%88/Set%EF%BC%881-HashSet%EF%BC%89/</url>
    <content><![CDATA[<h2 id="实现原理">实现原理</h2>
<ol>
<li>HashSet 的实现是依赖于 HashMap 的，HashSet 的值都是存储在 HashMap 中的。在 HashSet 的构造法中会初始化一个 HashMap 对象，HashSet 不允许值重复。因此，HashSet 的值是作为 HashMap 的 key 存储在 HashMap 中的，当存储的值已经存在时返回 false</li>
<li>HashSet 非线程安全，允许 null 值，添加值的时候会先获取对象的 hashCode 方法，如果 hashCode 方法返回的值一致，则再调用 equals 方法判断是否一致，如果不一致才 add 元素。HashSet 不保证迭代时顺序，也不保证存储的元素的顺序保持不变</li>
</ol>
<h2 id="接口和属性">接口和属性</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt; </span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable  &#123;  </span><br><span class="line">   <span class="comment">// 底层使用HashMap来保存HashSet中所有元素。  </span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;  </span><br><span class="line">     </span><br><span class="line">   <span class="comment">// 定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。  </span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); </span><br><span class="line"></span><br><span class="line">   <span class="comment">//........</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="构造方法">构造方法</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 默认的无参构造器，构造一个空的HashSet。 </span></span><br><span class="line"><span class="comment">* 实际底层会初始化一个空的HashMap，并使用默认初始容量为16和加载因子0.75。 </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;  </span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;E,Object&gt;();  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 构造一个包含指定collection中的元素的新set。 </span></span><br><span class="line"><span class="comment">* 实际底层使用默认的加载因子0.75和足以包含指定collection中所有元素的初始容量来创建一个HashMap。 </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;  </span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;E,Object&gt;(Math.max((<span class="type">int</span>) (c.size()/<span class="number">.75f</span>) + <span class="number">1</span>, <span class="number">16</span>));  </span><br><span class="line">    addAll(c);  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 以指定的initialCapacity和loadFactor构造一个空的HashSet。 </span></span><br><span class="line"><span class="comment">* 实际底层以相应的参数构造一个空的HashMap。 </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;  </span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;E,Object&gt;(initialCapacity, loadFactor);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 以指定的initialCapacity构造一个空的HashSet。 </span></span><br><span class="line"><span class="comment">* 实际底层以相应的参数及加载因子loadFactor为0.75构造一个空的HashMap。  </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;  </span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;E,Object&gt;(initialCapacity);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 以指定的initialCapacity和loadFactor构造一个新的空链接哈希集合。 </span></span><br><span class="line"><span class="comment">* 此构造函数为包访问权限，不对外公开，实际只是是对LinkedHashSet的支持。 </span></span><br><span class="line"><span class="comment">* 实际底层会以指定的参数构造一个空LinkedHashMap实例来实现。 </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">boolean</span> dummy)</span> &#123;  </span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;E,Object&gt;(initialCapacity, loadFactor);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h2 id="插入">插入</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 如果此set中尚未包含指定元素，则添加指定元素。 </span></span><br><span class="line"><span class="comment">* 更确切地讲，如果此 set 没有包含满足(e==null?e2==null:e.equals(e2))的元素e2，则向此set添加指定的元素e。 </span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* 底层实际将将该元素作为key放入HashMap。 </span></span><br><span class="line"><span class="comment">* 当新放入HashMap的Entry中key与集合中原有Entry的key相同</span></span><br><span class="line"><span class="comment">* 新添加的Entry的value会将覆盖原来Entry的value，但key不会有任何改变， </span></span><br><span class="line"><span class="comment">* 因此如果向HashSet中添加一个已经存在的元素时，新添加的集合元素将不会被放入HashMap中， </span></span><br><span class="line"><span class="comment">* 原来的元素也不会有任何改变，这也就满足了Set中元素不重复的特性。 </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="删除">删除</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 如果指定元素存在于此set中，则将其移除。 </span></span><br><span class="line"><span class="comment">* 更确切地讲，如果此set包含一个满足(o==null?e==null:o.equals(e))的元素e，则将其移除。如果此set已包含该元素，则返回true </span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* 底层实际调用HashMap的remove方法删除指定Entry。 </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> map.remove(o)==PRESENT;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h2 id="包含">包含</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他">其他</h2>
<h3 id="怎么保证元素不重复？">怎么保证元素不重复？</h3>
<p>元素值作为的是 map 的 key，map 的 value 则是 PRESENT 变量，这个变量只作为放入 map 时的一个占位符而存在，没实际用处。HashMap 的 key 是不能重复的，而 HashSet 的元素又作为 map 的 key，所以也不能重复</p>
<p><strong>为什么 val 要放上一个静态常量 present？</strong></p>
<ol>
<li>HashMap 使用 put 的时候，会把 put 的数据放在其位置上，如果该位置上已经存在当前 key，会对其 key 映射的 val 给替换掉，并且返回之前的 val；如果没有 key，则返回 null</li>
<li>val 放了一个 hashset 类的静态常量 present，如果 put 返回的是 null，不是 present，就说明 put 的 key 是不存在的，add 也会返回 true。如果 put 返回的是 present 就说明之前的 key 是存在的，并不是没有 put 上，所以 add 方法返回的 false 并不是存失败的意思</li>
</ol>
<h3 id="HashSet-是有序的吗？">HashSet 是有序的吗？</h3>
<p>HashSet 是无序的，它不能保证存储和取出顺序一致</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetOfInteger</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">47</span>);</span><br><span class="line">        Set&lt;Integer&gt; intset = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            intset.add(rand.nextInt(<span class="number">30</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(intset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HashSet 源码节选-JKD8</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap 源码节选-JDK8</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap 源码节选-JDK8</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里因为value的类型是Integer，所以使用的是Integer的hashCode</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Integer 中 hashCode 方法的返回值就是这个数本身，当数值小于 65536 时，得到的 hash 值是本身，插入到 HashMap 中的顺序即 hash 的顺序，所以是有序的；当超过该值时，HashSet 是无序的</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Lambda表达式和方法引用</title>
    <url>/blog/2025/01/22/Java/%E5%B7%A5%E4%BD%9C%E6%8A%80%E5%B7%A7/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Lambda-表达式">Lambda 表达式</h2>
<h3 id="什么是-Lambda-表达式？">什么是 Lambda 表达式？</h3>
<p>我们知道，对于一个 Java 变量，我们可以赋给一个值。</p>
<p><img src="1.png" alt=""></p>
<p>如果你想把一块代码赋给一个 Java 变量，应该怎么做呢？比如，我想把右边的代码块，赋值给一个叫做 blockOfCode 的 Java 变量</p>
<p><img src="2.png" alt=""></p>
<p>在 Java 8 之前这个是做不到的，但是 Java 8 问世之后，利用 Lambda 特性就可以做到了。</p>
<p><img src="3.png" alt=""></p>
<p>当然，这个并不是一个很简洁的写法，所以为了让这个赋值操作变得更加优雅，我们可以移除一些没有必要的声明。</p>
<p><img src="4.png" alt=""></p>
<p>这样，我们就非常优雅地把一块代码赋给了一个变量，而这块代码或者说这个被赋给一个变量的函数，就是一个 Lambda 表达式。但是这里仍然有一个问题，就是变量 blockOfCode 的类型应该是什么？</p>
<p>在 Java 8 里面，所有的 Lambda 的类型都是一个接口，而 Lambda 表达式本身，也就是那段代码，需要是这个接口的实现。这是理解 Lambda 的一个关键所在，简而言之就是，Lambda 表达式本身就是一个接口的实现。我们给上面的 blockOfCode 加上一个类型：</p>
<p><img src="5.png" alt=""></p>
<p>这种只有一个接口函数需要被实现的接口类型，我们叫它函数式接口。为了避免后来的人在这个接口中增加接口函数导致其有多个接口函数需要被实现，变成非函数接口，我们可以在这个上面加上一个声明 @FunctionalInterface，这样别人就无法在里面添加新的接口函数了</p>
<p><img src="6.png" alt=""></p>
<p>这样，我们就得到了一个完整的 Lambda 表达式声明：</p>
<p><img src="7.png" alt=""></p>
<h3 id="使用方法">使用方法</h3>
<ol>
<li>()：里面没有内容，可以看成是方法形式参数为空</li>
<li>-&gt;：用箭头指向后面要做的事情</li>
<li>{}：包含一段代码，可以看成是方法体的内容</li>
</ol>
<p>格式：(形式参数) -&gt; {代码块}</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">/* new Thread(new Runnable() &#123;</span></span><br><span class="line"><span class="comment">        @Override</span></span><br><span class="line"><span class="comment">        public void run() &#123;</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;123&quot;);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;).start();*/</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用前提：有一个接口，且接口中有且仅有一个抽象方法</p>
<p>注意：</p>
<ol>
<li>参数的类型可以省略，但是有多个参数的情况下，不能只省略一个</li>
<li>如果参数有且仅有一个，那么小括号可以省略</li>
<li>如果代码块的语句只有一条，可以省略大括号和分号。如果有 return，return 也可以省略</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Inter</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> ()-&gt; System.out.println(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(r).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt; System.out.println(<span class="string">&quot;456&quot;</span>)).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">(Inter inter)</span>&#123;</span><br><span class="line">    inter.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Lambda 表达式与匿名内部类的区别</strong></p>
<ol>
<li>匿名内部类：</li>
</ol>
<ul>
<li>编译之后，产生一个单独的.class 字节码文件</li>
<li>可以是接口，也可以是抽象类，还可以是具体类</li>
</ul>
<ol start="2">
<li>Lambda 表达式：</li>
</ol>
<ul>
<li>编译之后，没有一个单独的.class 字节码文件，对应的字节码文件会在运行时动态生成</li>
<li>只能是接口</li>
</ul>
<h3 id="使用案例">使用案例</h3>
<p><strong>Eatable</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Eatable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EatDemo</span> <span class="keyword">implements</span> <span class="title class_">Eatable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Eatable</span> <span class="variable">eatable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EatDemo</span>();</span><br><span class="line">    use(eatable);</span><br><span class="line">    use(<span class="keyword">new</span> <span class="title class_">Eatable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;456&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    use( () -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">(Eatable eatable)</span>&#123;</span><br><span class="line">    eatable.eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Add</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Add</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     use( (<span class="type">int</span> x,<span class="type">int</span> y) -&gt; &#123;</span><br><span class="line">         <span class="comment">//return x+y;</span></span><br><span class="line">         <span class="keyword">return</span> x-y;</span><br><span class="line">     &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">(Add add)</span>&#123;</span><br><span class="line">    System.out.println(add.add(<span class="number">10</span>,<span class="number">20</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法引用">方法引用</h2>
<p>方法引用是用来直接访问类或者实例的已经存在的方法或者构造方法。方法引用提供了一种引用而不执行方法的方式，它需要由兼容的函数式接口构成的目标类型上下文。计算时，方法引用会创建函数式接口的一个实例。当 Lambda 表达式中只是执行一个方法调用时，不用 Lambda 表达式，直接通过方法引用的形式可读性更高一些。方法引用是一种更简洁易懂的 Lambda 表达式。</p>
<h3 id="引用类方法">引用类方法</h3>
<p>类名:: 静态方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">show</span><span class="params">(String i)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    use(s-&gt; Integer.parseInt(s));</span><br><span class="line">    use(Integer::parseInt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">(Test3 test3)</span>&#123;</span><br><span class="line">    <span class="type">int</span> num= test3.show(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    System.out.println(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="引用对象实例方法">引用对象实例方法</h3>
<p>对象:: 成员方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Test4</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String s)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exp6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        use(s-&gt; System.out.println(s.toUpperCase()));</span><br><span class="line">        <span class="type">Exp6</span> <span class="variable">exp6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Exp6</span>();</span><br><span class="line">        use(exp6::Upper);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Upper</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        System.out.println(s.toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">(Test4 test4)</span>&#123;</span><br><span class="line">    	test4.show(<span class="string">&quot;dasf&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="引用类实例方法">引用类实例方法</h3>
<p>类名:: 成员方法</p>
<p>Lambda 表达式被类的实例方法替代的时候：第一个参数作为调用者，后面的参数全部传递给该方法作为参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Test5</span> &#123;</span><br><span class="line">    String <span class="title function_">mySubstring</span><span class="params">(String s,<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    use((s,a,b) -&gt; s.substring(a,b));</span><br><span class="line">    use(String::substring);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">(Test5 test5)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> test5.mySubstring(<span class="string">&quot;123456789&quot;</span>, <span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="引用构造器">引用构造器</h3>
<p>类名:: new</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    Student <span class="title function_">build</span><span class="params">(String name,<span class="type">int</span> age)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        use( (name, age) -&gt; <span class="keyword">new</span> <span class="title class_">Student</span>(name,age));</span><br><span class="line">        use(Student::<span class="keyword">new</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">(Test test)</span>&#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">da</span> <span class="operator">=</span> test.build(<span class="string">&quot;da&quot;</span>, <span class="number">13</span>);</span><br><span class="line">        System.out.println(da.getName()+<span class="string">&quot; &quot;</span>+ da.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>工作技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>Optional</title>
    <url>/blog/2025/01/01/Java/%E5%B7%A5%E4%BD%9C%E6%8A%80%E5%B7%A7/Optional/</url>
    <content><![CDATA[<h2 id="of">of</h2>
<p>通过一个非 null 的 value 来构造一个 Optional，返回的 Optional 包含了 value 这个值，对于该方法，传入的参数一定不能为 null，否则会抛出 NullPointerException</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Optional&lt;T&gt; <span class="title function_">of</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Optional</span>&lt;&gt;(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;String&gt; opt = Optional.of(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">System.out.println(opt.isPresent()); <span class="comment">// 输出：true</span></span><br></pre></td></tr></table></figure>
<h2 id="ofNullable">ofNullable</h2>
<p>与 of 的区别在于，传入的参数可以为 null，进行三目运算，判断传入的参数是否为 null，如果为 null 的话，返回的就是 Optional.empty()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Optional&lt;T&gt; <span class="title function_">ofNullable</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value == <span class="literal">null</span> ? empty() : of(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;String&gt; optOrNull = Optional.ofNullable(<span class="literal">null</span>);</span><br><span class="line">System.out.println(optOrNull.isPresent()); <span class="comment">// 输出：false</span></span><br></pre></td></tr></table></figure>
<h2 id="empty">empty</h2>
<p>用来构造一个空的 Optional，即该 Optional 中不包含值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Optional&lt;T&gt; <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Optional&lt;T&gt; t = (Optional&lt;T&gt;) EMPTY;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ifPresent">ifPresent</h2>
<p>如果 Optional 中有值，则对该值调用 consumer.accept，否则什么也不做</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPresent</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ifPresent</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; consumer)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="literal">null</span>)</span><br><span class="line">        consumer.accept(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;User&gt; user = Optional.ofNullable(getUserById(id));</span><br><span class="line">user.ifPresent(u -&gt; System.out.println(<span class="string">&quot;Username is: &quot;</span> + u.getUsername()));</span><br></pre></td></tr></table></figure>
<h2 id="orElse">orElse</h2>
<p>如果 Optional 中有值则将其返回，否则返回 orElse 方法传入的参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">orElse</span><span class="params">(T other)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value != <span class="literal">null</span> ? value : other;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> Optional.ofNullable(getUserById(id))</span><br><span class="line">        			.orElse(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">0</span>, <span class="string">&quot;Unknown&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;Username is: &quot;</span> + user.getUsername());</span><br></pre></td></tr></table></figure>
<h2 id="orElseGet">orElseGet</h2>
<p>与 orElse 方法的区别在于：orElseGet 方法传入的参数为一个 Supplier 接口的实现，当 Optional 中有值的时候，返回值；当 Optional 中没有值的时候，返回从该 Supplier 获得的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">orElseGet</span><span class="params">(Supplier&lt;? extends T&gt; ither)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value != <span class="literal">null</span> ? value : other.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> Optional.ofNullable(getUserById(id))</span><br><span class="line">                    .orElseGet(() -&gt; <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">0</span>, <span class="string">&quot;Unknown&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;Username is: &quot;</span> + user.getUsername());</span><br></pre></td></tr></table></figure>
<h2 id="orElseThrow">orElseThrow</h2>
<p>与 orElse 方法的区别在于：orElseThrow 方法当 Optional 中有值的时候，返回值；没有值的时候会抛出异常，抛出的异常由传入的 exceptionSupplier 提供</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;X <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt; T <span class="title function_">orElseThrow</span><span class="params">(Supplier&lt;? extends X&gt; exceptionSupplier)</span> <span class="keyword">throws</span> X &#123;</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> exceptionSupplier.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> Optional.ofNullable(getUserById(id))</span><br><span class="line">        			.orElseThrow(() -&gt; <span class="keyword">new</span> <span class="title class_">EntityNotFoundException</span>(<span class="string">&quot;id 为 &quot;</span> + id + <span class="string">&quot; 的用户没有找到&quot;</span>));</span><br></pre></td></tr></table></figure>
<h2 id="map">map</h2>
<p>如果当前 Optional 为 Optional.empty，则依旧返回 Optional.empty；否则返回一个新的 Optional，该 Optional 包含的是：函数 mapper 在以 value 作为输入时的输出值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; Optional&lt;U&gt; <span class="title function_">map</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends U&gt; mapper)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(mapper);</span><br><span class="line">    <span class="keyword">if</span> (!isPresent())&#123;</span><br><span class="line">        <span class="keyword">return</span> empty();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.ofNullable(mapper.apply(value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;String&gt; username = Optional.ofNullable(getUserById(id))</span><br><span class="line">                                    .map(user -&gt; user.getUsername())</span><br><span class="line">                                    .map(name -&gt; name.toLowerCase())</span><br><span class="line">                                    .map(name -&gt; name.replace(<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27; &#x27;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;Username is: &quot;</span> + username.orElse(<span class="string">&quot;Unknown&quot;</span>));</span><br></pre></td></tr></table></figure>
<h2 id="flatMap">flatMap</h2>
<p>与 map 方法的区别在于：map 方法参数中的函数 mapper 输出的是值，然后 map 方法会使用 Optional.ofNullable 将其包装为 Optional，而 flatMap 要求参数中的函数 mapper 输出的就是 Optional</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; Optional&lt;U&gt; <span class="title function_">flatMap</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, Optional&lt;U&gt;&gt; mapper)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(mapper);</span><br><span class="line">    <span class="keyword">if</span> (!isPresent())&#123;</span><br><span class="line">        <span class="keyword">return</span> empty();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.requireNonNull(mapper.apply(value));</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;String&gt; username = Optional.ofNullable(getUserById(id))</span><br><span class="line">                                    .flatMap(user -&gt; Optional.of(user.getUsername()))</span><br><span class="line">                                    .flatMap(name -&gt; Optional.of(name.toLowerCase()));</span><br><span class="line">System.out.println(<span class="string">&quot;Username is: &quot;</span> + username.orElse(<span class="string">&quot;Unknown&quot;</span>));</span><br></pre></td></tr></table></figure>
<h2 id="filter">filter</h2>
<p>filter 方法接受一个 Predicate 来对 Optional 中包含的值进行过滤，如果包含的值满足条件，那么还是返回这个 Optional，否则返回 Optional.empty</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Optional&lt;T&gt; <span class="title function_">filter</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(predicate);</span><br><span class="line">    <span class="keyword">if</span>(!isPresent()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> predicate.test(value) ? <span class="built_in">this</span> : empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;String&gt; username = Optional.ofNullable(getUserById(id))</span><br><span class="line">                                    .filter(user -&gt; user.getId() &lt; <span class="number">10</span>)</span><br><span class="line">                                    .map(user -&gt; user.getUsername());</span><br><span class="line">System.out.println(<span class="string">&quot;Username is: &quot;</span> + username.orElse(<span class="string">&quot;Unknown&quot;</span>));</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>工作技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>Stream流</title>
    <url>/blog/2024/10/20/Java/%E5%B7%A5%E4%BD%9C%E6%8A%80%E5%B7%A7/Stream%E6%B5%81/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="生成流">生成流</h2>
<h3 id="通过集合生成">通过集合生成</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// list 列表转换为 Stream</span></span><br><span class="line">List&lt;String&gt; strList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">strList.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">strList.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="type">Stream</span> <span class="variable">stream3</span> <span class="operator">=</span> strList.stream();</span><br><span class="line">stream3.forEach(System.out::println);</span><br><span class="line">System.out.println(<span class="string">&quot;=====================&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set 集合转换为 Stream</span></span><br><span class="line">Set&lt;String&gt; strSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">strSet.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">strSet.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="type">Stream</span> <span class="variable">stream4</span> <span class="operator">=</span> strSet.stream();</span><br><span class="line">stream4.forEach(System.out::println);</span><br><span class="line">System.out.println(<span class="string">&quot;=====================&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Map 集合转换为 Stream</span></span><br><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;a&quot;</span>, <span class="number">100</span>);</span><br><span class="line">map.put(<span class="string">&quot;b&quot;</span>, <span class="number">200</span>);</span><br><span class="line"><span class="type">Stream</span> <span class="variable">stream5</span> <span class="operator">=</span> map.entrySet().stream();</span><br><span class="line">stream5.forEach(System.out::println);</span><br><span class="line">System.out.println(<span class="string">&quot;=====================&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="通过数组生成">通过数组生成</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] intArr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">IntStream</span> <span class="variable">stream</span> <span class="operator">=</span> Arrays.stream(intArr);</span><br></pre></td></tr></table></figure>
<p>该方法生成的流是数值流（IntStream）而不是 Stream，使用数值流可以避免计算过程中拆箱装箱，提高性能</p>
<h3 id="通过值生成">通过值生成</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>通过 Stream 的 of 方法生成流，通过 Stream 的 empty 方法可以生成一个空流</p>
<h3 id="通过文件生成">通过文件生成</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; lines = Files.lines(Paths.get(<span class="string">&quot;data.txt&quot;</span>), Charset.defaultCharset());</span><br></pre></td></tr></table></figure>
<p>通过 Files.line 方法得到一个流，并且得到的每个流是给定文件中的一行</p>
<h3 id="通过函数生成">通过函数生成</h3>
<ol>
<li>iterate</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.iterate(<span class="number">0</span>, n -&gt; n + <span class="number">2</span>).limit(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>iterate 方法接受两个参数，第一个为初始值，第二个为进行的函数操作，因为 iterate 生成的流为无限流，通过 limit 方法对流进行了截断，只生成 5 个偶数</p>
<ol start="2">
<li>generate</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Double&gt; stream = Stream.generate(Math::random).limit(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>generate 方法接受一个参数，方法参数类型为 Supplier，由他为流提供值，generate 生成的流也是无限流，因此通过 limit 对流进行了截断</p>
<h2 id="中间操作">中间操作</h2>
<h3 id="filter-条件筛选">filter 条件筛选</h3>
<p>返回结果生成新的流中只包含满足筛选条件的数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">Stream&lt;Integer&gt; stream = integerList.stream().filter(i -&gt; i &gt; <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<h3 id="distinct-去除重复元素">distinct 去除重复元素</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">Stream&lt;Integer&gt; stream = integerList.stream().distinct();</span><br></pre></td></tr></table></figure>
<h3 id="limit-返回指定流个数">limit 返回指定流个数</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>); </span><br><span class="line">Stream&lt;Integer&gt; stream = integerList.stream().limit(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>通过 limit 方法指定返回流的个数，limit 的参数值必须 &gt;= 0，否则将会抛出异常</p>
<h3 id="skip-跳过流中的元素">skip 跳过流中的元素</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">Stream&lt;Integer&gt; stream = integerList.stream().skip(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>通过 skip 方法跳过流中的元素，skip 的参数值必须 &gt;= 0，否则将会抛出异常</p>
<h3 id="map-流映射">map 流映射</h3>
<p>流映射就是将接受的元素映射成另外一个元素，通过 map 方法可以完成映射</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; stringList = Arrays.asList(<span class="string">&quot;Java 8&quot;</span>, <span class="string">&quot;Lambdas&quot;</span>,  <span class="string">&quot;In&quot;</span>, <span class="string">&quot;Action&quot;</span>);</span><br><span class="line">Stream&lt;Integer&gt; stream = stringList.stream().map(String::length);</span><br></pre></td></tr></table></figure>
<p><strong>常用方法</strong></p>
<ol>
<li>
<p>mapToDouble</p>
</li>
<li>
<p>mapToInt</p>
</li>
<li>
<p>mapToLong</p>
</li>
</ol>
<p><strong>使用案例</strong></p>
<ol>
<li>当出现相同的 key 时，解决方法：取前面 value 的值，或者取后面放入的 value 值，则覆盖先前的 value 值</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Long, String&gt; map = userList.stream()</span><br><span class="line">        .collect(Collectors.toMap(User::getId, User::getUsername, (v1, v2) -&gt; v1));</span><br><span class="line">Map&lt;Long, String&gt; map = userList.stream()</span><br><span class="line">        .collect(Collectors.toMap(User::getId, User::getUsername, (v1, v2) -&gt; v2));</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>对相同 key 值的数据进行合并</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 处理 itemList 合并相同物料累加数量</span></span><br><span class="line">Map&lt;Long, Integer&gt; map = itemList.stream().collect(Collectors.toMap(StocksComponentsItem::getStocksId, StocksComponentsItem::getCount, (e1, e2) -&gt; e1 + e2));       </span><br></pre></td></tr></table></figure>
<ol start="3">
<li>获取 TreeMap，根据 key 值进行排序</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Long, String&gt; treeMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">TreeMap&lt;Long, String&gt; map = treeMap.entrySet().stream()</span><br><span class="line">.collect(Collectors.toMap(entry -&gt; entry.getKey(), entry -&gt; entry.getValue(), </span><br><span class="line">                          (v1, v2) -&gt; v1, TreeMap::<span class="keyword">new</span>));</span><br></pre></td></tr></table></figure>
<h3 id="flatMap-流转换">flatMap 流转换</h3>
<p>扁平化映射，将多个 stream 连接成一个 stream，这个操作是针对类似多维数组的，比如集合里面包含集合，相当于降维作用</p>
<p>例如：如果想要从 List &lt; StdCls &gt; 中取出学生列表，需要取出每个班级的学生 List，再 for 循环调用 List.addAll()方法把所有班级的学生 List 到一个新的总和 List 中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StdCls</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String clsNo;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Student&gt; studentList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 map 映射后会变成 List &lt;List&lt;Student&gt; &gt;，若使用 flatMap 会进行扁平化处理，从而将 List 嵌套 List 用 stream 合并成一个 List</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; nameList = stdClsList.stream()</span><br><span class="line">                        .map(StdCls::getStudentList)</span><br><span class="line">                        .flatMap(Collection::stream) <span class="comment">// 多个集合 List 合并</span></span><br><span class="line">                        .map(Student::getName).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<h3 id="sorted-排序">sorted 排序</h3>
<p>将流中的元素按照自然排序方式进行排序</p>
<ol>
<li>sorted()：自然排序，流中元素需实现 Comparable 接口</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;ff&quot;</span>, <span class="string">&quot;dd&quot;</span>);</span><br><span class="line"><span class="comment">//String 类自身已实现 Compareable 接口</span></span><br><span class="line">list.stream().sorted().forEach(System.out::println);<span class="comment">// aa dd ff</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>sorted(Comparator com)：定制排序，自定义 Comparator 排序器</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;aa&quot;</span>, <span class="number">10</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;bb&quot;</span>, <span class="number">20</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;aa&quot;</span>, <span class="number">30</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;dd&quot;</span>, <span class="number">40</span>);</span><br><span class="line">List&lt;Student&gt; studentList = Arrays.asList(s1, s2, s3, s4);</span><br><span class="line">  </span><br><span class="line"><span class="comment">//自定义排序：先按姓名升序，姓名相同则按年龄升序</span></span><br><span class="line">studentList.stream().sorted(</span><br><span class="line">    (o1, o2) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (o1.getName().equals(o2.getName())) &#123;</span><br><span class="line">        	<span class="keyword">return</span> o1.getAge() - o2.getAge();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	<span class="keyword">return</span> o1.getName().compareTo(o2.getName());</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">).forEach(System.out::println);　</span><br></pre></td></tr></table></figure>
<h3 id="peek-消费">peek 消费</h3>
<p>对流中每个元素执行操作，并返回一个新的流，返回的流还是包含原来流中的元素。</p>
<p>如同于 map，能得到流中的每一个元素，但 map 接收的是一个 Function 表达式，有返回值；而 peek 接收的是 Consumer 表达式，没有返回值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;aa&quot;</span>, <span class="number">10</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;bb&quot;</span>, <span class="number">20</span>);</span><br><span class="line">List&lt;Student&gt; studentList = Arrays.asList(s1, s2);</span><br><span class="line">  </span><br><span class="line">studentList.stream().peek(o -&gt; o.setAge(<span class="number">100</span>)).forEach(System.out::println);</span><br><span class="line">  </span><br><span class="line"><span class="comment">//结果：</span></span><br><span class="line">Student&#123;name=<span class="string">&#x27;aa&#x27;</span>, age=<span class="number">100</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;bb&#x27;</span>, age=<span class="number">100</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="concat-流合并">concat 流合并</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个集合，存储多个字符串元素 </span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;心如音&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;流老蛋&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;王值&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;李尔&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;张新敏&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;张天坤&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//需求 1：取前 4 个数据组成一个流 </span></span><br><span class="line">Stream&lt;String&gt; s1 = list.stream().limit(<span class="number">4</span>);</span><br><span class="line"><span class="comment">//需求 2：跳过 2 个数据组成一个流 </span></span><br><span class="line">Stream&lt;String&gt; s2 = list.stream().skip(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//需求 3：合并需求 1 和需求 2 得到的流，并把结果在控制台输出 </span></span><br><span class="line">Stream.concat(s1,s2).forEach(System.out::println); </span><br><span class="line"><span class="comment">//需求 4：合并需求 1 和需求 2 得到的流，并把结果在控制台输出，要求字符串元素不能重复 </span></span><br><span class="line">Stream.concat(s1,s2).distinct().forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<h2 id="终端操作">终端操作</h2>
<h3 id="match-元素匹配">match 元素匹配</h3>
<ol>
<li>allMatch 匹配所有</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> integerList.stream().allMatch(i -&gt; i &gt; <span class="number">3</span>);</span><br><span class="line"><span class="keyword">if</span> (result) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;值都大于3&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>anyMatch 匹配其中一个</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> integerList.stream().allMatch(i -&gt; i &gt; <span class="number">3</span>);</span><br><span class="line"><span class="keyword">if</span> (result) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;存在大于3的值&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>noneMatch 全部不匹配</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> integerList.stream().allMatch(i -&gt; i &gt; <span class="number">3</span>);</span><br><span class="line"><span class="keyword">if</span> (result) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;值都小于3&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="count-统计元素个数">count 统计元素个数</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> integerList.stream().filter(e -&gt; e &gt; <span class="number">3</span>).count();</span><br></pre></td></tr></table></figure>
<h3 id="find-查找元素">find 查找元素</h3>
<ol>
<li>findFirst：查找第一个</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">Optional&lt;Integer&gt; result = integerList.stream().filter(i -&gt; i &gt; <span class="number">3</span>).findFirst();</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>findAny：随机查找一个</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">Optional&lt;Integer&gt; result = integerList.stream().filter(i -&gt; i &gt; <span class="number">3</span>).findAny();</span><br></pre></td></tr></table></figure>
<h3 id="min、max-获取最值">min、max 获取最值</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">Optional&lt;Integer&gt; min = integerList.stream().min(Integer::compareTo);</span><br><span class="line">System.out.println(min.get());</span><br><span class="line">Optional&lt;Integer&gt; max = integerList.stream().max(Integer::compareTo);</span><br><span class="line">System.out.println(max.get());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 mapToInt</span></span><br><span class="line"><span class="type">OptionalInt</span> <span class="variable">min1</span> <span class="operator">=</span> integerList.stream().mapToInt(e -&gt; e).min();</span><br><span class="line">System.out.println(min1.getAsInt());</span><br><span class="line"><span class="type">OptionalInt</span> <span class="variable">max1</span> <span class="operator">=</span> integerList.stream().mapToInt(e -&gt; e).max();</span><br><span class="line">System.out.println(max1.getAsInt());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象使用，例如计算对象 Dish 中的 calories 值</span></span><br><span class="line">Optional&lt;Integer&gt; min = menu.stream().map(Dish::getCalories).min(Integer::compareTo);</span><br><span class="line">Optional&lt;Integer&gt; max = menu.stream().map(Dish::getCalories).max(Integer::compareTo);</span><br><span class="line"><span class="type">OptionalInt</span> <span class="variable">min</span> <span class="operator">=</span> menu.stream().mapToInt(Dish::getCalories).min();</span><br><span class="line"><span class="type">OptionalInt</span> <span class="variable">max</span> <span class="operator">=</span> menu.stream().mapToInt(Dish::getCalories).max();</span><br></pre></td></tr></table></figure>
<h3 id="reduce-元素组合">reduce 元素组合</h3>
<p>把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。从这个意义上说，字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reduce()：字符串拼接</span></span><br><span class="line"><span class="type">String</span> <span class="variable">reduceStr1</span> <span class="operator">=</span> Stream.of(<span class="string">&quot;ma&quot;</span>, <span class="string">&quot;zhi&quot;</span>, <span class="string">&quot;chu&quot;</span>).reduce(<span class="string">&quot;&quot;</span>, String::concat);</span><br><span class="line">System.out.println(reduceStr1);</span><br><span class="line"><span class="type">String</span> <span class="variable">reduceStr2</span> <span class="operator">=</span> Stream.of(<span class="string">&quot;ma&quot;</span>, <span class="string">&quot;zhi&quot;</span>, <span class="string">&quot;chu&quot;</span>).reduce(<span class="string">&quot;&quot;</span>, (x,y)-&gt;x+y);</span><br><span class="line">System.out.println(reduceStr2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// reduce()：求和，identity(起始值)为 0</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">total1</span> <span class="operator">=</span> Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>).reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">System.out.println(total1);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">total2</span> <span class="operator">=</span> Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>).reduce(<span class="number">0</span>, (x, y) -&gt; x +y);</span><br><span class="line">System.out.println(total2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求和，sumValue = 10, 无起始值</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">total3</span> <span class="operator">=</span> Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).reduce(Integer::sum).get();</span><br><span class="line">System.out.println(total3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// reduce()：求最小值</span></span><br><span class="line"><span class="type">double</span> <span class="variable">minValue</span> <span class="operator">=</span> Stream.of(-<span class="number">1.1</span>, <span class="number">8.8</span>, -<span class="number">2.2</span>, -<span class="number">6.6</span>).reduce(Double.MAX_VALUE, Double::min);</span><br><span class="line">System.out.println(minValue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象使用，例如计算对象 Dish 中的 calories 值</span></span><br><span class="line">Optional&lt;Integer&gt; min = menu.stream().map(Dish::getCalories).reduce(Integer::min);</span><br><span class="line">Optional&lt;Integer&gt; max = menu.stream().map(Dish::getCalories).reduce(Integer::max);</span><br></pre></td></tr></table></figure>
<h3 id="求不同值">求不同值</h3>
<ol>
<li>summingInt：求和</li>
<li>sum：求和</li>
<li>averagingInt：求平均值</li>
<li>summarizingInt：同时求总和、平均值、最大值、最小值</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> menu.stream().collect(Collectors.summingInt(Dish::getCalories));</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> menu.stream().map(Dish::getCalories).reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> menu.stream().mapToInt(Dish::getCalories).sum();</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="variable">average</span> <span class="operator">=</span> menu.stream().collect(Collectors.averagingInt(Dish::getCalories));</span><br><span class="line"></span><br><span class="line"><span class="type">IntSummaryStatistics</span> <span class="variable">intSummaryStatistics</span> <span class="operator">=</span> menu.stream().collect(Collectors.summarizingInt(Dish::getCalories));</span><br><span class="line"><span class="type">double</span> <span class="variable">average</span> <span class="operator">=</span> intSummaryStatistics.getAverage();  <span class="comment">//获取平均值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> intSummaryStatistics.getMin();  <span class="comment">//获取最小值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> intSummaryStatistics.getMax();  <span class="comment">//获取最大值</span></span><br><span class="line"><span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> intSummaryStatistics.getSum();  <span class="comment">//获取总和</span></span><br></pre></td></tr></table></figure>
<h3 id="foreach-元素遍历">foreach 元素遍历</h3>
<p>遍历流中的每一个元素，按照指定的方法执行，执行顺序不一定按照流的顺序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// foreach: 遍历流中每一个元素, 执行顺序不一定按照流的顺序</span></span><br><span class="line">integerList.stream().forEach(System.out::println);</span><br><span class="line"><span class="comment">// .parallel()表示创建一个并行流</span></span><br><span class="line">Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>).parallel().forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<h3 id="toArray-返回数组">toArray 返回数组</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// toArray()：将流中的元素放入到一个数组中</span></span><br><span class="line">String[] strings = Stream.of(<span class="string">&quot;ma&quot;</span>, <span class="string">&quot;zhi&quot;</span>, <span class="string">&quot;chu&quot;</span>).toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">System.out.println(Arrays.toString(strings));</span><br></pre></td></tr></table></figure>
<h3 id="collect-返回集合">collect 返回集合</h3>
<h4 id="minBy-maxBy-获取最值">minBy/maxBy 获取最值</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;Integer&gt; min = menu.stream().map(Dish::getCalories).collect(Collectors.minBy(Integer::compareTo));</span><br><span class="line">Optional&lt;Integer&gt; max = menu.stream().map(Dish::getCalories).collect(Collectors.maxBy(Integer::compareTo));</span><br></pre></td></tr></table></figure>
<h4 id="toMap-获取属性映射">toMap 获取属性映射</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; strings = menu.stream().map(Dish::getName).collect(Collectors.toList());</span><br><span class="line">Set&lt;String&gt; sets = menu.stream().map(Dish::getName).collect(Collectors.toSet());</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取属性和对象本身</span></span><br><span class="line">Map&lt;Integer, House&gt; houseMap = houses.stream().collect(Collectors.toMap(House::getOwnerid, o -&gt; o));</span><br><span class="line">Map&lt;Integer, House&gt; houseMap1 = houses.stream().collect(Collectors.toMap(House::getOwnerid,  Function.identity()));</span><br><span class="line"></span><br><span class="line"><span class="comment">//出现重复 id 时，取前面 value 的值，获取取后面放入的 value 值，则覆盖先前的 value 值</span></span><br><span class="line">houses.stream().collect(Collectors.toMap(House::getOwnerid, House::getHousename,(v1,v2)-&gt;v2));</span><br><span class="line">houses.stream().collect(Collectors.toMap(House::getOwnerid, House::getHousename,(v1,v2)-&gt;v1));</span><br></pre></td></tr></table></figure>
<p>常用方法：</p>
<ol>
<li>Collectors.toList()</li>
<li>Collectors.toMap()</li>
<li>Collectors.toSet()</li>
<li>Collectors.toCollection()</li>
<li>Collectors.toConcurrentMap()</li>
</ol>
<h4 id="counting-统计元素个数">counting 统计元素个数</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> integerList.stream().count();</span><br><span class="line"><span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> integerList.stream().collect(Collectors.counting());</span><br></pre></td></tr></table></figure>
<h4 id="joining-拼接流中元素">joining 拼接流中元素</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> menu.stream().map(Dish::getName).collect(Collectors.joining(<span class="string">&quot;, &quot;</span>));</span><br></pre></td></tr></table></figure>
<p>默认如果不通过 map 方法进行映射处理拼接的 toString 方法返回的字符串，joining 的方法参数为元素的分界符，如果不指定生成的字符串将是一串的</p>
<h4 id="groupingBy-元素分组">groupingBy 元素分组</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按 type 字段分组</span></span><br><span class="line">Map&lt;Type, List&lt;Dish&gt;&gt; result = dishList.stream().collect(Collectors.groupingBy(Dish::getType));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按 type 字段分组后，再按 calories 字段分组</span></span><br><span class="line">Map&lt;String, Map&lt;Integer, List&lt;Dish&gt;&gt;&gt; result = menu.stream().collect(Collectors.groupingBy(Dish::getName,</span><br><span class="line">                Collectors.groupingBy(Dish::getCalories)));</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 源数据</span></span><br><span class="line">ArrayList&lt;GateScanCodeRecord&gt; objects = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">objects.add(<span class="keyword">new</span> <span class="title class_">GateScanCodeRecord</span>().setMonth(<span class="string">&quot;2020-07&quot;</span>).setDay(<span class="string">&quot;2020-07-12&quot;</span>));</span><br><span class="line">objects.add(<span class="keyword">new</span> <span class="title class_">GateScanCodeRecord</span>().setMonth(<span class="string">&quot;2020-06&quot;</span>).setDay(<span class="string">&quot;2020-06-14&quot;</span>));</span><br><span class="line">objects.add(<span class="keyword">new</span> <span class="title class_">GateScanCodeRecord</span>().setMonth(<span class="string">&quot;2020-06&quot;</span>).setDay(<span class="string">&quot;2020-06-12&quot;</span>));</span><br><span class="line">objects.add(<span class="keyword">new</span> <span class="title class_">GateScanCodeRecord</span>().setMonth(<span class="string">&quot;2020-05&quot;</span>).setDay(<span class="string">&quot;2020-05-17&quot;</span>));</span><br><span class="line">objects.add(<span class="keyword">new</span> <span class="title class_">GateScanCodeRecord</span>().setMonth(<span class="string">&quot;2020-05&quot;</span>).setDay(<span class="string">&quot;2020-05-12&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按月份分组有序</span></span><br><span class="line">TreeMap&lt;String, List&lt;GateScanCodeRecord&gt;&gt; collect2 = objects.parallelStream().collect(Collectors.groupingBy(GateScanCodeRecord::getMonth, TreeMap::<span class="keyword">new</span>, Collectors.toList()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义分组有序</span></span><br><span class="line">TreeMap&lt;String, List&lt;GateScanCodeRecord&gt;&gt; collect3 =</span><br><span class="line">            objects.parallelStream().collect(Collectors.groupingBy(GateScanCodeRecord::getMonth,</span><br><span class="line">            () -&gt; <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;((o1, o2) -&gt; Math.toIntExact(Long.parseLong(o2.replaceAll(<span class="string">&quot;-&quot;</span>,<span class="string">&quot;&quot;</span>)) - Long.parseLong(o1.replaceAll(<span class="string">&quot;-&quot;</span>,<span class="string">&quot;&quot;</span>)))),</span><br><span class="line">            Collectors.toList()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两层排序(按月分组排序, 月下的数据按天分组并排序)</span></span><br><span class="line">TreeMap&lt;String, TreeMap&lt;String, List&lt;GateScanCodeRecord&gt;&gt;&gt; collect = objects.stream()</span><br><span class="line">            .collect(Collectors.groupingBy(GateScanCodeRecord::getMonth,</span><br><span class="line">             () -&gt; <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;((o1, o2) -&gt; Math.toIntExact(Long.parseLong(o2.replaceAll(<span class="string">&quot;-&quot;</span>,<span class="string">&quot;&quot;</span>)) - Long.parseLong(o1.replaceAll(<span class="string">&quot;-&quot;</span>,<span class="string">&quot;&quot;</span>)))),</span><br><span class="line">             Collectors.groupingBy(GateScanCodeRecord::getDay,</span><br><span class="line">             () -&gt; <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;((o1, o2) -&gt; Math.toIntExact(Long.parseLong(o2.replaceAll(<span class="string">&quot;-&quot;</span>,<span class="string">&quot;&quot;</span>)) - Long.parseLong(o1.replaceAll(<span class="string">&quot;-&quot;</span>,<span class="string">&quot;&quot;</span>)))),</span><br><span class="line">             Collectors.toList()))</span><br><span class="line">            );</span><br></pre></td></tr></table></figure>
<h4 id="partitioningBy-元素分区">partitioningBy 元素分区</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Boolean, List&lt;Dish&gt;&gt; result = menu.stream().collect(Collectors.partitioningBy(Dish::isVegetarian));</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">Map&lt;Boolean, List&lt;Dish&gt;&gt; result = menu.stream().collect(Collectors.groupingBy(Dish::isVegetarian));</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">Map&lt;Boolean, List&lt;Integer&gt;&gt; result = integerList.stream().collect(Collectors.partitioningBy(i -&gt; i &lt; <span class="number">3</span>));</span><br></pre></td></tr></table></figure>
<p><strong>groupingBy 和 partitioningBy 区别</strong></p>
<ol>
<li>partitioningBy：将一组数据分为两组，key 为 ture 和 false 的两组数据（仅能分为两组）</li>
<li>groupingBy：将一组数据按照指定的类型分为 N 组，key 为泛型</li>
</ol>
<h4 id="mapping-获取属性映射集合">mapping 获取属性映射集合</h4>
<p>对分组之后的对象集合转换为对象的某个属性的集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Person&gt; personList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 四个参与测试的小伙伴</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">tom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;tom&quot;</span>, <span class="string">&quot;男&quot;</span>, <span class="number">11</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">amy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;amy&quot;</span>, <span class="string">&quot;女&quot;</span>, <span class="number">13</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">ali</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;ali&quot;</span>, <span class="string">&quot;男&quot;</span>, <span class="number">12</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">daming</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;daming&quot;</span>, <span class="string">&quot;男&quot;</span>, <span class="number">13</span>);</span><br><span class="line">    personList.add(tom);</span><br><span class="line">    personList.add(amy);</span><br><span class="line">    personList.add(ali);</span><br><span class="line">    personList.add(daming);</span><br><span class="line">    <span class="comment">// 对小伙伴按照性别 age 进行分组</span></span><br><span class="line">    Map&lt;String, Set&lt;String&gt;&gt; resultMap = personList.stream().collect(Collectors.groupingBy(Person::getSex, Collectors.mapping(Person::getName, Collectors.toSet())));</span><br><span class="line">    System.out.println(resultMap.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="collectingAndThen-归纳处理">collectingAndThen 归纳处理</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按, 拼接成字符串后全部转为大写</span></span><br><span class="line"><span class="type">String</span> <span class="variable">collect</span> <span class="operator">=</span> Stream.of(<span class="string">&quot;ma&quot;</span>, <span class="string">&quot;zhi&quot;</span>, <span class="string">&quot;chu&quot;</span>).collect(Collectors.collectingAndThen(Collectors.joining(<span class="string">&quot;,&quot;</span>),</span><br><span class="line">        String::toUpperCase));</span><br><span class="line">System.out.println(collect);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>工作技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>函数式接口</title>
    <url>/blog/2025/01/21/Java/%E5%B7%A5%E4%BD%9C%E6%8A%80%E5%B7%A7/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h2 id="函数式接口">函数式接口</h2>
<p>特点：有且仅有一个抽象方法的接口</p>
<p>检测是否为函数式接口：@FunctionalInterface，放在接口定义的上方，如果接口是函数式接口，编译通过，不是则编译失败</p>
<p>@FunctionalInterface是可选的，只要保证满足函数式接口定义的条件，也是函数式接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyInter</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>如果方法的参数是一个函数式接口，可以使用Lambda表达式作为参数传递</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    startThread(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;启动&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    startThread(()-&gt; System.out.println(Thread.currentThread().getName()+<span class="string">&quot;启动&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">startThread</span><span class="params">(Runnable r)</span>&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(r).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>如果方法的返回值是一个函数式接口，可以使用Lambda表达式作为结果返回</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ArrayList&lt;String&gt;arrayList=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    arrayList.add(<span class="string">&quot;das&quot;</span>);</span><br><span class="line">    arrayList.add(<span class="string">&quot;fdfs&quot;</span>);</span><br><span class="line">    arrayList.add(<span class="string">&quot;vcxvv&quot;</span>);</span><br><span class="line">    Collections.sort(arrayList,getComparator());</span><br><span class="line">    System.out.println(arrayList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Comparator&lt;String&gt; <span class="title function_">getComparator</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">/* Comparator&lt;String&gt;comparator=new Comparator&lt;String&gt;() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public int compare(String o1, String o2) &#123;</span></span><br><span class="line"><span class="comment">                return o1.length()-o2.length();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;;</span></span><br><span class="line"><span class="comment">        return comparator;*/</span></span><br><span class="line">    <span class="comment">/* return new Comparator&lt;String&gt;() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public int compare(String o1, String o2) &#123;</span></span><br><span class="line"><span class="comment">                return o1.length()-o2.length();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;;*/</span></span><br><span class="line">    <span class="keyword">return</span> (s1,s2)-&gt; s1.length()-s2.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Comparator（比较器）">Comparator（比较器）</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compare</span><span class="params">(T o1, T o2)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);</span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Doe&quot;</span>);</span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Wonderland&quot;</span>);</span><br><span class="line">comparator.compare(p1, p2);             <span class="comment">// &gt; 0</span></span><br><span class="line">comparator.reversed().compare(p1, p2);  <span class="comment">// &lt; 0</span></span><br></pre></td></tr></table></figure>
<h2 id="Supplier（供应）">Supplier（供应）</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Supplier</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 获取结果</span></span><br><span class="line">    T <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> getString(() -&gt; <span class="string">&quot;da&quot;</span>);</span><br><span class="line">    System.out.println(s);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> getInteger(() -&gt; <span class="number">123</span>);</span><br><span class="line">    System.out.println(integer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getString</span><span class="params">(Supplier&lt;String&gt; supplier)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> supplier.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Integer <span class="title function_">getInteger</span><span class="params">(Supplier&lt;Integer&gt; supplier)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> supplier.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Consumer（消费）">Consumer（消费）</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Consumer</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 对给定的参数执行此操作</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回一个组合的Consumer，依次执行此操作，然后执行after操作</span></span><br><span class="line">	<span class="keyword">default</span> Consumer&lt;T&gt; <span class="title function_">andThen</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; after)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    operatorString(<span class="string">&quot;da&quot;</span>, s-&gt; System.out.println(s));</span><br><span class="line">    operatorString(<span class="string">&quot;da&quot;</span>, System.out::println);</span><br><span class="line">    System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">    operatorString(<span class="string">&quot;da&quot;</span>, s-&gt; System.out.println(s), s-&gt; System.out.println(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s).reverse().toString()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">operatorString</span><span class="params">(String s, Consumer&lt;String&gt;consumer)</span> &#123;</span><br><span class="line">    consumer.accept(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">operatorString</span><span class="params">(String s, Consumer&lt;String&gt;consumer, Consumer&lt;String&gt;consumer1)</span> &#123;</span><br><span class="line">    <span class="comment">// consumer.accept(s);</span></span><br><span class="line">    <span class="comment">// consumer1.accept(s);</span></span><br><span class="line">    <span class="comment">// 等于下面的操作</span></span><br><span class="line">    consumer.andThen(consumer1).accept(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Predicate（断言）">Predicate（断言）</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Predicate</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 对给定的参数进行判断（判断逻辑由Lambda表达式实现），返回一个布尔值</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(T t)</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 返回一个组合判断，对应短路与</span></span><br><span class="line">    <span class="keyword">default</span> Predicate&lt;T&gt; <span class="title function_">and</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; other)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) &amp;&amp; other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个逻辑的否定，对应逻辑非</span></span><br><span class="line">    <span class="keyword">default</span> Predicate&lt;T&gt; <span class="title function_">negate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; !test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个组合判断，对应短路或</span></span><br><span class="line">    <span class="keyword">default</span> Predicate&lt;T&gt; <span class="title function_">or</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; other)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) || other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; Predicate&lt;T&gt; <span class="title function_">isEqual</span><span class="params">(Object targetRef)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">null</span> == targetRef)</span><br><span class="line">                ? Objects::isNull</span><br><span class="line">                : object -&gt; targetRef.equals(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="type">boolean</span> <span class="variable">cxz</span> <span class="operator">=</span> checkString(<span class="string">&quot;cxz&quot;</span>, s -&gt; s.length() &gt; <span class="number">8</span>);</span><br><span class="line">     System.out.println(cxz);</span><br><span class="line">     <span class="type">boolean</span> <span class="variable">ccxz</span> <span class="operator">=</span> checkString(<span class="string">&quot;ccxz&quot;</span>, s -&gt; s.length() &gt; <span class="number">3</span>, s -&gt; s.length() &lt; <span class="number">11</span>);</span><br><span class="line">     System.out.println(ccxz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkString</span><span class="params">(String s, Predicate&lt;String&gt;predicate)</span>&#123;</span><br><span class="line">    <span class="comment">//return predicate.test(s);</span></span><br><span class="line">    <span class="keyword">return</span> predicate.negate().test(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkString</span><span class="params">(String s, Predicate&lt;String&gt; predicate, Predicate&lt;String&gt; predicate1)</span>&#123;</span><br><span class="line">    <span class="comment">/*boolean test = predicate.test(s);</span></span><br><span class="line"><span class="comment">        boolean test1 = predicate1.test(s);</span></span><br><span class="line"><span class="comment">        return test&amp;&amp;test1;*/</span></span><br><span class="line">    <span class="comment">//return predicate.and(predicate1).test(s);</span></span><br><span class="line">    <span class="keyword">return</span> predicate.or(predicate1).test(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Function（功能）">Function（功能）</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Function</span>&lt;T, R&gt; &#123;</span><br><span class="line">    R <span class="title function_">apply</span><span class="params">(T t)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; Function&lt;V, R&gt; <span class="title function_">compose</span><span class="params">(Function&lt;? <span class="built_in">super</span> V, ? extends T&gt; before)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(before);</span><br><span class="line">        <span class="keyword">return</span> (V v) -&gt; apply(before.apply(v));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; Function&lt;T, V&gt; <span class="title function_">andThen</span><span class="params">(Function&lt;? <span class="built_in">super</span> R, ? extends V&gt; after)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; after.apply(apply(t));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; Function&lt;T, T&gt; <span class="title function_">identity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t -&gt; t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    convert(<span class="string">&quot;100&quot;</span>, s-&gt; Integer.parseInt(s));</span><br><span class="line">    convert(<span class="string">&quot;100&quot;</span>, Integer::parseInt);</span><br><span class="line">    convert(<span class="number">100</span>, i-&gt; String.valueOf(i+<span class="number">100</span>));</span><br><span class="line">    convert(<span class="string">&quot;100&quot;</span>, s-&gt; Integer.parseInt(s), s-&gt; String.valueOf(s+<span class="number">100</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">convert</span><span class="params">(String s, Function&lt;String,Integer&gt; function)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">apply</span> <span class="operator">=</span> function.apply(s);</span><br><span class="line">    System.out.println(apply);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">convert</span><span class="params">(<span class="type">int</span> i, Function&lt;Integer,String&gt; function)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">apply</span> <span class="operator">=</span> function.apply(i);</span><br><span class="line">    System.out.println(apply);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">convert</span><span class="params">(String s, Function&lt;String,Integer&gt; function, Function&lt;Integer,String&gt; function1)</span> &#123;</span><br><span class="line">    <span class="comment">// Integer apply = function.apply(s);</span></span><br><span class="line">    <span class="comment">// String apply1 = function1.apply(apply);</span></span><br><span class="line">    <span class="comment">// System.out.println(apply1);</span></span><br><span class="line">    <span class="comment">// 等于下面的操作</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">apply</span> <span class="operator">=</span> function.andThen(function1).apply(s);</span><br><span class="line">    System.out.println(apply);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>工作技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux（1-目录文件操作）</title>
    <url>/blog/2024/11/17/%E8%BF%90%E7%BB%B4/Linux/Linux%EF%BC%881-%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%EF%BC%89/</url>
    <content><![CDATA[<h2 id="Linux-系统目录结构图">Linux 系统目录结构图</h2>
<p><img src="1.jpg" alt=""></p>
<ol>
<li>/root：该目录为系统管理员的用户主目录</li>
<li>/bin（Binary）：存放着最经常使用的命令</li>
<li>/boot：存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件</li>
<li>/dev（Device）：存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的</li>
<li>/ect：存放所有的系统管理所需要的配置文件和子目录</li>
<li>/home：用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账户命名的</li>
<li>/var：存放着在不断扩充着的东西，习惯将那些经常被修改的目录放在这个目录下，包括各种日志文件</li>
<li>/lib：存放着系统最基本的动态连接共享库，其作用类似于 Windows 的 DLL 文件，几乎所有的应用程序都需要用到这些共享库</li>
<li>/usr：用户的很多应用程序和文件都放在这个目录下，类似于 Windows 下的 program files 目录</li>
<li>/usr/bin：系统用户使用的应用程序</li>
<li>/usr/sbin：超级用户使用的比较高级的管理程序和系统守护程序</li>
<li>/usr/src：内核源代码默认的放置目录</li>
<li>/media：Linux 系统会自动识别一些设备，例如 U 盘、光驱等，当识别后，Linux 会把识别的设备挂载到这个目录下</li>
<li>/opt：给主机额外安装软件所摆放的目录</li>
<li>/proc：一个虚拟的目录，是系统内存的映射，可以通过直接访问这个目录来获取系统信息</li>
<li>/sbin（s 指 Super User）：存放的是系统管理员使用的系统管理程序</li>
<li>/srv：存放一些服务启动之后需要提取的数据</li>
<li>/tmp：用来存放一些临时文件</li>
</ol>
<h2 id="目录操作命令">目录操作命令</h2>
<h3 id="cd：目录切换">cd：目录切换</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd / ：切换到根目录</span><br><span class="line">cd /usr：切换到根目录下的usr目录</span><br><span class="line">cd ..：切换到上一级目录</span><br><span class="line">cd ~：切换到home目录</span><br><span class="line">cd -：切换到上次访问的目录</span><br></pre></td></tr></table></figure>
<h3 id="ls：目录查看">ls：目录查看</h3>
<ol>
<li>-l：以长格式查看文件和目录</li>
<li>-o：作用同-l，显示除用户组外的详细信息</li>
<li>-a：查看当前目录下的所有目录和文件（包括隐藏的文件）</li>
<li>-R：遇到目录要进行递归展开（继续列出目录下面的文件和内容）</li>
<li>-d：只列出目录，不列出其他内容</li>
<li>-S/-t：按大小/时间排序</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls：查看当前目录下的所有目录和文件</span><br><span class="line">ls -a：查看当前目录下的所有目录和文件（包括隐藏的文件）</span><br><span class="line">ls -l 或 ll：列表查看当前目录下的所有目录和文件（列表查看，显示更多信息）</span><br><span class="line">ls /dir：查看指定目录下的所有目录和文件，如：ls /usr</span><br></pre></td></tr></table></figure>
<h3 id="mkdir：创建目录">mkdir：创建目录</h3>
<ol>
<li>-m（mode）：配置文件的权限，不需要看默认权限 (umask) 的脸色</li>
<li>-p（parents）：直接将所需要的目录（包含上一级目录）递归创建起来</li>
<li>-v（verbose）：为每一个创建的目录打印一个信息</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir aaa：在当前目录下创建一个名为aaa的目录</span><br><span class="line">mkdir /usr/aaa：在指定目录usr（已存在）下创建一个名为aaa的目录</span><br><span class="line">mkdir -p test2/test3：递归创建多个目录</span><br><span class="line">mkdir -v test6：创建目录打印输出信息</span><br><span class="line">mkdir -m=r-- test1：创建一个test1目录，同时目录所有者、用户组和其他用户针对该目录赋予只读权限</span><br><span class="line">mkdir -m=777 test1：创建一个test1目录，同时目录所有者、用户组和其他用户针对该目录赋予所有权限</span><br></pre></td></tr></table></figure>
<h3 id="rm：删除目录">rm：删除目录</h3>
<ol>
<li>-r 或-R：递归处理，将指定目录下的所有文件与子目录一并处理</li>
<li>-f：强制删除文件或目录</li>
<li>-i：删除已有文件或目录之前先询问用户</li>
<li>-v：打印操作的信息</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">删除文件：</span><br><span class="line">rm a.txt：删除当前目录下的a文件</span><br><span class="line">rm -f a.txt：删除当前目录的的a文件（不询问）</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除目录：</span></span><br><span class="line">rm -r aaa：递归删除当前目录下的aaa目录</span><br><span class="line">rm -rf aaa：递归删除当前目录下的aaa目录（不询问）</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">全部删除：</span></span><br><span class="line">rm -rf * ：将当前目录下的所有目录和文件全部删除</span><br><span class="line">rm -rf /* ：【自杀命令！慎用！慎用！慎用！】将根目录下的所有文件全部删除，删库跑路</span><br></pre></td></tr></table></figure>
<h3 id="mv：目录修改">mv：目录修改</h3>
<ol>
<li>-b：当文件存在时，覆盖前为其创建一个备份</li>
<li>-f：force 强制，如果目标文件已经存在，不会询问而直接覆盖</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">重命名目录：mv 当前目录 新目录</span><br><span class="line">mv aaa bbb</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重命名文件</span></span><br><span class="line">mv a.txt b.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">剪切目录：<span class="built_in">mv</span> 目录名称 目录的新位置</span></span><br><span class="line">mv /usr/tmp/aaa /usr</span><br></pre></td></tr></table></figure>
<h3 id="cp：目录复制">cp：目录复制</h3>
<ol>
<li>-r：代表递归</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">贝目录</span><br><span class="line">cp -r /usr/tmp/aaa /usr</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">拷贝文件</span></span><br><span class="line">cp a.txt b.txt</span><br></pre></td></tr></table></figure>
<h3 id="pwd：查看当前目录">pwd：查看当前目录</h3>
<h2 id="文件操作命令">文件操作命令</h2>
<h3 id="touch：新建文件">touch：新建文件</h3>
<p>语法：touch 文件名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch a.txt</span><br></pre></td></tr></table></figure>
<h3 id="rm：删除文件">rm：删除文件</h3>
<p>语法：rm -rf 文件名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -rf a.txt</span><br></pre></td></tr></table></figure>
<h3 id="vi-或-vim：修改文件">vi 或 vim：修改文件</h3>
<h4 id="切换插入模式">切换插入模式</h4>
<ol>
<li>i：切换到输入模式，在光标当前位置开始输入文本</li>
<li>a：进入插入模式，在光标下一个位置开始输入文本</li>
<li>o：在当前行的下方插入一个新行，并进入插入模式</li>
<li>O：在当前行的上方插入一个新行，并进入插入模式</li>
</ol>
<h4 id="切换末行模式">切换末行模式</h4>
<ol>
<li>:：切换到底线命令模式，以在最底一行输入命令</li>
<li>: w：保存文件</li>
<li>: q：退出 vim 编辑器</li>
<li>: wq：保存并退出编辑</li>
<li>: q!：强制退出 vim 编辑器，不保存修改</li>
</ol>
<h4 id="删除、复制和粘贴">删除、复制和粘贴</h4>
<ol>
<li>x：删除当前光标所在处的字符</li>
<li>D：删除从光标到行尾的所有内容</li>
<li>dd：删除光标所在的一行</li>
<li>ndd：删除光标所在的向下 n 行</li>
<li>yy：复制光标所在的一行</li>
<li>nyy：复制光标所在的向下 n 行</li>
<li>p：粘贴剪贴板内容到光标下方</li>
<li>P：粘贴剪贴板内容到光标上方</li>
<li>r：替换光标下的字符</li>
<li>R：进入替换模式，替换当前光标后的内容，直到按 Esc 退出</li>
</ol>
<h4 id="查找和替换">查找和替换</h4>
<ol>
<li>/字符串：向下寻找一个名为字符串的字符串</li>
<li>?字符串：向上寻找一个名为字符串的字符串</li>
<li>n：重复上一次搜索，向下查找下一个匹配</li>
<li>N：重复上一次搜索，向上查找上一个匹配</li>
<li>:%s/old/new/g：将整个文件中的 old 替换为 new</li>
<li>:%s/old/new/gc：替换前进行确认</li>
</ol>
<h4 id="撤销和恢复">撤销和恢复</h4>
<ol>
<li>u：撤销上一次操作</li>
<li>Ctrl+r：重做上一次的操作</li>
</ol>
<p><img src="2.png" alt=""></p>
<p>命令行模式下的常用命令：</p>
<ol>
<li>shift+z+z：保存并退出快捷键</li>
<li>shift+g：光标跳到最后一行快捷键</li>
<li>set  noreadonly：修改 readonly 形式</li>
</ol>
<h3 id="查看文件">查看文件</h3>
<h4 id="cat：第一行开始显示">cat：第一行开始显示</h4>
<p>格式：cat [options] 文件名</p>
<ol>
<li>-b：列出行号，仅针对非空白行做行号显示，空白行不标行号</li>
<li>-n：列出行号，连同空白行也会有行号</li>
<li>-s：将连续的空行压缩为单个空行</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat a.txt</span><br><span class="line">cat file1.txt file2.txt # 将多个文件的内容合并并显示</span><br><span class="line">cat -n myfile.txt # 显示文件内容并包括行号</span><br><span class="line">cat -s myfile.txt # 压缩空行</span><br></pre></td></tr></table></figure>
<h4 id="more：百分比显示">more：百分比显示</h4>
<p>格式：more [options] 文件名</p>
<ol>
<li>空白键：向下翻一页</li>
<li>Enter：向下翻一行</li>
<li>b：往回翻页</li>
<li>q：退出查看</li>
<li>-数字 n：查看 n 行</li>
<li>+数字 n：从第 n 行开始看</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">more a.txt</span><br></pre></td></tr></table></figure>
<h4 id="less：翻页查看">less：翻页查看</h4>
<p>格式：less [options] 文件名</p>
<ol>
<li>上下键：上下翻页</li>
<li>/字符串：代表在这个显示的内容中，向下搜寻 [字符串] 这个关键字</li>
<li>?字符串：代表在这个显示的内容中，向上搜寻 [字符串] 这个关键字</li>
</ol>
<ul>
<li>n：向下找下一个</li>
<li>N：向上找上一个</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">less a.txt</span><br></pre></td></tr></table></figure>
<h4 id="tail：取出文件后面几行">tail：取出文件后面几行</h4>
<p>格式：tail [options] 文件名</p>
<ol>
<li>-f：实时打印文件内容</li>
<li>-n 数字 m：显示文件最后 m 行内容</li>
<li>-c 数字 m：显示文件最后 m 个字符</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">显示文件的最后 10 行</span><br><span class="line">tail myfile.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示文件的最后 20 行</span></span><br><span class="line">tail -n 20 myfile.txt</span><br><span class="line">tail -20 myfile.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">实时追踪查看日志文件的新内容</span></span><br><span class="line">tail -f /var/log/syslog</span><br><span class="line">tail -20f /var/log/syslog</span><br></pre></td></tr></table></figure>
<h4 id="head：取出文件前面几行">head：取出文件前面几行</h4>
<p>格式：head [options] 文件名</p>
<ol>
<li>-n 数字 m：显示文件前 m 行内容</li>
<li>-c 数字 m：显示文件前 m 个字符</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">显示文件的前 10 行</span><br><span class="line">head myfile.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示文件的前 5 行</span></span><br><span class="line">head -5 myfile.txt</span><br><span class="line">head -n 5 myfile.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示文件的前 20 字节</span></span><br><span class="line">head -c 20 myfile.txt</span><br></pre></td></tr></table></figure>
<h2 id="查找命令">查找命令</h2>
<h3 id="grep：过滤查找">grep：过滤查找</h3>
<p>语法：grep [options] pattern [file…]</p>
<ol>
<li>-n：显示匹配行及行号</li>
<li>-i：忽略字母大小写</li>
<li>-w：只匹配整个单词，而不是字符串的一部分（如匹配’magic’，而不是’magical’）</li>
<li>-l：列出匹配文件内容的文件名</li>
<li>-c：统计匹配成功的行数</li>
<li>–color：匹配到的关键词会高亮显示</li>
<li>-r：递归的搜索目录</li>
<li>-v：排除对应的字符串</li>
<li>-o：只显示匹配的字符串</li>
<li>-a（after）：打印搜索的字符串后 n 行的数据</li>
<li>-b（before）：打印搜索的字符串前 n 行的数据</li>
<li>-c（both）：打印搜索的字符串前后 n 行的数据</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep -l &#x27;oldboy&#x27; /oldboy/*</span><br><span class="line">grep -i &#x27;OLDBOY&#x27; /oldboy/oldboy.txt</span><br><span class="line">grep -n &#x27;man&#x27; /oldboy/oldboy.txt</span><br><span class="line"></span><br><span class="line">grep -r &quot;ramesh&quot; * # 使用-r 参数来实现递归的搜索目录</span><br><span class="line">grep -c &quot;pattern&quot; filename # 计算出命中匹配的总行数：6</span><br><span class="line">grep -iw &quot;is&quot; demo_file # 只会完整的匹配 is 这个单词</span><br><span class="line">grep -A 3 -i &quot;example&quot; demo_text # After 连着打印“example” 单词后的 2 行，共 3 行</span><br><span class="line">grep -B 3 -i &quot;example&quot; demo_text # Before 连着打印“example” 单词前的 2 行，共 3 行</span><br><span class="line">grep -C 3 -i &quot;example&quot; demo_text # Both 连着打印“example” 单词前后的 2 行，共 5 行</span><br><span class="line">grep -v &quot;go&quot; demo_text  # 显示哪些不包含 go 子串的行</span><br><span class="line">grep -v -e &quot;pattern1&quot; -e &quot;pattern2&quot; filename # 显示不符合 pattern1 和 pattern2 的结果的数据</span><br><span class="line">grep -o &quot;is.*line&quot; demo_file  # 只显示 is 和 line 之间的字符串，而不是一行</span><br></pre></td></tr></table></figure>
<p><strong>管道符结合</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">查找指定 ssh 服务进程 </span><br><span class="line">ps -ef | grep sshd</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找指定服务进程，排除 gerp 身</span> </span><br><span class="line">ps -ef | grep sshd | grep -v grep</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找指定进程个数</span></span><br><span class="line">ps -ef | grep sshd -c</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示文件行数</span></span><br><span class="line">cat b.txt | grep -n b.txt</span><br></pre></td></tr></table></figure>
<h3 id="find：目录查找">find：目录查找</h3>
<p>find 默认搜索当前目录及其子目录，并且不过滤任何结果（返回所有文件）</p>
<p>语法：find 目录 参数 文件名称</p>
<p>参数：</p>
<ol>
<li>-name &lt;查询方式&gt;：按照指定的文件名查找模式查找文件</li>
<li>-user &lt;用户名&gt;：查找属于指定用户名所有文件</li>
<li>-group &lt;用户组&gt;：按文件所属组查找文件</li>
<li>-size &lt;文件大小&gt;：按照指定的文件大小查找文件</li>
<li>-type &lt;文件类型&gt;：按文件类型查找，可以是 f（普通文件）、d（目录）、l（符号链接）等</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find /usr/tmp -name &#x27;a*&#x27;：查找/usr/tmp目录下的所有以a开头的目录或文件</span><br><span class="line">find /usr/tmp -user &#x27;root&#x27;：查找/usr/tmp目录下的所有以a开头的目录或文件</span><br><span class="line">find . -type f：将当前目录及其子目录中的所有文件列出</span><br><span class="line">find /home -size +1M：查找 /home 目录下大于 1MB 的文件</span><br><span class="line"></span><br><span class="line">find . -name &quot;*.log&quot; -ls：在当前目录查找以.log结尾的文件，并显示详细信息</span><br><span class="line">find /root/ -perm 600：查找/root/目录下权限为600的文件</span><br><span class="line">find . -type f -name &quot;*.log&quot;：查找当前目录以.log结尾的普通文件</span><br><span class="line">find . -type d | sort：查找当前所有目录并排序</span><br><span class="line">find . -size +100M：查找当前目录大于100M的文件</span><br></pre></td></tr></table></figure>
<ol>
<li>-iname：按照文件名搜索，不区分文件名大小</li>
<li>-size [±] 大小：按照指定大小搜索文件</li>
<li>-atime [±] 时间：按照文件访问时间搜索</li>
<li>-mtime [±] 时间：按照文件数据修改时间搜索</li>
<li>-ctime [±] 时间：按照文件状态修改时间搜索</li>
<li>-perm 权限模式：查找文件权限刚好等于“权限模式”的文件</li>
<li>-perm -权限模式：查找文件权限全部包含“权限模式”的文件</li>
<li>-perm +权限模式：查找文件权限包含“权限模式”的任意一个权限的文件</li>
</ol>
<h3 id="locate">locate</h3>
<p>格式：locate [选项] [参数]</p>
<ol>
<li>-A：显示匹配所有模式的文件，可使用多个匹配值选择要查找的文件</li>
<li>-b：只能匹配文件名，有绝对路径的情况下不进行匹配</li>
<li>-c：只显示文件数量</li>
<li>-i：匹配不区分大小写的文件</li>
</ol>
<p>locate 指令无需遍历整个文件系统，查询速度较快，因为是去搜索一个数据库（/var/lib/mlocate/mlocate.db），可以很快速的搜寻某个路径，默认每天自动更新一次，所以使用 locate 命令查不到最新变动过的文件，为了避免这种情况，可以在使用 locate 之前，先使用 updatedb 命令，手动更新数据库。由于 locate 指令基于数据库进行查询，所以第一次运行前，必须使用 updatedb 指令创建 locate 数据库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">updatedb</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">搜索 etc 目录下所有以 sh 开头的文件</span></span><br><span class="line">locate /etc/sh</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找和 <span class="built_in">pwd</span> 相关的所有文件</span></span><br><span class="line">locate pwd</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找包含 pass 和 txt 都有的文件</span></span><br><span class="line">locate -A &quot;pass&quot; &quot;txt&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">匹配不区分大小写的文件</span></span><br><span class="line">locate -i &quot;testdir&quot;</span><br></pre></td></tr></table></figure>
<p>与 find 的区别：</p>
<ol>
<li>locate 命令查找文件在数据库中查找，查找的速度非常快，几乎是马上列出结果；而 find 命令查找时则是直接查找硬盘上的文件，查找的速度相应的非常慢</li>
<li>locate 需要先 updatedb 才能找到文件；而 find 不需要</li>
</ol>
<h3 id="whereis">whereis</h3>
<p>whereis 命令是定位可执行文件、源代码文件、帮助文件在文件系统中的位置，这些文件的属性应属于原始代码、二进制文件或帮助文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">whereis ls：将和ls文件相关的文件都查找出来</span><br></pre></td></tr></table></figure>
<h3 id="which：环境变量">which：环境变量</h3>
<p>which 命令的作用是在 PATH 变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">which pwd	#查找 pwd 命令所在路径</span><br><span class="line">which java	#查找 path 中 java 的路径</span><br></pre></td></tr></table></figure>
<h2 id="压缩文件操作">压缩文件操作</h2>
<ol>
<li>Linux 中的打包文件：aa.tar</li>
<li>Linux 中的压缩文件：bb.gz</li>
<li>Linux 中打包并压缩的文件：.tar.gz</li>
<li>Linux 中的打包文件一般是以.tar 结尾的，压缩的命令一般是以.gz 结尾的。</li>
</ol>
<p>一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。</p>
<h3 id="tar">tar</h3>
<ol>
<li>压缩命令：tar [-zcvf] 打包压缩后的文件名 要打包的文件</li>
<li>解压命令：tar [-zxvf] 压缩文件</li>
</ol>
<ul>
<li>z：调用 gzip 命令进行压缩和解压</li>
<li>c：打包文件</li>
<li>v：显示运行过程</li>
<li>f：指定文件名</li>
<li>x：代表解压</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -cvf test.tar abd.txt bcd.txt</span><br><span class="line">tar -xvf test.tar </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">压缩文件 file1 和目录 dir2 到 test.tar.gz</span></span><br><span class="line">tar -zcvf test.tar.gz file1 dir2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打包并压缩/usr/tmp 下的所有文件</span></span><br><span class="line">tar -zcvf test.tar.gz *</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压 test.tar.gz（将 c 换成 x 即可），解压到当前目录下</span></span><br><span class="line">tar -zxvf test.tar.gz</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将/usr/tmp 下的 ab.tar 解压到根目录/usr 下</span></span><br><span class="line">tar -zxvf test.tar.gz -C /usr</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出压缩文件的内容</span></span><br><span class="line">tar -ztvf test.tar.gz </span><br></pre></td></tr></table></figure>
<h3 id="rar">rar</h3>
<h3 id="gzip-gunzip">gzip/gunzip</h3>
<ol>
<li>gzip 文件：压缩文件（不会保留原有的文件）</li>
</ol>
<ul>
<li>-c：将压缩数据输出到标准输出中，可以用于保留源文件</li>
<li>-r：把目录下的所有文件都压缩，而不是把这个目录压缩（不能打包）</li>
</ul>
<ol start="2">
<li>gunzip 文件.gz：解压缩文件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gzip abc.txt </span><br><span class="line">gzip -c bcd.txt &gt; bcd.txt.gz</span><br><span class="line">gzip -r aaaa/</span><br></pre></td></tr></table></figure>
<h3 id="zip-unzip">zip/unzip</h3>
<ol>
<li>zip [选项] 文件.zip 要压缩的文件：压缩文件和目录</li>
</ol>
<ul>
<li>-r：递归压缩，即压缩目录</li>
</ul>
<ol start="2">
<li>unzip [选项] 文件.zip：解压缩文件</li>
</ol>
<ul>
<li>-d &lt;目录&gt;：指定解压后文件的存放目录（如果不指定 -d 参数，默认解压到当前目录下）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">压缩文件</span><br><span class="line">zip -r test.zip file</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压文件</span></span><br><span class="line">unzip test.zip</span><br><span class="line">unzip -d /home/hepingfly/abc/ mytxt.zip </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux（2-用户权限管理）</title>
    <url>/blog/2024/12/01/%E8%BF%90%E7%BB%B4/Linux/Linux%EF%BC%882-%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%EF%BC%89/</url>
    <content><![CDATA[<h2 id="用户和组">用户和组</h2>
<h3 id="用户账号">用户账号</h3>
<ol>
<li>超级用户：root用户是Linux操作系统中默认的超级用户账号，对本主机拥有最高的权限。系统中超级用户是唯一的。</li>
<li>普通用户：由root用户或其他管理员用户创建，拥有的权限会受到限制，一般只在用户自己的宿主目录中拥有完整权限。</li>
<li>程序用户：在安装Linux操作系统及部分应用程序时，会添加一些特定的低权限用户账号，这些用户一般不允许登录到系统，仅用于维持系统或某个程序的正常运行，如bin、daemon、ftp、mail等。</li>
</ol>
<h3 id="组账号">组账号</h3>
<ol>
<li>基本组（私有组）：基本组账号只有一个，一般为创建用户时指定的组。在/etc/passwd文件中第4字段记录的即为该用户的基本组GID号。</li>
<li>附加组（公共组）：用户除了基本组以外，额外添加指定的组。</li>
</ol>
<ul>
<li>UID：用户标识号</li>
<li>GID：组标识号</li>
</ul>
<h3 id="相关文件">相关文件</h3>
<ol>
<li>/etc/passwd：文件用户的配置文件，保存用户名称、宿主目录、登录Shell 等基本信息</li>
<li>/etc/group：文件组的配置文件，记录Linux包含的组的信息</li>
<li>/etc/shadow：文件口令的配置文件，保存用户的密码、账号有效期等信息</li>
<li>/etc/gshadow：组密码及其相关属性</li>
</ol>
<h3 id="文件属性">文件属性</h3>
<h4 id="rwx">rwx</h4>
<ol>
<li>读取r：允许查看文件内容、显示目录列表</li>
<li>写入w：允许修改文件内容，允许在目录中新建、移动、删除文件或子目录</li>
<li>可执行x：允许运行程序、切换目录</li>
</ol>
<p>注意：三个权限的位置不会改变，如果没有权限，就会出现-代替，如果rwx任意位置变为-则代表不可读或不可写或不可执行文件。</p>
<table>
<thead>
<tr>
<th>权限</th>
<th>读</th>
<th>写</th>
<th>执行</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>字符</td>
<td>r</td>
<td>w</td>
<td>x</td>
<td>-</td>
</tr>
<tr>
<td>数字</td>
<td>4</td>
<td>2</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<h4 id="查看文件-目录的权限和归属">查看文件/目录的权限和归属</h4>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>d</td>
<td>目录</td>
</tr>
<tr>
<td>-</td>
<td>文件</td>
</tr>
<tr>
<td>l</td>
<td>链接文档（link file）</td>
</tr>
<tr>
<td>b</td>
<td>装置文件里面的可供储存的接口设备（可随机存取装置）</td>
</tr>
<tr>
<td>c</td>
<td>装置文件里面的串行端口设备</td>
</tr>
</tbody>
</table>
<ol>
<li>第一段（3位）：代表拥有者的权限</li>
<li>第二段（3位）：代表拥有者所在的组，组员的权限</li>
<li>第三段（3位）：代表的是其他用户的权限</li>
</ol>
<p>每个文件的属性由左边第一部分的10个字符来确定</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>文件类型</th>
<th>属主权限</th>
<th>属组权限</th>
<th>其他用户权限</th>
</tr>
</thead>
<tbody>
<tr>
<td>位置</td>
<td>0</td>
<td>123</td>
<td>456</td>
<td>789</td>
</tr>
</tbody>
</table>
<h2 id="用户管理">用户管理</h2>
<h3 id="查看用户信息">查看用户信息</h3>
<ol>
<li>whoami：查看当前用户</li>
<li>who：打印当前登录用户</li>
</ol>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a</td>
<td>打印全面信息</td>
</tr>
<tr>
<td>-b</td>
<td>打印系统最近启动时间</td>
</tr>
<tr>
<td>-d</td>
<td>打印死掉的进程</td>
</tr>
<tr>
<td>-l</td>
<td>打印系统登录进程</td>
</tr>
<tr>
<td>-H</td>
<td>带有列标题打印用户名，登录终端和登录时间</td>
</tr>
<tr>
<td>-t</td>
<td>打印系统上次锁定时间</td>
</tr>
<tr>
<td>-u</td>
<td>打印已登录用户列表</td>
</tr>
</tbody>
</table>
<h3 id="exit：退出登录账户">exit：退出登录账户</h3>
<h3 id="useradd：添加用户">useradd：添加用户</h3>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-u</td>
<td>指定用户的 UID 号，要求该 UID 号码未被其他用户使用。</td>
</tr>
<tr>
<td>-d</td>
<td>指定用户的宿主目录位置（当与-M 一起使用时，不生效）。</td>
</tr>
<tr>
<td>-e</td>
<td>指定用户的账户失效时间，可使用 YYYY-MM-DD 的日期格式。</td>
</tr>
<tr>
<td>-g</td>
<td>指定用户的基本组名（或使用 GID 号），对应的组名必须已存在。</td>
</tr>
<tr>
<td>-G</td>
<td>指定用户的附加组名（或使用 GID 号），对应的组名必须已存在。</td>
</tr>
<tr>
<td>-m</td>
<td>用户目录不存在时自动创建</td>
</tr>
<tr>
<td>-M</td>
<td>不建立宿主目录。</td>
</tr>
<tr>
<td>-s</td>
<td>指定用户的登录 Shell，（比如/bin/bash为可登陆系统，/sbin/nologin和/bin/false为禁止用户登陆系统）。</td>
</tr>
<tr>
<td>-r</td>
<td>建立系统账号</td>
</tr>
<tr>
<td>-c</td>
<td>添加备注文字</td>
</tr>
</tbody>
</table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">useradd -m liyou1：创建用户名，并且创建与用户名相同的目录与用户组</span><br><span class="line">useradd -d /home/liyou -m liyou2：指定用户目录</span><br><span class="line">useradd -g ftp liyou3：指定用户组</span><br><span class="line">useradd -p 123 liyou4：指定用户密码</span><br></pre></td></tr></table></figure>
<h3 id="userdel：删除用户">userdel：删除用户</h3>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-r</td>
<td>将该用户的宿主目录一并删除</td>
</tr>
</tbody>
</table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">userdel liyou：删除用户，但不删除其家目录及文件</span><br><span class="line">userdel -r liyou：删除用户，并将其家目录及文件一并删除</span><br><span class="line">userdel -f liyou：强制删除用户</span><br></pre></td></tr></table></figure>
<h3 id="usermod：修改用户账号">usermod：修改用户账号</h3>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-u</td>
<td>修改用户的 UID 号。</td>
</tr>
<tr>
<td>-d</td>
<td>修改用户的宿主目录位置。</td>
</tr>
<tr>
<td>-e</td>
<td>修改用户的账户失效时间，可使用 YYYY-MM-DD 的日期格式。</td>
</tr>
<tr>
<td>-g</td>
<td>修改用户的基本组名（或使用 GID 号）。</td>
</tr>
<tr>
<td>-G</td>
<td>修改用户的附加组名（或使用 GID 号）。</td>
</tr>
<tr>
<td>-s</td>
<td>指定用户的登录 Shell。</td>
</tr>
<tr>
<td>-l</td>
<td>更改用户账号的登录名称</td>
</tr>
<tr>
<td>-L</td>
<td>锁定用户账户</td>
</tr>
<tr>
<td>-U</td>
<td>解锁用户账户</td>
</tr>
</tbody>
</table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">usermod -d /home/liyou liyou：更改登录目录</span><br><span class="line">usermod -u 777 liyou：改变用户的uid</span><br><span class="line">usermod -l liyou liyou1：修改用户名liyou1为liyou</span><br><span class="line">usermod -L liyou：锁定密码</span><br><span class="line">usermod -U liyou：解锁密码</span><br></pre></td></tr></table></figure>
<h3 id="passwd：设置用户密码">passwd：设置用户密码</h3>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-d</td>
<td>清空指定用户的密码，仅使用用户名即可登录系统。</td>
</tr>
<tr>
<td>-l</td>
<td>锁定用户密码，无法被用户自行修改，锁定的用户账号将无法再登录系统。</td>
</tr>
<tr>
<td>-u</td>
<td>解开已锁定用户密码，允许用户自行修改（-u解锁时，如果没有密码会提示，需要使用-f强制解锁）</td>
</tr>
<tr>
<td>-e</td>
<td>密码立即过期，下次登录强制修改密码</td>
</tr>
<tr>
<td>-k</td>
<td>保留即将过期的用户在期满后仍能使用</td>
</tr>
<tr>
<td>-S</td>
<td>查看用户账户的状态（是否被锁定）。</td>
</tr>
</tbody>
</table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">passwd：设置当前用户密码</span><br><span class="line">passwd liyou1：设置用户密码</span><br><span class="line">passwd -l liyou1：锁定密码不允许用户修改</span><br><span class="line">passwd -u liyou1：解除锁定密码，允许用户修改</span><br><span class="line">passwd -e liyou1：下次登录强制改密码</span><br><span class="line">passwd -d liyou1：移除用户密码</span><br></pre></td></tr></table></figure>
<h3 id="sudo：用超级用户的权限执行命令">sudo：用超级用户的权限执行命令</h3>
<p>sudo是为所有想使用root权限的普通用户设计的，可以让普通用户具有临时使用root权限的权利，只需输入自己账户的密码即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入<span class="built_in">sudo</span>配置文件命令</span></span><br><span class="line">vi /etc/sudoer或者visudo</span><br></pre></td></tr></table></figure>
<h3 id="su：切换用户">su：切换用户</h3>
<p>su用于用户之间的切换，但是切换前的用户依然保持登录状态。如果是root向普通或虚拟用户切换不需要密码，反之普通用户切换到其它任何用户都需要密码验证。</p>
<p>不足：如果某个用户需要使用root权限、则必须要把root密码告诉此用户。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su test：切换到test用户，但是路径还是/root目录</span><br><span class="line">su - test ：切换到test用户，路径变成了/home/test</span><br><span class="line">su：切换到root用户，但是路径还是原来的路径</span><br><span class="line">su - ：切换到root用户，并且路径是/root</span><br><span class="line">exit、logout：退出返回之前的用户</span><br></pre></td></tr></table></figure>
<h2 id="用户组管理">用户组管理</h2>
<h3 id="groupadd：添加组">groupadd：添加组</h3>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-g</td>
<td>指定新建工作组的id</td>
</tr>
<tr>
<td>-r</td>
<td>创建系统工作组，系统工作组的组ID小于500</td>
</tr>
<tr>
<td>-K</td>
<td>覆盖配置文件“/ect/login.defs”</td>
</tr>
<tr>
<td>-o</td>
<td>允许添加组ID号不唯一的工作组</td>
</tr>
</tbody>
</table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">groupadd usergroup1：创建用户组</span><br><span class="line">groupadd -g 8563 usergroup1：创建用户组，指定工作组id</span><br><span class="line">groupadd -r usergroup1：使用-r创建系统工作组</span><br></pre></td></tr></table></figure>
<h3 id="groupdel：删除用户组">groupdel：删除用户组</h3>
<p>给出的组名必须存在，若改群组中仍包括某些用户，则必须先删除这些用户后，方能删除群组</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">groupdel usergroup1：删除用户组</span><br></pre></td></tr></table></figure>
<h3 id="gpasswd：设置用户的用户组">gpasswd：设置用户的用户组</h3>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a</td>
<td>添加用户到组</td>
</tr>
<tr>
<td>-d</td>
<td>从组删除用户</td>
</tr>
<tr>
<td>-A</td>
<td>指定管理员</td>
</tr>
<tr>
<td>-M</td>
<td>定义组成员列表，以逗号分隔</td>
</tr>
<tr>
<td>-r</td>
<td>删除密码</td>
</tr>
<tr>
<td>-R</td>
<td>限制用户登入组，只有组中的成员才可以用newgrp加入该组</td>
</tr>
</tbody>
</table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gpasswd -a liyou usergroup1：添加用户到组</span><br><span class="line">gpasswd -d liyou usergroup1：移除用户出组</span><br></pre></td></tr></table></figure>
<h3 id="groupmod：更改用户组">groupmod：更改用户组</h3>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-g</td>
<td>设置欲使用的群组识别码</td>
</tr>
<tr>
<td>-o</td>
<td>重复使用群组识别码</td>
</tr>
<tr>
<td>-n</td>
<td>设置欲使用的群组名称</td>
</tr>
</tbody>
</table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">groupmod -g 222 usergroup1：更改组ID</span><br><span class="line">groudmod -n usergroup1 usergroup2：更改组名</span><br></pre></td></tr></table></figure>
<h3 id="groups：查询用户所属的组">groups：查询用户所属的组</h3>
<p>格式：groups  [用户名]</p>
<h2 id="权限修改">权限修改</h2>
<h3 id="chmod：修改文件或目录权限">chmod：修改文件或目录权限</h3>
<ol>
<li>u（user）：所有者</li>
<li>g（group）：所有组</li>
<li>o（other）：其他人</li>
<li>a（all）：所有人</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod u=rwx,g=rx,o=x 文件目录名</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">表示给所有者读、写、执行权限 ，给所有组读和执行权限，给其他人执行权限</span></span><br><span class="line">chmod o+w 文件目录名</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">表示给其他人添加写的权限</span></span><br><span class="line">chmod a-x 文件目录名</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">表示给所有人去除执行的权限</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1、给abc文件的所有者读写执行的权限，给所有组读执行权限，给其他组读执行权限</span></span><br><span class="line">chmod u=rwx,g=rx,o=rx abc</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2、给abc文件的所有者除去执行的权限，增加所有组写的权限</span></span><br><span class="line">chmod u-x,g+w abc</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3、给abc文件的所有用户添加读的权限</span></span><br><span class="line">chmod a+r abc</span><br></pre></td></tr></table></figure>
<p>**规则 **</p>
<ol>
<li>r=4：二进制 100</li>
<li>w=2：二进制 010</li>
<li>x=1：二进制 001</li>
</ol>
<p>rwx=4+2+1=7</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod u=rwx,g=rx,o=x 文件目录名</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">相当于<span class="built_in">chmod</span> 751 文件目录名</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将/home/abc.txt文件的权限修改成rwxr-xr-x，使用数字的方式实现</span></span><br><span class="line">chmod 755 /home/abc.txt</span><br></pre></td></tr></table></figure>
<h3 id="chown：修改文件所有者">chown：修改文件所有者</h3>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-R</td>
<td>递归修改指定目录下所有子项的权限</td>
</tr>
</tbody>
</table>
<p>格式：</p>
<ol>
<li>chown newowner file：改变文件的所有者</li>
<li>chown newowner:newgroup file：改变用户的所有者和所有组</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将/home/abc.txt文件的所有者修改成tom</span></span><br><span class="line">chown tom abc.txt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将/home/kkk目录下所有的文件和目录的所有者都修改成tom</span></span><br><span class="line">chown -R tom kkk/</span><br></pre></td></tr></table></figure>
<h3 id="chgrp：修改文件所在组">chgrp：修改文件所在组</h3>
<p>格式：chgrp newgroup file：改变文件的所有组</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将/home/abc.txt文件的所在组修改成bandit(土匪)</span></span><br><span class="line">chgrp bandit /home/abc.txt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将/home/kkk 目录下所有的文件和目录的所在组都修改成bandit(土匪)</span></span><br><span class="line">chgrp -R bandit /home/kkk</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL（1-常用命令）</title>
    <url>/blog/2024/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/MySQL%EF%BC%881-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%89/</url>
    <content><![CDATA[<h2 id="DDL（定义数据库、表结构）">DDL（定义数据库、表结构）</h2>
<h3 id="操作数据库">操作数据库</h3>
<h4 id="创建数据库">创建数据库</h4>
<ol>
<li>创建数据库：create database 数据库名称;</li>
<li>创建数据库，判断是否存在：create database if not exists 数据库名称;</li>
<li>创建数据库，判断是否存在，并指定字符集：create database 数据库名称 character set 字符集;</li>
</ol>
<h4 id="查询数据库">查询数据库</h4>
<ol>
<li>查询所有数据库的名称：show databases;</li>
<li>查询某个数据库的字符集：show create database 数据库名称;</li>
</ol>
<h4 id="修改数据库">修改数据库</h4>
<p>修改数据库的字符集：alter database 数据库名称 character set 字符集;</p>
<h4 id="删除数据库">删除数据库</h4>
<ol>
<li>删除数据库：drop  database 数据库名称;</li>
<li>判断数据库是否存在，存在则删除：drop database if exists 数据库名称;</li>
</ol>
<h4 id="使用数据库">使用数据库</h4>
<ol>
<li>查询当前正在使用的数据库名称：select database();</li>
<li>使用数据库：use 数据库名称;</li>
</ol>
<h3 id="操作表">操作表</h3>
<h4 id="创建表">创建表</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">	列名1  数据类型1，</span><br><span class="line">	列名2  数据类型2，</span><br><span class="line">	........</span><br><span class="line">	列名n  数据类型n </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>注意：最后一列不需要加逗号</p>
<h4 id="复制表">复制表</h4>
<ol>
<li>只复制表结构：create table 表名 like 被复制的表名;</li>
<li>复制表结构及数据：create table 表名 select *  from 被复制的表名;</li>
</ol>
<h4 id="查询表">查询表</h4>
<ol>
<li>查询某个数据库中所有的表名称：show tables;</li>
<li>查询表结构：desc 表名;</li>
<li>查看建表语句：show create table 表名;</li>
</ol>
<h4 id="修改表">修改表</h4>
<ol>
<li>修改表名：alter table 表名 rename to 新表名;</li>
<li>修改表的字符集：alter table 表名 character set 字符集名称;</li>
<li>添加一列：alter table 表名 add 列名 数据类型;</li>
<li>修改列名称和类型：</li>
</ol>
<ul>
<li>alter table 表名 change 列名 新列名 新数据类型;</li>
<li>alter table 表名 modify 列名 新数据类型;</li>
</ul>
<ol start="5">
<li>删除列：alter table 表名 drop 列名;</li>
</ol>
<h4 id="删除表">删除表</h4>
<ol>
<li>删除表：drop table 表名;</li>
<li>如果存在表，则删除：drop table if exists 表名;</li>
</ol>
<h3 id="约束">约束</h3>
<h4 id="主键约束（primary-key）">主键约束（primary key）</h4>
<ol>
<li>创建表时添加约束</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名 (</span><br><span class="line">	字段名 数据类型 primary key,</span><br><span class="line">	......</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>
<p>创建表完后删除约束：alter table 表名 drop primary key;</p>
</li>
<li>
<p>创建表完后添加约束</p>
</li>
</ol>
<ul>
<li>
<p>alter table 表名 add primary key(字段名);</p>
</li>
<li>
<p>alter table 表名 modify 字段名 数据类型 primary key;</p>
</li>
<li>
<p>alter table 表名 change 旧字段名 新字段名 数据类型 primary key;</p>
</li>
<li>
<p>alter table 表名 add constraint 约束名称 primary key(字段名);</p>
</li>
</ul>
<p><strong>注意</strong></p>
<ol>
<li>非空且唯一（等于唯一约束+非空约束），一张表只能有一个字段为主键</li>
<li>表需有该字段才能添加约束，有自动增长时需先删除自动增长，然后才能删除主键，否则会报错</li>
</ol>
<h4 id="自动增长（auto-increment）">自动增长（auto_increment）</h4>
<p>如果某一列是数值类型的，使用 auto_increment 可以来实现自动增长</p>
<ol>
<li>创建表时添加自动增长</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">	字段名 数据类型 primary key auto_increment,</span><br><span class="line">	......</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>创建表完后删除自动增长</li>
</ol>
<ul>
<li>
<p>alter table 表名 modify 字段名 数据类型;</p>
</li>
<li>
<p>alter table 表名 change 旧字段名 新字段名 数据类型;</p>
</li>
</ul>
<ol start="3">
<li>创建表完后添加自动增长</li>
</ol>
<ul>
<li>
<p>alter table 表名 modify 字段名 数据类型 auto_increment;</p>
</li>
<li>
<p>alter table 表名 change 旧字段名 新字段名 数据类型 auto_increment;</p>
</li>
</ul>
<p><strong>注意</strong></p>
<ol>
<li>一张表只能有一个自增列，并且该列必须定义了约束</li>
<li>必须为主键才可以设置为递增，并且只能在数字类型中使用，否则会报错</li>
</ol>
<h4 id="非空约束（not-null）">非空约束（not null）</h4>
<ol>
<li>创建表时添加约束</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">	字段名 数据类型 not null,</span><br><span class="line">	.......</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>创建表完后删除约束</li>
</ol>
<ul>
<li>
<p>alter table 表名 modify 字段名 数据类型;</p>
</li>
<li>
<p>alter table 表名 change 旧字段名 新字段名 数据类型;</p>
</li>
</ul>
<ol start="3">
<li>创建表完后添加约束</li>
</ol>
<ul>
<li>
<p>alter table 表名 modify 字段名 数据类型 not null;</p>
</li>
<li>
<p>alter table 表名 change 旧字段名 新字段名 数据类型 not null;</p>
</li>
</ul>
<h4 id="默认值约束（default）">默认值约束（default）</h4>
<ol>
<li>创建表时添加约束</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">	字段名 数据类型 default 值,</span><br><span class="line">	......</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>创建表完后删除约束</li>
</ol>
<ul>
<li>
<p>alter table 表名 modify 字段名 数据类型;</p>
</li>
<li>
<p>alter table 表名 change 旧字段名 新字段名 数据类型;</p>
</li>
</ul>
<ol start="3">
<li>创建表完后添加约束</li>
</ol>
<ul>
<li>
<p>alter table 表名  modify 字段名 数据类型 default 值;</p>
</li>
<li>
<p>alter table 表名  change 旧字段名 新字段名 数据类型 default 值;</p>
</li>
</ul>
<h4 id="唯一约束（unique）">唯一约束（unique）</h4>
<ol>
<li>创建表时添加约束</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">	字段名 数据类型 unique,</span><br><span class="line">	......</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>
<p>创建表完后删除约束：alter table 表名 drop index 字段名;</p>
</li>
<li>
<p>创建表完后添加约束</p>
</li>
</ol>
<ul>
<li>
<p>alter table 表名 add unique(字段名);</p>
</li>
<li>
<p>alter table 表名 add unique key(字段名);</p>
</li>
<li>
<p>alter table 表名 add constraint 约束名 unique(字段名);</p>
</li>
<li>
<p>alter table 表名 add constraint 约束名 unique key(字段名);</p>
</li>
<li>
<p>alter table 表名 modify 字段名 数据类型 unique;</p>
</li>
<li>
<p>alter table 表名 change 旧字段名 新字段名 数据类型 unique;</p>
</li>
</ul>
<p><strong>注意</strong></p>
<p>唯一约束可以有 null 值，null 值只能有一个</p>
<h4 id="外键约束（foreign-key）">外键约束（foreign key）</h4>
<p>foreign  key：让表与表之间产生联系，保证数据的正确性</p>
<ol>
<li>创建表时添加约束</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">	......,</span><br><span class="line">	外键列,</span><br><span class="line">	constraint 外键名称(自定义) foreign key(外键列名称) references 主表名称(主表列名称)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>
<p>创建表完后删除约束：alter table 表名 drop foreign key 外键名称;</p>
</li>
<li>
<p>创建表完后添加约束：alter table 表名 add constraint 外键名称(自定义) foreign key (外键列名称) references 主表名称(主表列名称);</p>
</li>
<li>
<p>级联操作：alter table 表名 add constraint 外键名称 foreign key (外键字段名称) references 主表名称(主表列名称) on update cascade on delete cascade;</p>
</li>
</ol>
<ul>
<li>级联更新：on update cascade</li>
<li>级联删除：on delete cascade</li>
</ul>
<p><strong>注意</strong></p>
<p>从表的外键关联的必须是主表的主键，且主键和外键的类型必须一致</p>
<h3 id="索引">索引</h3>
<h4 id="创建索引">创建索引</h4>
<ol>
<li>创建表的时候创建索引</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#唯一索引</span><br><span class="line">CREATE TABLE t1(</span><br><span class="line">  id INT NOT NULL,</span><br><span class="line">  name CHAR(30) NOT NULL,</span><br><span class="line">  UNIQUE INDEX UniqIdx(id)</span><br><span class="line">);</span><br><span class="line">#普通索引</span><br><span class="line">CREATE TABLE t1(</span><br><span class="line">  id INT NOT NULL,</span><br><span class="line">  name CHAR(30) NOT NULL,</span><br><span class="line">  INDEX UniqIdx(id)</span><br><span class="line">);</span><br><span class="line">#全文索引</span><br><span class="line">CREATE TABLE t1(</span><br><span class="line">  id INT NOT NULL,</span><br><span class="line">  name TEXT NOT NULL,</span><br><span class="line">  FULLTEXT INDEX UniqIdx(id)</span><br><span class="line">);</span><br><span class="line">#多列索引</span><br><span class="line">CREATE TABLE t1(</span><br><span class="line">  id INT NOT NULL,</span><br><span class="line">  name TEXT NOT NULL,</span><br><span class="line">  key INDEX UniqIdx(id,name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在已存在的表上建立索引</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#在已存在的表上建立索引</span><br><span class="line">ALTER TABLE mytable ADD UNIQUE INDEX UniqIdx(id);</span><br><span class="line">ALTER TABLE mytable ADD INDEX index_name(name(10),city,age);</span><br><span class="line">ALTER TABLE mytable ADD FULLTEXT INDEX UniqIdx(id);</span><br><span class="line">ALTER TABLE mytable ADD INDEX UniqIdx(id);</span><br><span class="line">#组合索引，相当于分别建立了下面三组索引：</span><br><span class="line">username,city,age</span><br><span class="line">username,city</span><br><span class="line">username</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#只能增加普通索引INDEX和UNIQUE INDEX索引这两种，不能创建PRIMARY KEY索引</span><br><span class="line">CREATE INDEX index_name ON mytable(username);</span><br><span class="line">CREATE UNIQUE INDEX index_name ON mytable(username);</span><br><span class="line">CREATE FULLTEXT INDEX index_name ON mytable(username);</span><br><span class="line">CREATE INDEX index_name ON mytable(username,password);</span><br></pre></td></tr></table></figure>
<h4 id="查看索引">查看索引</h4>
<ol>
<li>查看表的索引：show index from 表名;</li>
<li>指定数据库查看表的索引：show index from 表名 from 数据库名;</li>
</ol>
<h4 id="删除索引">删除索引</h4>
<ol>
<li>删除表的索引：drop index 索引名 on 表名;</li>
<li>删除表的索引：alter table 表名 drop index 索引名;</li>
</ol>
<h2 id="DML（增删改表中数据）">DML（增删改表中数据）</h2>
<h3 id="添加数据">添加数据</h3>
<ol>
<li>指定列名添加数据：insert into 表名(列名 1, 列名 2,…列名 n) values (值 1, 值 2,…值 n);</li>
<li>给所有列添加值：insert into 表名 values (值 1, 值 2,…值 n);</li>
<li>从表 2 查询向表 1 添加数据：insert into 表名 1(列名 1, 列名 2,…列名 n) select 字段 1, 字段 2,…字段 n from 表名 2;</li>
</ol>
<p><strong>注意</strong></p>
<ol>
<li>列名和值要一一对应</li>
<li>除了数字类型，其他类型需要使用引号（单双引号）都可以</li>
</ol>
<h3 id="删除数据">删除数据</h3>
<ol>
<li>删除符合条件的数据：delete from 表名 where 条件;</li>
<li>删除所有数据：delete from 表名;</li>
<li>删除表结构和数据：truncate table 表名;（不可以加条件语句）</li>
</ol>
<h3 id="修改数据">修改数据</h3>
<ol>
<li>更新符合条件的数据：update 表名 set 列名 1 = 值 1, 列名 2 = 值 2, …  where 条件;</li>
<li>更新所有数据：update 表名 set 列名 1 = 值 1, 列名 2 = 值 2, …</li>
</ol>
<h2 id="DQL（查询表中的数据）">DQL（查询表中的数据）</h2>
<h3 id="语法结构">语法结构</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 字段列表</span><br><span class="line">from 表名列表</span><br><span class="line">where 条件列表</span><br><span class="line">group by 分组列表</span><br><span class="line">having 分组之后的条件</span><br><span class="line">order by 排序方式</span><br><span class="line">limit 分页限定</span><br></pre></td></tr></table></figure>
<p>注意：执行顺序如下</p>
<ol>
<li>from</li>
<li>where</li>
<li>group by</li>
<li>having</li>
<li>select</li>
<li>order by</li>
<li>limit</li>
</ol>
<h3 id="基础查询">基础查询</h3>
<h4 id="多字段查询">多字段查询</h4>
<ol>
<li>查询指定字段数据：select 字段名 1, 字段名 2 …  from 表名;</li>
<li>查询所有数据：select * from 表名;</li>
</ol>
<h4 id="去除重复值（distinct）">去除重复值（distinct）</h4>
<ol>
<li>select distinct 字段名 1, 字段名 2 …  from 表名;</li>
<li>select distinct 字段名 1, distinct 字段名 2 …  from 表名;</li>
</ol>
<h4 id="计算列（ifnull）">计算列（ifnull）</h4>
<p>select 字段名 1, 字段名 2 …  字段名 1+字段名 2  from  表名;（一般只会进行数值型的计算）</p>
<p><strong>注意</strong></p>
<p>ifnull(表达式 1, 表达式 2)：null 参与的运算，计算结果都为 null，所以要使用 ifnull</p>
<ul>
<li>表达式 1：哪个字段需要判断是否为 null</li>
<li>表达式 2：如果该字段为 null 后的替换值</li>
</ul>
<h4 id="起别名（as）">起别名（as）</h4>
<ol>
<li>select  字段名 1 as 别名, 字段名 2 …  from 表名 as 别名;（注意：as 也可以省略）</li>
<li>select  字段名 1 别名, 字段名 2 …  from 表名 别名;</li>
</ol>
<h3 id="条件查询">条件查询</h3>
<p>运算符：</p>
<ol>
<li>
<p>&gt;、&lt;、&lt;=、&gt; =、=、&lt;&gt; 表示不等于</p>
</li>
<li>
<p>BETWEEN…AND</p>
</li>
<li>
<p>LIKE：模糊查询（占位符如下）</p>
</li>
</ol>
<ul>
<li>_：单个任意字符</li>
<li>%：任意字符</li>
<li>[]：用来指定一个字符集，它必须匹配指定位置（通配符的位置）的一个字符，可以用前缀字符^来否定</li>
</ul>
<ol start="4">
<li>IS  NULL</li>
<li>and 或&amp;&amp;</li>
<li>or 或||</li>
<li>not 或！</li>
<li>IN( 集合 )</li>
</ol>
<h3 id="排序查询">排序查询</h3>
<p>order by 字段 1 排序方式 1, …字段 n  排序方式 n</p>
<p>排序方式：</p>
<ol>
<li>ASC：升序，默认的</li>
<li>DESC：降序</li>
</ol>
<h3 id="聚合函数">聚合函数</h3>
<ol>
<li>count（计算个数）</li>
<li>max（计算最大值）</li>
<li>min（计算最小值）</li>
<li>sum（计算和）</li>
<li>avg（计算平均值）</li>
</ol>
<p>注意：聚合函数的计算，要排除 null 值时，可以使用下面解决方法</p>
<ol>
<li>选择不包含非空的列进行计算</li>
<li>IFNULL 函数</li>
</ol>
<h3 id="分组查询">分组查询</h3>
<p>group by 字段 1, 字段 2…</p>
<p>注意：</p>
<ol>
<li>分组之后查询的字段必须是：分组字段、聚合函数</li>
<li>where 和 having 的区别：</li>
</ol>
<ul>
<li>where 在分组之前进行限定，如果不满足条件，则不参与分组</li>
<li>where 后不可以跟聚合函数</li>
<li>having 在分组之后进行限定，如果不满足条件，则不会被查询出来</li>
<li>having 可以进行聚合函数的判断</li>
</ul>
<h3 id="分页查询">分页查询</h3>
<p>limit  开始的索引, 每页查询的条数</p>
<p>公式：开始的索引 =（当前的页码-1）* 每页显示的条数</p>
<h3 id="多表查询">多表查询</h3>
<h4 id="自然连接">自然连接</h4>
<p>select  …  from 表名 1 natural join 表名 2</p>
<p>注意：自然连接是一种特殊的等值连接，他要求两个关系表中进行连接的必须是相同的属性列（名字相同），无须添加连接条件，并且在结果中消除重复的属性列</p>
<h4 id="内连接查询">内连接查询</h4>
<ol>
<li>隐式内连接（使用 where 条件消除无用数据）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 别名.字段名,.....</span><br><span class="line">from 表名 别名,......</span><br><span class="line">where 别名.字段名=别名.字段名,.....;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>显式内连接</li>
</ol>
<p>select 字段列表 from 表名 1 inner(可选)  join 表名 2 on 条件;</p>
<h4 id="外连接查询">外连接查询</h4>
<ol>
<li>全外连接（看两边表）</li>
</ol>
<p>select 字段列表 from 表名 1 full outer(可选)  join 表 2 on 条件;</p>
<ol start="2">
<li>左外连接（看左边表）：查询的是左表所有数据以及其交集部分</li>
</ol>
<p>select 字段列表 from 表名 1 left outer(可选)  join  表 2 on 条件;</p>
<p>注意：若在左表的某行在右表中没有匹配的行，则在相关联的结果集行中右表的所有选择列均为空值</p>
<ol start="3">
<li>右外连接（看右边表）：查询的是右表所有数据以及其交集部分</li>
</ol>
<p>select 字段列表 from 表名 1 right outer(可选)  join 表 2 on 条件;</p>
<p>注意：若在右表的某行在左表中没有匹配的行，则在相关联的结果集行中左表的所有选择列均为空值</p>
<h4 id="子查询">子查询</h4>
<ol>
<li>子查询的结果是单行单列的</li>
</ol>
<p>子查询可以作为条件，使用运算符去判断，运算符：&gt;、&lt;、&gt; =、&lt;=、=</p>
<ol start="2">
<li>子查询的结果是多行单列的</li>
</ol>
<p>子查询可以作为条件，使用运算符 in 来判断</p>
<ol start="3">
<li>子查询的结果是多行多列的</li>
</ol>
<p>子查询可以作为一张虚拟表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例子：查询工资最高的员工信息</span><br><span class="line">select * from emp where emp.&#x27;salary&#x27;=(select max(salary) from emp);</span><br></pre></td></tr></table></figure>
<h2 id="DCL（用户和权限管理）">DCL（用户和权限管理）</h2>
<h3 id="用户管理">用户管理</h3>
<h4 id="添加用户">添加用户</h4>
<p>create user ‘用户名’@‘主机名’ identified by ‘密码’;</p>
<h4 id="删除用户">删除用户</h4>
<p>drop user ‘用户名’@‘主机名’;</p>
<h4 id="修改用户密码">修改用户密码</h4>
<ol>
<li>update user set password = password(‘新密码’) where user =‘用户名’;</li>
<li>set password for ‘用户名’@‘主机名’= password(‘新密码’);</li>
</ol>
<p><strong>MySQL 中忘记了 root 用户的密码时</strong></p>
<ol>
<li>停止 MySQL 服务（需要管理员运行 cmd）：net  stop  mysql</li>
<li>使用无验证方式启动 MySQL 服务：mysqld  --skip-grant-tables</li>
<li>打开新的 cmd 窗口，直接输入 mysql 命令，敲回车，就可以登录成功</li>
<li>use  mysql;</li>
<li>update  user  set  password = password( ‘新密码’ )  where  user = ‘root’;</li>
<li>关闭两个窗口；</li>
<li>打开任务管理器，手动结束 mysqld.exe 的进程</li>
<li>启动 mysql 服务</li>
<li>使用新密码登录</li>
</ol>
<h4 id="查询用户">查询用户</h4>
<ol>
<li>切换到 MySQL 数据库：use mysql;</li>
<li>查询 user 表：select *  from user;</li>
</ol>
<h3 id="权限管理">权限管理</h3>
<h4 id="查询权限">查询权限</h4>
<p>show grants for ‘用户名’@‘主机名’;</p>
<h4 id="授予权限">授予权限</h4>
<p>grant 权限列表 on 数据库名.表名 to ‘用户名’@‘主机名’;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例子：给张三用户授予所有权限，在任意数据库任意表上</span><br><span class="line">grant all on *.* to &#x27;zhangsan&#x27;@&#x27;localhost&#x27;;</span><br></pre></td></tr></table></figure>
<h4 id="撤销权限">撤销权限</h4>
<p>revoke 权限列表 on 数据库名.表名 from ‘用户名’@‘主机名’;</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringSecurity5（2-自定义用户信息）</title>
    <url>/blog/2024/12/30/Java/SpringSecurity/SpringSecurity5/SpringSecurity5%EF%BC%882-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%EF%BC%89/</url>
    <content><![CDATA[<h2 id="配置文件自定义用户名和密码">配置文件自定义用户名和密码</h2>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">root</span>    <span class="comment">#通过配置文件，设置静态用户名</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">root</span>    <span class="comment">#配置文件，设置静态登录密码</span></span><br></pre></td></tr></table></figure>
<h3 id="SecurityProperties">SecurityProperties</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.security&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityProperties</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BASIC_AUTH_ORDER</span> <span class="operator">=</span> Ordered.LOWEST_PRECEDENCE - <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">IGNORED_ORDER</span> <span class="operator">=</span> Ordered.HIGHEST_PRECEDENCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_FILTER_ORDER</span> <span class="operator">=</span> OrderedFilter.REQUEST_WRAPPER_FILTER_MAX_ORDER - <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Filter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Filter</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Filter <span class="title function_">getFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.filter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">order</span> <span class="operator">=</span> DEFAULT_FILTER_ORDER;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Set&lt;DispatcherType&gt; dispatcherTypes = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(</span><br><span class="line">                Arrays.asList(DispatcherType.ASYNC, DispatcherType.ERROR, DispatcherType.REQUEST));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.order;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOrder</span><span class="params">(<span class="type">int</span> order)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.order = order;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Set&lt;DispatcherType&gt; <span class="title function_">getDispatcherTypes</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.dispatcherTypes;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDispatcherTypes</span><span class="params">(Set&lt;DispatcherType&gt; dispatcherTypes)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.dispatcherTypes = dispatcherTypes;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;user&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> List&lt;String&gt; roles = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">passwordGenerated</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.password;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPassword</span><span class="params">(String password)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!StringUtils.hasLength(password)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.passwordGenerated = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.password = password;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getRoles</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.roles;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoles</span><span class="params">(List&lt;String&gt; roles)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.roles = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(roles);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPasswordGenerated</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.passwordGenerated;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SecuityProperties 会获取配置文件中的信息，UserDetailsServiceAutoConfiguration 在自动装配时获取 SecuityProperties 的属性信息</p>
<h3 id="UserDetailsServiceAutoConfiguration">UserDetailsServiceAutoConfiguration</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(AuthenticationManager.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(ObjectPostProcessor.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(</span></span><br><span class="line"><span class="meta">    value = &#123; AuthenticationManager.class, AuthenticationProvider.class, UserDetailsService.class &#125;,</span></span><br><span class="line"><span class="meta">    type = &#123; &quot;org.springframework.security.oauth2.jwt.JwtDecoder&quot;, &quot;org.springframework.security.oauth2.server.resource.introspection.OpaqueTokenIntrospector&quot; &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDetailsServiceAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NOOP_PASSWORD_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;&#123;noop&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Pattern</span> <span class="variable">PASSWORD_ALGORITHM_PATTERN</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;^\\&#123;.+&#125;.*$&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Log</span> <span class="variable">logger</span> <span class="operator">=</span> LogFactory.getLog(UserDetailsServiceAutoConfiguration.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(</span></span><br><span class="line"><span class="meta">            type = &quot;org.springframework.security.oauth2.client.registration.ClientRegistrationRepository&quot;)</span></span><br><span class="line">    <span class="meta">@Lazy</span></span><br><span class="line">    <span class="keyword">public</span> InMemoryUserDetailsManager <span class="title function_">inMemoryUserDetailsManager</span><span class="params">(SecurityProperties properties,</span></span><br><span class="line"><span class="params">            ObjectProvider&lt;PasswordEncoder&gt; passwordEncoder)</span> &#123;</span><br><span class="line">        SecurityProperties.<span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> properties.getUser();</span><br><span class="line">        List&lt;String&gt; roles = user.getRoles();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InMemoryUserDetailsManager</span>(</span><br><span class="line">                User.withUsername(user.getName()).password(getOrDeducePassword(user, passwordEncoder.getIfAvailable()))</span><br><span class="line">                        .roles(StringUtils.toStringArray(roles)).build());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getOrDeducePassword</span><span class="params">(SecurityProperties.User user, PasswordEncoder encoder)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> user.getPassword();</span><br><span class="line">        <span class="keyword">if</span> (user.isPasswordGenerated()) &#123;</span><br><span class="line">            logger.info(String.format(<span class="string">&quot;%n%nUsing generated security password: %s%n&quot;</span>, user.getPassword()));</span><br><span class="line">        &#125;	</span><br><span class="line">        <span class="keyword">if</span> (encoder != <span class="literal">null</span> || PASSWORD_ALGORITHM_PATTERN.matcher(password).matches()) &#123;</span><br><span class="line">            <span class="keyword">return</span> password;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> NOOP_PASSWORD_PREFIX + password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当容器中没有 AuthenticationManager、AuthenticationProvider、UserDetailsService 对应的实例类，且没有 org.springframework.security.oauth2.client.registration.ClientRegistrationRepository 时，会实例化 InMemoryUserDetailsManager 从而获取 SecurityProperties 的配置信息，加载用户信息在内存中</p>
<h2 id="基于内存存储认证信息">基于内存存储认证信息</h2>
<ol>
<li>在 Spring Security 5.0 版本前，加密的 PasswordEncoder 接口默认实现类为 NoOpPasswordEncoder ，这个是可以不用加密的，直接使用明文密码存储。当前已经标注过时了。</li>
<li>在 Spring Security 5.0 版本后 ，默认实现类改为了 DelegatingPasswordEncoder，这个实现类要求我们必须对加密后存储，如果不加密处理则会报错。</li>
</ol>
<h3 id="基本使用">基本使用</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 密码编码器，密码不能明文存储</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 设置默认的加密方式，使用 BCryptPasswordEncoder 密码编码器，</span></span><br><span class="line">        <span class="comment">// 该编码器会将随机产生的 salt 混入最终生成的密文中</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定制基于 HTTP 请求的用户访问控制</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * fromLogin()：表单认证</span></span><br><span class="line"><span class="comment">         * httpBasic()：弹出框认证</span></span><br><span class="line"><span class="comment">         * authorizeRequests()：身份认证请求</span></span><br><span class="line"><span class="comment">         * anyRequest()：所有请求</span></span><br><span class="line"><span class="comment">         * authenticated()：身份认证</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        http.httpBasic()</span><br><span class="line">                .and()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                <span class="comment">// 其它任何请求访问都需要先通过认证</span></span><br><span class="line">                .anyRequest()</span><br><span class="line">                .authenticated();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 认证管理器：</span></span><br><span class="line"><span class="comment">    * 1、认证信息提供方式（用户名、密码、当前用户的资源权限）</span></span><br><span class="line"><span class="comment">    * 2、可采用内存存储方式，也可能采用数据库方式等</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 用户信息存储在内存中</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> passwordEncoder().encode(<span class="string">&quot;1234&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;加密之后存储的密码：&quot;</span> + password);</span><br><span class="line">        auth.inMemoryAuthentication()</span><br><span class="line">            .withUser(<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">            .password(password)</span><br><span class="line">            .authorities(<span class="string">&quot;ADMIN&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定制一些全局性的安全配置，例如：不拦截静态资源的访问</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 静态资源的访问不需要拦截，直接放行</span></span><br><span class="line">        web.ignoring().antMatchers(<span class="string">&quot;/**/*.css&quot;</span>, <span class="string">&quot;/**/*.js&quot;</span>, <span class="string">&quot;/**/*.png&quot;</span>, <span class="string">&quot;/**/*.jpg&quot;</span>, <span class="string">&quot;/**/*.jpeg&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="加密处理分析">加密处理分析</h3>
<p><img src="4.png" alt=""></p>
<p><img src="1.png" alt=""></p>
<p><img src="2.png" alt=""></p>
<p><img src="3.png" alt=""></p>
<h2 id="UserDetailsService-自定义登录请求">UserDetailsService 自定义登录请求</h2>
<p>在实际开发中，Spring Security 应该动态的从数据库中获取信息进行自定义身份认证，采用数据库方式进行身份认证一般需要实现两个核心接口 UserDetailsService 和 UserDetails</p>
<h3 id="UserDetailService-接口">UserDetailService 接口</h3>
<p>该接口只有一个方法 loadUserByUsername()，用于定义从数据库中获取指定用户信息的逻辑。如果未获取到用户信息，则需要手动抛出 UsernameNotFoundException 异常；如果获取到用户信息，则将该用户信息封装到 UserDetails 接口的实现类中并返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line">    <span class="comment">// 输入参数 username 是前端传入的用户名</span></span><br><span class="line">    UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="UserDetails-接口">UserDetails 接口</h3>
<p>UserDetails 接口定义了用于描述用户信息的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDetails</span> <span class="keyword">extends</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">// 返回用户权限集合</span></span><br><span class="line">    Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回用户的密码</span></span><br><span class="line">    String <span class="title function_">getPassword</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回用户的用户名</span></span><br><span class="line">    String <span class="title function_">getUsername</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 账户是否未过期（true 未过期, false 过期）</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAccountNonExpired</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 账户是否未锁定（true 未锁定, false 锁定）</span></span><br><span class="line">    <span class="comment">// 用户账户可能会被封锁，达到一定要求可恢复</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAccountNonLocked</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 密码是否未过期（true 未过期, false 过期）</span></span><br><span class="line">    <span class="comment">// 一些安全级别高的系统，可能要求 30 天更换一次密码</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCredentialsNonExpired</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 账户是否可用（true 可用, false 不可用）</span></span><br><span class="line">    <span class="comment">// 系统一般不会真正的删除用户信息，而是假删除，通过一个状态码标志用户是否被删除</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="用户登录逻辑处理">用户登录逻辑处理</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDetailServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Spring Security 接收 login 请求调用 UserDetailService 这个接口中的 loadUserByUsername</span></span><br><span class="line"><span class="comment">     * loadUserByUsername 根据传进来的用户名进行校验工作，</span></span><br><span class="line"><span class="comment">     * 最后将查询到的用户信息封装到 UserDetails 这个接口的实现类中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String s)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;登录用户名：&#123;&#125;&quot;</span>,s);</span><br><span class="line">        <span class="comment">//根据用户名查询用户数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(s,<span class="string">&quot;123456&quot;</span>, AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="string">&quot;admin&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用了 Spring Security5.x 版本，需要手动提供一个 PasswordEncoder 实现类，进行密码校验，PasswordEncoder 是 SpringSecurity 的密码解析器，用户密码校验、加密，自定义登录逻辑时要求必须给容器注入 PasswordEncoder 的 bean 对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PasswordEncoderImpl</span> <span class="keyword">implements</span> <span class="title class_">PasswordEncoder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">encode</span><span class="params">(CharSequence charSequence)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> charSequence.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(CharSequence charSequence, String s)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s.equals(charSequence.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PasswordEncoder passwordEncoder;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定制基于 HTTP 请求的用户访问控制</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * fromLogin()：表单认证</span></span><br><span class="line"><span class="comment">         * httpBasic()：弹出框认证</span></span><br><span class="line"><span class="comment">         * authorizeRequests()：身份认证请求</span></span><br><span class="line"><span class="comment">         * anyRequest()：所有请求</span></span><br><span class="line"><span class="comment">         * authenticated()：身份认证</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        http.httpBasic()</span><br><span class="line">                .and()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">            	<span class="comment">// 其它任何请求访问都需要先通过认证</span></span><br><span class="line">                .anyRequest()</span><br><span class="line">                .authenticated();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 认证管理器：</span></span><br><span class="line"><span class="comment">    * 1、认证信息提供方式（用户名、密码、当前用户的资源权限）</span></span><br><span class="line"><span class="comment">    * 2、可采用内存存储方式，也可能采用数据库方式等</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 不再使用内存方式存储用户认证信息，而是动态从数据库中获取</span></span><br><span class="line">        auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定制一些全局性的安全配置，例如：不拦截静态资源的访问</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 静态资源的访问不需要拦截，直接放行</span></span><br><span class="line">        web.ignoring().antMatchers(<span class="string">&quot;/**/*.css&quot;</span>, <span class="string">&quot;/**/*.js&quot;</span>, <span class="string">&quot;/**/*.png&quot;</span>, <span class="string">&quot;/**/*.jpg&quot;</span>, <span class="string">&quot;/**/*.jpeg&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<p>上面自定义的密码解析器密码加密后与原来的一致，如果使用其他的密码解析器密码加密后与原来的不一致时，采用以下方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 密码编码器，密码不能明文存储</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> BCryptPasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 BCryptPasswordEncoder 密码编码器，该编码器会将随机产生的 salt 混入最终生成的密文中</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    auth.userDetailsService(userDetailService).passwordEncoder(passwordEncoder());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDetailServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Spring Security 接收 login 请求调用 UserDetailService 这个接口中的 loadUserByUsername</span></span><br><span class="line"><span class="comment">     * loadUserByUsername 根据传进来的用户名进行校验工作，</span></span><br><span class="line"><span class="comment">     * 最后将查询到的用户信息封装到 UserDetails 这个接口的实现类中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String s)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;登录用户名：&#123;&#125;&quot;</span>,s);</span><br><span class="line">        <span class="comment">//根据用户名查询用户数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(s, passwordEncoder.encode(<span class="string">&quot;123456&quot;</span>), AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="string">&quot;admin&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义返回-UserDetails-信息">自定义返回 UserDetails 信息</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountUser</span> <span class="keyword">implements</span> <span class="title class_">UserDetails</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">540L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Log</span> <span class="variable">logger</span> <span class="operator">=</span> LogFactory.getLog(User.class);</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String username;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; authorities;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> accountNonExpired;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> accountNonLocked;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> credentialsNonExpired;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> enabled;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AccountUser</span><span class="params">(Long userId, String username, String password, Collection&lt;? extends GrantedAuthority&gt; authorities)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(userId, username, password, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>, authorities);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AccountUser</span><span class="params">(Long userId, String username, String password, <span class="type">boolean</span> enabled, <span class="type">boolean</span> accountNonExpired, <span class="type">boolean</span> credentialsNonExpired, <span class="type">boolean</span> accountNonLocked, Collection&lt;? extends GrantedAuthority&gt; authorities)</span> &#123;</span><br><span class="line">        Assert.isTrue(username != <span class="literal">null</span> &amp;&amp; !<span class="string">&quot;&quot;</span>.equals(username) &amp;&amp; password != <span class="literal">null</span>, <span class="string">&quot;Cannot pass null or empty values to constructor&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.userId = userId;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">        <span class="built_in">this</span>.enabled = enabled;</span><br><span class="line">        <span class="built_in">this</span>.accountNonExpired = accountNonExpired;</span><br><span class="line">        <span class="built_in">this</span>.credentialsNonExpired = credentialsNonExpired;</span><br><span class="line">        <span class="built_in">this</span>.accountNonLocked = accountNonLocked;</span><br><span class="line">        <span class="built_in">this</span>.authorities = authorities;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.authorities;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.accountNonExpired;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonLocked</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.accountNonLocked;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCredentialsNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.credentialsNonExpired;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.enabled;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDetailServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span>.equals(username)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AccountUser</span>(<span class="number">12L</span>, <span class="string">&quot;admin&quot;</span>, passwordEncoder.encode(<span class="string">&quot;123&quot;</span>), AuthorityUtils.NO_AUTHORITIES);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailServiceImpl userDetailService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http.formLogin()</span><br><span class="line">                .and()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .anyRequest()</span><br><span class="line">                .authenticated();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        auth.userDetailsService(userDetailService);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringSecurity5（1-快速入门）</title>
    <url>/blog/2024/12/29/Java/SpringSecurity/SpringSecurity5/SpringSecurity5%EF%BC%881-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%89/</url>
    <content><![CDATA[<h2 id="依赖">依赖</h2>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="登录认证">登录认证</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：导入依赖之后，访问 localhost: 8080/test 请求地址会自动跳转到 localhost: 8080/test 中，出现一个表单，需要登录后才能访问</p>
<p>用户名默认为 user，密码在控制台出现</p>
<p><img src="1.png" alt=""></p>
<p><img src="2.png" alt=""></p>
<h2 id="将表单请求转换为弹出框请求">将表单请求转换为弹出框请求</h2>
<p><strong>WebSecurityConfigurerAdapter</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定制用户认证管理器来实现用户认证</span></span><br><span class="line"><span class="comment"> *  1. 提供用户认证所需信息（用户名、密码、当前用户的资源权）</span></span><br><span class="line"><span class="comment"> *  2. 可采用内存存储方式，也可能采用数据库方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定制基于 HTTP 请求的用户访问控制</span></span><br><span class="line"><span class="comment"> *  1. 配置拦截的哪一些资源</span></span><br><span class="line"><span class="comment"> *  2. 配置资源所对应的角色权限</span></span><br><span class="line"><span class="comment"> *  3. 定义认证方式：HttpBasic、HttpForm</span></span><br><span class="line"><span class="comment"> *  4. 定制登录页面、登录请求地址、错误处理方式</span></span><br><span class="line"><span class="comment"> *  5. 自定义 Spring Security 过滤器等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定制一些全局性的安全配置，例如：不拦截静态资源的访问</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(WebSecurity web)</span>;</span><br></pre></td></tr></table></figure>
<p><strong>使用案例</strong></p>
<ol>
<li>创建配置类继承 WebSecurityConfigurerAdapter 类，实现 http 的 configure 方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * fromLogin()：表单认证</span></span><br><span class="line"><span class="comment">         * httpBasic()：弹出框认证</span></span><br><span class="line"><span class="comment">         * authorizeRequests()：身份认证请求</span></span><br><span class="line"><span class="comment">         * anyRequest()：所有请求</span></span><br><span class="line"><span class="comment">         * authenticated()：身份认证</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        http.httpBasic()</span><br><span class="line">                .and()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                <span class="comment">// 其它任何请求访问都需要先通过认证</span></span><br><span class="line">                .anyRequest()</span><br><span class="line">                .authenticated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>访问地址：localhost: 8080/test，此时发现表单请求转换为弹出框请求</li>
</ol>
<p><img src="3.png" alt=""></p>
<h2 id="路径匹配器">路径匹配器</h2>
<h3 id="MvcRequestMatcher">MvcRequestMatcher</h3>
<h4 id="匹配规则">匹配规则</h4>
<ol>
<li>/a：仅匹配路径/a</li>
<li>/a/*：操作符* 会替换一个路径名。在这种情况下，它将匹配/a/b 或/a/c，而不是/a/b/c</li>
<li>/a/**：操作符** 会替换多个路径名。在这种情况下，/a 以及/a/b 和/a/b/c 都是这个表达式的匹配项</li>
<li>/a/{param}：这个表达式适用于具有给定路径参数的路径/a</li>
<li>/a/{param: regex}：只有当参数的值与给定正则表达式匹配时，此表达式才应用于具有给定路径参数的路径/a</li>
</ol>
<h4 id="使用案例">使用案例</h4>
<ol>
<li>单个请求无请求方法匹配</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">http.authorizeRequests() </span><br><span class="line">    .mvcMatchers(<span class="string">&quot;/hello_user&quot;</span>).hasRole(<span class="string">&quot;USER&quot;</span>) </span><br><span class="line">    .mvcMatchers(<span class="string">&quot;/hello_admin&quot;</span>).hasRole(<span class="string">&quot;ADMIN&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>如果使用角色为“USER”的用户来访问“/hello_admin”端点，那么会出现禁止访问的情况，因为“/hello_admin”端点只有角色为“ADMIN”的用户才能访问</p>
<p>注意：没有被 MVC 匹配器所匹配的端点，其访问不受任何的限制，效果相当于如下所示的配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">http.authorizeRequests() </span><br><span class="line">    .mvcMatchers(<span class="string">&quot;/hello_user&quot;</span>).hasRole(<span class="string">&quot;USER&quot;</span>) </span><br><span class="line">    .mvcMatchers(<span class="string">&quot;/hello_admin&quot;</span>).hasRole(<span class="string">&quot;ADMIN&quot;</span>);</span><br><span class="line">    .anyRequest().permitAll();</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>单个请求有请求方法匹配</li>
</ol>
<p>如果一个 Controller 中存在两个路径完全一样的 HTTP 端点，可以把 HTTP 方法作为一个访问的维度进行控制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">http.authorizeRequests() </span><br><span class="line">    .mvcMatchers(HttpMethod.POST, <span class="string">&quot;/hello&quot;</span>).authenticated() </span><br><span class="line">    .mvcMatchers(HttpMethod.GET, <span class="string">&quot;/hello&quot;</span>).permitAll() </span><br><span class="line">    .anyRequest().denyAll();</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>多个路径匹配</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">http.authorizeRequests() </span><br><span class="line">	.mvcMatchers(<span class="string">&quot;/test/xiao&quot;</span>,<span class="string">&quot;/test/giao&quot;</span>,<span class="string">&quot;/test/a&quot;</span>,<span class="string">&quot;/test/a/b&quot;</span>).hasRole(<span class="string">&quot;ADMIN&quot;</span>);</span><br><span class="line"><span class="comment">//可以简化为以下方式</span></span><br><span class="line">http.authorizeRequests() </span><br><span class="line">	.mvcMatchers(<span class="string">&quot;/test/**&quot;</span>).hasRole(<span class="string">&quot;ADMIN&quot;</span>);</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>带有路径变量匹配</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/product/&#123;code&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">productCode</span><span class="params">(<span class="meta">@PathVariable</span> String code)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">http.authorizeRequests() </span><br><span class="line">	.mvcMatchers(<span class="string">&quot;/product/&#123;code:^[0-9]*$&#125;&quot;</span>).permitAll();</span><br></pre></td></tr></table></figure>
<p>此时调用端点，假设 code = 1234a，不符合全部都是数字，报 401；然后再次调用端点，code = 12345，发现调用通过</p>
<h3 id="AntPathRequestMatcher">AntPathRequestMatcher</h3>
<p>Ant 匹配器的表现形式和使用方法与前面介绍的 MVC 匹配器非常相似</p>
<p>使用方法：</p>
<ol>
<li>antMatchers(String patterns)</li>
<li>antMatchers(HttpMethod method)</li>
<li>antMatchers(HttpMethod method, String patterns)</li>
</ol>
<p><strong>mvc 与 ant 匹配器的区别</strong></p>
<ol>
<li>antMatchers(“/secured”)仅仅匹配 /secured</li>
<li>mvcMatchers(“/secured”)匹配 /secured 之余还匹配 /secured/，/secured.html，/secured.xyz</li>
</ol>
<p>因此 mvcMatcher 更加通用且容错性更高</p>
<h3 id="RegexRequestMatcher">RegexRequestMatcher</h3>
<p>使用方法：</p>
<ol>
<li>regexMatchers(HttpMethod method, String regex)</li>
<li>regexMatchers(String regex)</li>
</ol>
<p>使用这一匹配器的主要优势在于它能够基于复杂的正则表达式对请求地址进行匹配，这是 MVC 匹配器和 Ant 匹配器无法实现的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">http.authorizeRequests() </span><br><span class="line">	<span class="comment">//只有输入的请求是一个合法的邮箱地址才能允许访问</span></span><br><span class="line">	.regexMatchers(<span class="string">&quot;/email/&#123;email:.*(.+@.+\\.com)&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringSecurity5（4-自定义登录、登出处理器）</title>
    <url>/blog/2025/02/07/Java/SpringSecurity/SpringSecurity5/SpringSecurity5%EF%BC%884-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%99%BB%E5%BD%95%E3%80%81%E7%99%BB%E5%87%BA%E5%A4%84%E7%90%86%E5%99%A8%EF%BC%89/</url>
    <content><![CDATA[<h2 id="自定义登录页面">自定义登录页面</h2>
<h3 id="常用方法">常用方法</h3>
<p><strong>http.formLogin()</strong></p>
<ol>
<li>loginPage(String loginPage)：设置用户登录页面的访问路径，默认为 GET 请求的 /login</li>
<li>loginProcessingUrl(String loginProcessingUrl)：设置登录表单提交的路径，默认为是 POST 请求的 loginPage() 设置的路径</li>
<li>successForwardUrl(String forwordUrl)：设置用户认证成功后转发的地址</li>
<li>successHandler(AuthenticationSuccessHandler successHandler)：配置用户认证成功后的自定义处理器</li>
<li>defaultSuccessUrl(String defaultSuccessUrl)：设置用户认证成功后重定向的地址。这里需要注意，该路径是用户直接访问登录页面认证成功后重定向的路径，如果是其他路径跳转到登录页面认证成功后会重定向到原始访问路径。可设置第二个参数为 true，使认证成功后始终重定向到该地址</li>
<li>failureForwrad(String forwardUrl)：设置用户认证失败后转发的地址</li>
<li>failureHandler(AuthenticationFailureHandler authenticationFailureHandler)：设置用户登录失败后的自定义错误处理器</li>
<li>failureUrl(String authenticationFailureUrl)：设置用户登录失败后重定向的地址，指定的路径要能匿名访问，默认为 loginPage() + ?error</li>
<li>usernameParamter(String usernameParamter)：设置登录表单中的用户名参数，默认为 username</li>
<li>passwordParamter(String passwordParamter)：设置登录表单中的密码参数，默认为 password</li>
</ol>
<h3 id="使用案例">使用案例</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">&quot;login-page&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/login&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>账户登录<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;用户名&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">required</span>=<span class="string">&quot;required&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;密码&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">required</span>=<span class="string">&quot;required&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * fromLogin()：表单认证</span></span><br><span class="line"><span class="comment">         * httpBasic()：弹出框认证</span></span><br><span class="line"><span class="comment">         * authorizeRequests()：身份认证请求</span></span><br><span class="line"><span class="comment">         * anyRequest()：所有请求</span></span><br><span class="line"><span class="comment">         * authenticated()：身份认证</span></span><br><span class="line"><span class="comment">         * loginPage()：登录页面地址</span></span><br><span class="line"><span class="comment">         * loginProcessingUrl()：登录表单提交地址</span></span><br><span class="line"><span class="comment">         * csrf().disable()：关闭 Spring Security 的跨站请求伪造的功能</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        http.csrf().disable()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .loginPage(<span class="string">&quot;/login.html&quot;</span>)</span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line">                .and()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">&quot;/login.html&quot;</span>).permitAll()</span><br><span class="line">                .anyRequest()</span><br><span class="line">                .authenticated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：SpringBoot 项目集成 Spring Security 5.3.4RELEASE 后，默认情况 crsf 是开启的。每次请求会校验请求头中 X-CSRF-TOKEN 的值与内存中保存的是否一致，如果一致框架则认为登录页面是安全的，如果不一致，会报 403。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/login.html&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">login</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>转发</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">http.formLogin()</span><br><span class="line">    .usernameParameter(<span class="string">&quot;name&quot;</span>) <span class="comment">// 设置请求参数中，用户名参数名称。 默认 username</span></span><br><span class="line">    .passwordParameter(<span class="string">&quot;pswd&quot;</span>) <span class="comment">// 设置请求参数中，密码参数名称。 默认 password</span></span><br><span class="line">    .loginPage(<span class="string">&quot;/toLogin&quot;</span>) <span class="comment">// 当用户未登录的时候，跳转的登录页面地址是什么？ 默认 /login</span></span><br><span class="line">    .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>) <span class="comment">// 用户登录逻辑请求地址是什么。 默认是 /login</span></span><br><span class="line">    .failureForwardUrl(<span class="string">&quot;/failure&quot;</span>); <span class="comment">// 登录失败后，请求转发的位置。Security 请求转发使用 Post 请求。默认转发到：loginPage?error</span></span><br><span class="line">    .successForwardUrl(<span class="string">&quot;/toMain&quot;</span>); <span class="comment">// 用户登录成功后，请求转发到的位置。Security 请求转发使用 POST 请求。</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>重定向</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">http.formLogin()</span><br><span class="line">    .usernameParameter(<span class="string">&quot;name&quot;</span>) <span class="comment">// 设置请求参数中，用户名参数名称。 默认 username</span></span><br><span class="line">    .passwordParameter(<span class="string">&quot;pswd&quot;</span>) <span class="comment">// 设置请求参数中，密码参数名称。 默认 password</span></span><br><span class="line">    .loginPage(<span class="string">&quot;/toLogin&quot;</span>) <span class="comment">// 当用户未登录的时候，跳转的登录页面地址是什么？ 默认 /login</span></span><br><span class="line">    .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>) <span class="comment">// 用户登录逻辑请求地址是什么。 默认是 /login</span></span><br><span class="line">    .defaultSuccessUrl(<span class="string">&quot;/toMain&quot;</span>,<span class="literal">true</span>); <span class="comment">//用户登录成功后，响应重定向到的位置。GET 请求。必须配置绝对地址。</span></span><br><span class="line">    .failureUrl(<span class="string">&quot;/failure&quot;</span>); <span class="comment">// 登录失败后，重定向的位置。</span></span><br></pre></td></tr></table></figure>
<h2 id="自定义登录处理器">自定义登录处理器</h2>
<h3 id="AuthenticationSuccessHandler">AuthenticationSuccessHandler</h3>
<p>用来处理认证成功的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AuthenticationSuccessHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationSuccess</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">            HttpServletResponse response, FilterChain chain, Authentication authentication)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, ServletException&#123;</span><br><span class="line">        onAuthenticationSuccess(request, response, authentication);</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onAuthenticationSuccess</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">            HttpServletResponse response, Authentication authentication)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, ServletException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthenticationSuccessHandlerImpl</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationSuccessHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationSuccess</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">        httpServletResponse.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">        httpServletResponse.getWriter().write(objectMapper.writeValueAsString(authentication));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AuthenticationFailureHandler">AuthenticationFailureHandler</h3>
<p>用来处理认证失败的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AuthenticationFailureHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onAuthenticationFailure</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">            HttpServletResponse response, AuthenticationException exception)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, ServletException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthenticationFailureHandlerImpl</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationFailureHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationFailure</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;登录失败&quot;</span>);</span><br><span class="line">        httpServletResponse.setStatus(HttpStatus.INTERNAL_SERVER_ERROR.value());</span><br><span class="line">        httpServletResponse.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">        httpServletResponse.getWriter().write(objectMapper.writeValueAsString(e));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SimpleUrlAuthenticationSuccessHandler">SimpleUrlAuthenticationSuccessHandler</h3>
<p>用来处理认证成功后跳转的 URL 信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleUrlAuthenticationSuccessHandler</span> <span class="keyword">extends</span></span><br><span class="line">		<span class="title class_">AbstractAuthenticationTargetUrlRequestHandler</span> <span class="keyword">implements</span></span><br><span class="line">		<span class="title class_">AuthenticationSuccessHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleUrlAuthenticationSuccessHandler</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleUrlAuthenticationSuccessHandler</span><span class="params">(String defaultTargetUrl)</span> &#123;</span><br><span class="line">        setDefaultTargetUrl(defaultTargetUrl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationSuccess</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">            HttpServletResponse response, Authentication authentication)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">        handle(request, response, authentication);</span><br><span class="line">        clearAuthenticationAttributes(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">clearAuthenticationAttributes</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (session == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        session.removeAttribute(WebAttributes.AUTHENTICATION_EXCEPTION);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用案例-2">使用案例</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationSuccessHandlerImpl authenticationSuccessHandler;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationFailureHandlerImpl authenticationFailureHandler;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * fromLogin()：表单认证</span></span><br><span class="line"><span class="comment">         * httpBasic()：弹出框认证</span></span><br><span class="line"><span class="comment">         * authorizeRequests()：身份认证请求</span></span><br><span class="line"><span class="comment">         * anyRequest()：所有请求</span></span><br><span class="line"><span class="comment">         * authenticated()：身份认证</span></span><br><span class="line"><span class="comment">         * loginPage()：登录页面地址</span></span><br><span class="line"><span class="comment">         * loginProcessingUrl()：登录表单提交地址</span></span><br><span class="line"><span class="comment">         * csrf().disable()：关闭 Spring Security 的跨站请求伪造的功能</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        http.csrf().disable()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .loginPage(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/auth/login&quot;</span>)</span><br><span class="line">                .successHandler(authenticationSuccessHandler)</span><br><span class="line">                .failureHandler(authenticationFailureHandler)</span><br><span class="line">                .and()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">&quot;/login&quot;</span>).permitAll()</span><br><span class="line">                .anyRequest()</span><br><span class="line">                .authenticated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义退出处理器">自定义退出处理器</h2>
<h3 id="LogoutSuccessHandler">LogoutSuccessHandler</h3>
<p>用来处理退出成功的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LogoutSuccessHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onLogoutSuccess</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">            Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLogOutSuccessHandler</span> <span class="keyword">implements</span> <span class="title class_">LogoutSuccessHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLogoutSuccess</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        httpServletResponse.setStatus(HttpStatus.UNAUTHORIZED.value());</span><br><span class="line">        httpServletResponse.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">        httpServletResponse.getWriter().write(<span class="string">&quot;退出成功，请重新登录&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SimpleUrlLogoutSuccessHandler">SimpleUrlLogoutSuccessHandler</h3>
<p>用来处理退出成功跳转的 URL 信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleUrlLogoutSuccessHandler</span> <span class="keyword">extends</span></span><br><span class="line">		<span class="title class_">AbstractAuthenticationTargetUrlRequestHandler</span> <span class="keyword">implements</span> <span class="title class_">LogoutSuccessHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLogoutSuccess</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">            Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="built_in">super</span>.handle(request, response, authentication);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="LogoutHandler">LogoutHandler</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">http.and()</span><br><span class="line">    .logout() <span class="comment">//提供系统退出支持，使用 WebSecurityConfigurerAdapter 会自动被应用</span></span><br><span class="line">    .logoutUrl(<span class="string">&quot;/logout&quot;</span>) <span class="comment">//默认退出地址</span></span><br><span class="line">    .logoutSuccessUrl(<span class="string">&quot;/login‐view?logout&quot;</span>) <span class="comment">//退出后的跳转地址</span></span><br><span class="line">    .addLogoutHandler(logoutHandler) <span class="comment">//添加一个 LogoutHandler，用于实现用户退出时的清理工作.默认 SecurityContextLogoutHandler 会被添加为最后一个 LogoutHandler 。</span></span><br><span class="line">    .invalidateHttpSession(<span class="literal">true</span>);  <span class="comment">//指定是否在退出时让 HttpSession 失效，默认是 true</span></span><br></pre></td></tr></table></figure>
<p>一般来说， LogoutHandler 的实现类被用来执行必要的清理，因而他们不应该抛出异常。</p>
<p>下面是 Spring Security 提供的一些实现：</p>
<ol>
<li>PersistentTokenBasedRememberMeServices：基于持久化 token 的 RememberMe 功能的相关清理</li>
<li>TokenBasedRememberMeService：基于 token 的 RememberMe 功能的相关清理</li>
<li>CookieClearingLogoutHandler：退出时 Cookie 的相关清理</li>
<li>CsrfLogoutHandler：负责在退出时移除 csrfToken</li>
<li>SecurityContextLogoutHandler：退出时 SecurityContext 的相关清理</li>
</ol>
<h3 id="使用案例-3">使用案例</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/signout/success&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">signout</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;退出成功，请重新登录&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationSuccessHandlerImpl authenticationSuccessHandler;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationFailureHandlerImpl authenticationFailureHandler;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> MyLogOutSuccessHandler logOutSuccessHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http.formLogin()</span><br><span class="line">            .successHandler(authenticationSuccessHandler)</span><br><span class="line">            .failureHandler(authenticationFailureHandler)</span><br><span class="line">            .and()</span><br><span class="line">            .logout()</span><br><span class="line">            <span class="comment">//.logoutUrl(&quot;/signout&quot;)</span></span><br><span class="line">            .logoutSuccessUrl(<span class="string">&quot;/signout/success&quot;</span>)</span><br><span class="line">            .deleteCookies(<span class="string">&quot;JSESSIONID&quot;</span>)</span><br><span class="line">            .logoutSuccessHandler(logoutSuccessHandler)</span><br><span class="line">            .and()</span><br><span class="line">            .authorizeRequests()</span><br><span class="line">            .anyRequest()</span><br><span class="line">            .authenticated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring Security 默认的退出登录 URL 为/logout，退出登录后，Spring Security 会做如下处理：</p>
<ol>
<li>使当前的 Session 失效</li>
<li>清除与当前用户关联的 RememberMe 记录</li>
<li>清空当前的 SecurityContext</li>
<li>重定向到登录页</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringSecurity5（5-自定义短信、手机验证码）</title>
    <url>/blog/2025/02/08/Java/SpringSecurity/SpringSecurity5/SpringSecurity5%EF%BC%885-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9F%AD%E4%BF%A1%E3%80%81%E6%89%8B%E6%9C%BA%E9%AA%8C%E8%AF%81%E7%A0%81%EF%BC%89/</url>
    <content><![CDATA[<h2 id="图形验证码">图形验证码</h2>
<p>SpringSecurity 实现的用户名、密码登录是在 UsernamePasswordAuthenticationFilter 过滤器进行认证的，而图形验证码一般是在用户名、密码认证之前进行验证的，所以需要在 UsernamePasswordAuthenticationFilter 过滤器之前添加一个自定义过滤器 ImageCodeValidateFilter，用来校验用户输入的图形验证码是否正确。</p>
<h3 id="实现逻辑">实现逻辑</h3>
<p>自定义过滤器继承 OncePerRequestFilter 类，该类是 Spring 提供的在一次请求中只会调用一次的 filter，确保每个请求只会进入过滤器一次，避免了多次执行的情况</p>
<p>自定义的过滤器 ImageCodeValidateFilter 首先会判断请求是否为 POST 方式的登录表单提交请求，如果是就将其拦截进行图形验证码校验。如果验证错误，会抛出自定义异常类对象 ValidateCodeException，该异常类需要继承 AuthenticationException 类。在自定义过滤器中，我们需要手动捕获自定义异常类对象，并将捕获到自定义异常类对象交给自定义失败处理器进行处理</p>
<p><img src="1.png" alt=""></p>
<h3 id="添加验证码配置">添加验证码配置</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 图形验证码工具 kaptcha --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.penggle<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kaptcha<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 图形验证码的配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KaptchaConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DefaultKaptcha <span class="title function_">captchaProducer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DefaultKaptcha</span> <span class="variable">defaultKaptcha</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultKaptcha</span>();</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">// 是否有边框</span></span><br><span class="line">        properties.setProperty(Constants.KAPTCHA_BORDER, <span class="string">&quot;yes&quot;</span>);</span><br><span class="line">        <span class="comment">// 边框颜色</span></span><br><span class="line">        properties.setProperty(Constants.KAPTCHA_BORDER_COLOR, <span class="string">&quot;192,192,192&quot;</span>);</span><br><span class="line">        <span class="comment">// 验证码图片的宽和高</span></span><br><span class="line">        properties.setProperty(Constants.KAPTCHA_IMAGE_WIDTH, <span class="string">&quot;110&quot;</span>);</span><br><span class="line">        properties.setProperty(Constants.KAPTCHA_IMAGE_HEIGHT, <span class="string">&quot;40&quot;</span>);</span><br><span class="line">        <span class="comment">// 验证码颜色</span></span><br><span class="line">        properties.setProperty(Constants.KAPTCHA_TEXTPRODUCER_FONT_COLOR, <span class="string">&quot;0,0,0&quot;</span>);</span><br><span class="line">        <span class="comment">// 验证码字体大小</span></span><br><span class="line">        properties.setProperty(Constants.KAPTCHA_TEXTPRODUCER_FONT_SIZE, <span class="string">&quot;32&quot;</span>);</span><br><span class="line">        <span class="comment">// 验证码生成几个字符</span></span><br><span class="line">        properties.setProperty(Constants.KAPTCHA_TEXTPRODUCER_CHAR_LENGTH, <span class="string">&quot;4&quot;</span>);</span><br><span class="line">        <span class="comment">// 验证码随机字符库</span></span><br><span class="line">        properties.setProperty(Constants.KAPTCHA_TEXTPRODUCER_CHAR_STRING, <span class="string">&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYAZ&quot;</span>);</span><br><span class="line">        <span class="comment">// 验证码图片默认是有线条干扰的，我们设置成没有干扰</span></span><br><span class="line">        properties.setProperty(Constants.KAPTCHA_NOISE_IMPL, <span class="string">&quot;com.google.code.kaptcha.impl.NoNoise&quot;</span>);</span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>(properties);</span><br><span class="line">        defaultKaptcha.setConfig(config);</span><br><span class="line">        <span class="keyword">return</span> defaultKaptcha;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="提供验证码接口">提供验证码接口</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheckCode</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String code;           <span class="comment">// 验证码字符</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime expireTime;  <span class="comment">// 过期时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code 验证码字符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime 过期时间，单位秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CheckCode</span><span class="params">(String code, <span class="type">int</span> expireTime)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.expireTime = LocalDateTime.now().plusSeconds(expireTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CheckCode</span><span class="params">(String code)</span> &#123;</span><br><span class="line">        <span class="comment">// 默认验证码 60 秒后过期</span></span><br><span class="line">        <span class="built_in">this</span>(code, <span class="number">60</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否过期</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isExpried</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.expireTime.isBefore(LocalDateTime.now());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Session 中存储图形验证码的属性名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KAPTCHA_SESSION_KEY</span> <span class="operator">=</span> <span class="string">&quot;KAPTCHA_SESSION_KEY&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DefaultKaptcha defaultKaptcha;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/login/page&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">login</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/code/image&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">imageCode</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 创建验证码文本</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">capText</span> <span class="operator">=</span> defaultKaptcha.createText();</span><br><span class="line">        <span class="comment">// 创建验证码图片</span></span><br><span class="line">        <span class="type">BufferedImage</span> <span class="variable">image</span> <span class="operator">=</span> defaultKaptcha.createImage(capText);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将验证码文本放进 Session 中</span></span><br><span class="line">        <span class="type">CheckCode</span> <span class="variable">code</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CheckCode</span>(capText);</span><br><span class="line">        request.getSession().setAttribute(KAPTCHA_SESSION_KEY, code);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将验证码图片返回，禁止验证码图片缓存</span></span><br><span class="line">        response.setHeader(<span class="string">&quot;Cache-Control&quot;</span>, <span class="string">&quot;no-store&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Pragma&quot;</span>, <span class="string">&quot;no-cache&quot;</span>);</span><br><span class="line">        response.setDateHeader(<span class="string">&quot;Expires&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        response.setContentType(<span class="string">&quot;image/jpeg&quot;</span>);</span><br><span class="line">        ImageIO.write(image, <span class="string">&quot;jpg&quot;</span>, response.getOutputStream());</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>表单登录<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/login/form&#125;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;用户名&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;密码&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;imageCode&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;验证码&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">th:onclick</span>=<span class="string">&quot;this.src=&#x27;/code/image?&#x27;+Math.random()&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/code/image&#125;&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;验证码&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;param.error&#125;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;session.SPRING_SECURITY_LAST_EXCEPTION.message&#125;&quot;</span> <span class="attr">style</span>=<span class="string">&quot;color:red&quot;</span>&gt;</span>用户名或密码错误<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="自定义验证码过滤器">自定义验证码过滤器</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义验证码校验错误的异常类，继承 AuthenticationException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValidateCodeException</span> <span class="keyword">extends</span> <span class="title class_">AuthenticationException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ValidateCodeException</span><span class="params">(String msg, Throwable t)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(msg, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ValidateCodeException</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageCodeValidateFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">codeParamter</span> <span class="operator">=</span> <span class="string">&quot;imageCode&quot;</span>;  <span class="comment">// 前端输入的图形验证码参数名</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationFailureHandlerImpl authenticationFailureHandler;  <span class="comment">// 自定义认证失败处理器</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 非 POST 方式的表单提交请求不校验图形验证码</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;/login/form&quot;</span>.equals(request.getRequestURI()) &amp;&amp; <span class="string">&quot;POST&quot;</span>.equals(request.getMethod())) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 校验图形验证码合法性</span></span><br><span class="line">                validate(request);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ValidateCodeException e) &#123;</span><br><span class="line">                <span class="comment">// 手动捕获图形验证码校验过程抛出的异常，将其传给失败处理器进行处理</span></span><br><span class="line">                authenticationFailureHandler.onAuthenticationFailure(request, response, e);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 放行请求，进入下一个过滤器</span></span><br><span class="line">        filterChain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断验证码的合法性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">validate</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取用户传入的图形验证码值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">requestCode</span> <span class="operator">=</span> request.getParameter(<span class="built_in">this</span>.codeParamter);</span><br><span class="line">        <span class="keyword">if</span>(requestCode == <span class="literal">null</span>) &#123;</span><br><span class="line">            requestCode = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        requestCode = requestCode.trim();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 Session</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        <span class="comment">// 获取存储在 Session 里的验证码值</span></span><br><span class="line">        <span class="type">CheckCode</span> <span class="variable">savedCode</span> <span class="operator">=</span> (CheckCode) session.getAttribute(LoginController.KAPTCHA_SESSION_KEY);</span><br><span class="line">        <span class="keyword">if</span> (savedCode != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 随手清除验证码，无论是失败，还是成功。客户端应在登录失败时刷新验证码</span></span><br><span class="line">            session.removeAttribute(LoginController.KAPTCHA_SESSION_KEY);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 校验出错，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(requestCode)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ValidateCodeException</span>(<span class="string">&quot;验证码的值不能为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (savedCode == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ValidateCodeException</span>(<span class="string">&quot;验证码不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (savedCode.isExpried()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ValidateCodeException</span>(<span class="string">&quot;验证码过期&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!requestCode.equalsIgnoreCase(savedCode.getCode())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ValidateCodeException</span>(<span class="string">&quot;验证码输入错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDetailServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;root&quot;</span>.equals(username)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(username, passwordEncoder.encode(<span class="string">&quot;123&quot;</span>), AuthorityUtils.createAuthorityList(<span class="string">&quot;admin&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;用户名不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="设置过滤器顺序">设置过滤器顺序</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringSecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationSuccessHandlerImpl authenticationSuccessHandler;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationFailureHandlerImpl authenticationFailureHandler;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ImageCodeValidateFilter imageCodeValidateFilter; <span class="comment">// 自定义过滤器（图形验证码校验）</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailServiceImpl userDetailService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 密码编码器，密码不能明文存储</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> BCryptPasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 BCryptPasswordEncoder 密码编码器，该编码器会将随机产生的 salt 混入最终生成的密文中</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        auth.userDetailsService(userDetailService).passwordEncoder(passwordEncoder());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定制基于 HTTP 请求的用户访问控制</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 启动 form 表单登录</span></span><br><span class="line">        http.formLogin()</span><br><span class="line">            <span class="comment">// 设置登录页面的访问路径，默认为 /login，GET 请求；该路径不设限访问</span></span><br><span class="line">            .loginPage(<span class="string">&quot;/login/page&quot;</span>)</span><br><span class="line">            <span class="comment">// 设置登录表单提交路径，默认为 loginPage() 设置的路径，POST 请求</span></span><br><span class="line">            .loginProcessingUrl(<span class="string">&quot;/login/form&quot;</span>)</span><br><span class="line">            <span class="comment">// 使用自定义的认证成功和失败处理器</span></span><br><span class="line">            .successHandler(authenticationSuccessHandler)</span><br><span class="line">            .failureHandler(authenticationFailureHandler);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启基于 HTTP 请求访问控制</span></span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">            <span class="comment">// 以下访问不需要任何权限，任何人都可以访问</span></span><br><span class="line">            .antMatchers(<span class="string">&quot;/login/page&quot;</span>, <span class="string">&quot;/code/image&quot;</span>).permitAll()</span><br><span class="line">            <span class="comment">// 其它任何请求访问都需要先通过认证</span></span><br><span class="line">            .anyRequest().authenticated();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭 csrf 防护</span></span><br><span class="line">        http.csrf().disable();</span><br><span class="line">        <span class="comment">// 将自定义过滤器（图形验证码校验）添加到 UsernamePasswordAuthenticationFilter 之前</span></span><br><span class="line">        http.addFilterBefore(imageCodeValidateFilter, UsernamePasswordAuthenticationFilter.class);        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定制一些全局性的安全配置，例如：不拦截静态资源的访问</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 静态资源的访问不需要拦截，直接放行</span></span><br><span class="line">        web.ignoring().antMatchers(<span class="string">&quot;/**/*.css&quot;</span>, <span class="string">&quot;/**/*.js&quot;</span>, <span class="string">&quot;/**/*.png&quot;</span>, <span class="string">&quot;/**/*.jpg&quot;</span>, <span class="string">&quot;/**/*.jpeg&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="手机短信验证码">手机短信验证码</h2>
<h3 id="验证流程">验证流程</h3>
<p>带有图形验证码的用户名、密码登录流程：</p>
<ol>
<li>在 ImageCodeValidateFilter 过滤器中校验用户输入的图形验证码是否正确。</li>
<li>在 UsernamePasswordAuthenticationFilter 过滤器中将 username 和 password 生成一个用于认证的 Token（UsernamePasswordAuthenticationToken），并将其传递给 ProviderManager 接口的实现类 AuthenticationManager。</li>
<li>AuthenticationManager 管理器寻找到一个合适的处理器 DaoAuthenticationProvider 来处理 UsernamePasswordAuthenticationToken。</li>
<li>DaoAuthenticationProvider 通过 UserDetailsService 接口的实现类 CustomUserDetailsService 从数据库中获取指定 username 的相关信息，并校验用户输入的 password。如果校验成功，那就认证通过，用户信息类对象 Authentication 标记为已认证。</li>
<li>认证通过后，将已认证的用户信息对象 Authentication 存储到 SecurityContextHolder 中，最终存储到 Session 中。</li>
</ol>
<p>仿照上述流程，我们分析手机短信验证码登录流程：</p>
<ol>
<li>仿照 ImageCodeValidateFilter 过滤器设计 MobileVablidateFilter 过滤器，该过滤器用来校验用户输入手机短信验证码。</li>
<li>仿照 UsernamePasswordAuthenticationFilter 过滤器设计 MobileAuthenticationFilter 过滤器，该过滤器将用户输入的手机号生成一个 Token（MobileAuthenticationToken），并将其传递给 ProviderManager 接口的实现类 AuthenticationManager。</li>
<li>AuthenticationManager 管理器寻找到一个合适的处理器 MobileAuthenticationProvider 来处理 MobileAuthenticationToken，该处理器是仿照 DaoAuthenticationProvider 进行设计的。</li>
<li>MobileAuthenticationProvider 通过 UserDetailsService 接口的实现类 MobileUserDetailsService 从数据库中获取指定手机号对应的用户信息，此处不需要进行任何校验，直接将用户信息类对象 Authentication 标记为已认证。</li>
<li>认证通过后，将已认证的用户信息对象 Authentication 存储到 SecurityContextHolder 中，最终存储到 Session 中，此处的操作不需要我们编写。</li>
</ol>
<p>最后通过自定义配置类 MobileAuthenticationConfig 组合上述组件，并添加到安全配置类 SpringSecurityConfig 中。</p>
<p><img src="2.png" alt=""></p>
<h3 id="提供短信发送接口">提供短信发送接口</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Session 中存储手机短信验证码的属性名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MOBILE_SESSION_KEY</span> <span class="operator">=</span> <span class="string">&quot;MOBILE_SESSION_KEY&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/mobile/page&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">mobileLoginPage</span><span class="params">()</span> &#123;  <span class="comment">// 跳转到手机短信验证码登录页面</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login-mobile&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/code/mobile&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">sendMoblieCode</span><span class="params">(HttpServletRequest request)</span> &#123; </span><br><span class="line">        <span class="comment">// 随机生成一个 4 位的验证码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> RandomStringUtils.randomNumeric(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将手机验证码文本存储在 Session 中，设置过期时间为 10 * 60s</span></span><br><span class="line">        <span class="type">CheckCode</span> <span class="variable">mobileCode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CheckCode</span>(code, <span class="number">10</span> * <span class="number">60</span>);</span><br><span class="line">        request.getSession().setAttribute(MOBILE_SESSION_KEY, mobileCode);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mobileCode;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>登录页面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://s3.pstatp.com/cdn/expire-1-M/jquery/3.3.1/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/mobile/form&#125;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;mobile&quot;</span> <span class="attr">name</span>=<span class="string">&quot;mobile&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;手机号码&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;mobileCode&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;验证码&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;sendCode&quot;</span>&gt;</span>获取验证码<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;param.error&#125;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;session.SPRING_SECURITY_LAST_EXCEPTION.message&#125;&quot;</span> <span class="attr">style</span>=<span class="string">&quot;color:red&quot;</span>&gt;</span>用户名或密码错误<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 获取手机短信验证码</span></span></span><br><span class="line"><span class="language-javascript">        $(<span class="string">&quot;#sendCode&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> mobile = $(<span class="string">&#x27;#mobile&#x27;</span>).<span class="title function_">val</span>().<span class="title function_">trim</span>();</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span>(mobile == <span class="string">&#x27;&#x27;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">alert</span>(<span class="string">&quot;手机号不能为空&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">return</span>;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// /code/mobile?mobile=123123123</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> url = <span class="string">&quot;/code/mobile?mobile=&quot;</span> + mobile;</span></span><br><span class="line"><span class="language-javascript">            $.<span class="title function_">get</span>(url, <span class="keyword">function</span>(<span class="params">data</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">alert</span>(data);</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="自定义短信验证码校验过滤器">自定义短信验证码校验过滤器</h3>
<p>更改自定义失败处理器 CustomAuthenticationFailureHandler，原先的处理器在认证失败时，会直接重定向到/login/page?error 显示认证异常信息。现在我们有两种登录方式，应该进行以下处理：</p>
<ol>
<li>带图形验证码的用户名、密码方式登录方式出现认证异常，重定向到/login/page?error</li>
<li>手机短信验证码方式登录出现认证异常，重定向到/mobile/page?error</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 继承 SimpleUrlAuthenticationFailureHandler 处理器，该类是 failureUrl() 方法使用的认证失败处理器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomAuthenticationFailureHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleUrlAuthenticationFailureHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationFailure</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException e)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">xRequestedWith</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;x-requested-with&quot;</span>);</span><br><span class="line">        <span class="comment">// 判断前端的请求是否为 ajax 请求</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;XMLHttpRequest&quot;</span>.equals(xRequestedWith)) &#123;</span><br><span class="line">            <span class="comment">// 认证成功，响应 JSON 数据</span></span><br><span class="line">            response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">            response.getWriter().write(<span class="string">&quot;认证失败&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 用户名、密码方式登录出现认证异常，需要重定向到 /login/page?error</span></span><br><span class="line">            <span class="comment">// 手机短信验证码方式登录出现认证异常，需要重定向到 /mobile/page?error</span></span><br><span class="line">            <span class="comment">// 使用 Referer 获取当前登录表单提交请求是从哪个登录页面(/login/page 或 /mobile/page)链接过来的</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">refer</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Referer&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">lastUrl</span> <span class="operator">=</span> StringUtils.substringBefore(refer, <span class="string">&quot;?&quot;</span>);</span><br><span class="line">            <span class="comment">// 设置默认的重定向路径</span></span><br><span class="line">            <span class="built_in">super</span>.setDefaultFailureUrl(lastUrl + <span class="string">&quot;?error&quot;</span>);</span><br><span class="line">            <span class="comment">// 调用父类的 onAuthenticationFailure() 方法</span></span><br><span class="line">            <span class="built_in">super</span>.onAuthenticationFailure(request, response, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 手机短信验证码校验</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MobileCodeValidateFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">codeParamter</span> <span class="operator">=</span> <span class="string">&quot;mobileCode&quot;</span>;  <span class="comment">// 前端输入的手机短信验证码参数名</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CustomAuthenticationFailureHandler authenticationFailureHandler; <span class="comment">// 自定义认证失败处理器</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 非 POST 方式的手机短信验证码提交请求不进行校验</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;/mobile/form&quot;</span>.equals(request.getRequestURI()) &amp;&amp; <span class="string">&quot;POST&quot;</span>.equals(request.getMethod())) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 检验手机验证码的合法性</span></span><br><span class="line">                validate(request);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ValidateCodeException e) &#123;</span><br><span class="line">                <span class="comment">// 将异常交给自定义失败处理器进行处理</span></span><br><span class="line">                authenticationFailureHandler.onAuthenticationFailure(request, response, e);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 放行，进入下一个过滤器</span></span><br><span class="line">        filterChain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检验用户输入的手机验证码的合法性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">validate</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取用户传入的手机验证码值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">requestCode</span> <span class="operator">=</span> request.getParameter(<span class="built_in">this</span>.codeParamter);</span><br><span class="line">        <span class="keyword">if</span>(requestCode == <span class="literal">null</span>) &#123;</span><br><span class="line">            requestCode = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        requestCode = requestCode.trim();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 Session</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        <span class="comment">// 获取 Session 中存储的手机短信验证码</span></span><br><span class="line">        <span class="type">CheckCode</span> <span class="variable">savedCode</span> <span class="operator">=</span> (CheckCode) session.getAttribute(LoginController.MOBILE_SESSION_KEY);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (savedCode != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 随手清除验证码，无论是失败，还是成功。客户端应在登录失败时刷新验证码</span></span><br><span class="line">            session.removeAttribute(LoginController.MOBILE_SESSION_KEY);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 校验出错，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(requestCode)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ValidateCodeException</span>(<span class="string">&quot;验证码的值不能为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (savedCode == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ValidateCodeException</span>(<span class="string">&quot;验证码不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (savedCode.isExpried()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ValidateCodeException</span>(<span class="string">&quot;验证码过期&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!requestCode.equalsIgnoreCase(savedCode.getCode())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ValidateCodeException</span>(<span class="string">&quot;验证码输入错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义短信验证码认证过滤器">自定义短信验证码认证过滤器</h3>
<ol>
<li>仿照 UsernamePasswordAuthenticationToken 类进行编写</li>
<li>仿照 UsernamePasswordAuthenticationFilter 过滤器进行编写</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MobileAuthenticationToken</span> <span class="keyword">extends</span> <span class="title class_">AbstractAuthenticationToken</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">520L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object principal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 认证前，使用该构造器进行封装信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MobileAuthenticationToken</span><span class="params">(Object principal)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="literal">null</span>);     <span class="comment">// 用户权限为 null</span></span><br><span class="line">        <span class="built_in">this</span>.principal = principal;   <span class="comment">// 前端传入的手机号</span></span><br><span class="line">        <span class="built_in">this</span>.setAuthenticated(<span class="literal">false</span>); <span class="comment">// 标记为未认证</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 认证成功后，使用该构造器封装用户信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MobileAuthenticationToken</span><span class="params">(Object principal, Collection&lt;? extends GrantedAuthority&gt; authorities)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(authorities);          <span class="comment">// 用户权限集合</span></span><br><span class="line">        <span class="built_in">this</span>.principal = principal;  <span class="comment">// 封装认证用户信息的 UserDetails 对象，不再是手机号</span></span><br><span class="line">        <span class="built_in">super</span>.setAuthenticated(<span class="literal">true</span>); <span class="comment">// 标记认证成功</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getCredentials</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 由于使用手机短信验证码登录不需要密码，所以直接返回 null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getPrincipal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.principal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAuthenticated</span><span class="params">(<span class="type">boolean</span> isAuthenticated)</span> <span class="keyword">throws</span> IllegalArgumentException &#123;</span><br><span class="line">        <span class="keyword">if</span> (isAuthenticated) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Cannot set this token to trusted - use constructor which takes a GrantedAuthority list instead&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.setAuthenticated(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eraseCredentials</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 手机短信验证码认证方式不必去除额外的敏感信息，所以直接调用父类方法</span></span><br><span class="line">        <span class="built_in">super</span>.eraseCredentials();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 手机短信验证码认证过滤器，仿照 UsernamePasswordAuthenticationFilter 过滤器编写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MobileAuthenticationFilter</span> <span class="keyword">extends</span> <span class="title class_">AbstractAuthenticationProcessingFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">mobileParamter</span> <span class="operator">=</span> <span class="string">&quot;mobile&quot;</span>;  <span class="comment">// 默认手机号参数名为 mobile</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">postOnly</span> <span class="operator">=</span> <span class="literal">true</span>;    <span class="comment">// 默认请求方式只能为 POST</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">MobileAuthenticationFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 默认登录表单提交路径为 /mobile/form，POST 方式请求</span></span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">AntPathRequestMatcher</span>(<span class="string">&quot;/mobile/form&quot;</span>, <span class="string">&quot;POST&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Authentication <span class="title function_">attemptAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> AuthenticationException, IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">//(1) 默认情况下，如果请求方式不是 POST，会抛出异常</span></span><br><span class="line">        <span class="keyword">if</span>(postOnly &amp;&amp; !request.getMethod().equals(<span class="string">&quot;POST&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AuthenticationServiceException</span>(<span class="string">&quot;Authentication method not supported: &quot;</span> + request.getMethod());</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//(2) 获取请求携带的 mobile</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">mobile</span> <span class="operator">=</span> request.getParameter(mobileParamter);</span><br><span class="line">            <span class="keyword">if</span>(mobile == <span class="literal">null</span>) &#123;</span><br><span class="line">                mobile = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mobile = mobile.trim();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//(3) 使用前端传入的 mobile 构造 Authentication 对象，标记该对象未认证</span></span><br><span class="line">            <span class="comment">// MobileAuthenticationToken 是我们自定义的 Authentication 类，后续介绍</span></span><br><span class="line">            <span class="type">MobileAuthenticationToken</span> <span class="variable">authRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MobileAuthenticationToken</span>(mobile);</span><br><span class="line">            <span class="comment">//(4) 将请求中的一些属性信息设置到 Authentication 对象中，如：remoteAddress，sessionId</span></span><br><span class="line">            <span class="built_in">this</span>.setDetails(request, authRequest);</span><br><span class="line">            <span class="comment">//(5) 调用 ProviderManager 类的 authenticate() 方法进行身份认证</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.getAuthenticationManager().authenticate(authRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">protected</span> String <span class="title function_">obtainMobile</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> request.getParameter(<span class="built_in">this</span>.mobileParamter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setDetails</span><span class="params">(HttpServletRequest request, MobileAuthenticationToken authRequest)</span> &#123;</span><br><span class="line">        authRequest.setDetails(<span class="built_in">this</span>.authenticationDetailsSource.buildDetails(request));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMobileParameter</span><span class="params">(String mobileParamter)</span> &#123;</span><br><span class="line">        Assert.hasText(mobileParamter, <span class="string">&quot;Mobile par ameter must not be empty or null&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.mobileParamter = mobileParamter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPostOnly</span><span class="params">(<span class="type">boolean</span> postOnly)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.postOnly = postOnly;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMobileParameter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mobileParamter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义短信验证码认证处理器">自定义短信验证码认证处理器</h3>
<ol>
<li>仿照 DaoAuthenticationProvider 处理器进行编写</li>
<li>MobileAuthenticationProvider 处理器传入的 UserDetailsService 对象的类型需要我们自定义</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MobileAuthenticationProvider</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationProvider</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">MessageSourceAccessor</span> <span class="variable">messages</span> <span class="operator">=</span> SpringSecurityMessageSource.getAccessor();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserDetailsChecker</span> <span class="variable">authenticationChecks</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MobileAuthenticationProvider</span>.DefaultAuthenticationChecks();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理认证</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Authentication <span class="title function_">authenticate</span><span class="params">(Authentication authentication)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">        <span class="comment">//(1) 如果入参的 Authentication 类型不是 MobileAuthenticationToken，抛出异常</span></span><br><span class="line">        Assert.isInstanceOf(MobileAuthenticationToken.class, authentication, () -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.messages.getMessage(<span class="string">&quot;MobileAuthenticationProvider.onlySupports&quot;</span>, <span class="string">&quot;Only MobileAuthenticationToken is supported&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取手机号</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">mobile</span> <span class="operator">=</span> authentication.getPrincipal() == <span class="literal">null</span> ? <span class="string">&quot;NONE_PROVIDED&quot;</span> : authentication.getName();</span><br><span class="line">        <span class="comment">//(2) 根据手机号从数据库中查询用户信息</span></span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">user</span> <span class="operator">=</span> <span class="built_in">this</span>.userDetailsService.loadUserByUsername(mobile);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//(3) 未查询到用户信息，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AuthenticationServiceException</span>(<span class="string">&quot;该手机号未注册&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//(4) 检查账号是否锁定、账号是否可用、账号是否过期、密码是否过期</span></span><br><span class="line">        <span class="built_in">this</span>.authenticationChecks.check(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//(5) 查询到了用户信息，则认证通过，构建标记认证成功用户信息类对象 AuthenticationToken</span></span><br><span class="line">        <span class="type">MobileAuthenticationToken</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MobileAuthenticationToken</span>(user, user.getAuthorities());</span><br><span class="line">        <span class="comment">// 需要把认证前 Authentication 对象中的 details 信息加入认证后的 Authentication</span></span><br><span class="line">        result.setDetails(authentication.getDetails());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ProviderManager 管理器通过此方法来判断是否采用此 AuthenticationProvider 类</span></span><br><span class="line"><span class="comment">     * 来处理由 AuthenticationFilter 过滤器传入的 Authentication 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Class&lt;?&gt; authentication)</span> &#123;</span><br><span class="line">        <span class="comment">// isAssignableFrom 返回 true 当且仅当调用者为父类.class，参数为本身或者其子类.class</span></span><br><span class="line">        <span class="comment">// ProviderManager 会获取 MobileAuthenticationFilter 过滤器传入的 Authentication 类型</span></span><br><span class="line">        <span class="comment">// 所以当且仅当 authentication 的类型为 MobileAuthenticationToken 才返回 true</span></span><br><span class="line">        <span class="keyword">return</span> MobileAuthenticationToken.class.isAssignableFrom(authentication);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此处传入自定义的 MobileUserDetailsSevice 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDetailsService</span><span class="params">(UserDetailsService userDetailsService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDetailsService = userDetailsService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> UserDetailsService <span class="title function_">getUserDetailsService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userDetailsService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查账号是否锁定、账号是否可用、账号是否过期、密码是否过期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">DefaultAuthenticationChecks</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsChecker</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">DefaultAuthenticationChecks</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">(UserDetails user)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!user.isAccountNonLocked()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LockedException</span>(MobileAuthenticationProvider.<span class="built_in">this</span>.messages.getMessage(<span class="string">&quot;AbstractUserDetailsAuthenticationProvider.locked&quot;</span>, <span class="string">&quot;User account is locked&quot;</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!user.isEnabled()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DisabledException</span>(MobileAuthenticationProvider.<span class="built_in">this</span>.messages.getMessage(<span class="string">&quot;AbstractUserDetailsAuthenticationProvider.disabled&quot;</span>, <span class="string">&quot;User is disabled&quot;</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!user.isAccountNonExpired()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AccountExpiredException</span>(MobileAuthenticationProvider.<span class="built_in">this</span>.messages.getMessage(<span class="string">&quot;AbstractUserDetailsAuthenticationProvider.expired&quot;</span>, <span class="string">&quot;User account has expired&quot;</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!user.isCredentialsNonExpired()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CredentialsExpiredException</span>(MobileAuthenticationProvider.<span class="built_in">this</span>.messages.getMessage(<span class="string">&quot;AbstractUserDetailsAuthenticationProvider.credentialsExpired&quot;</span>, <span class="string">&quot;User credentials have expired&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MobileUserDetailsService</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String mobile)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        <span class="comment">//(1) 从数据库尝试读取该用户</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectByMobile(mobile);</span><br><span class="line">        <span class="comment">// 用户不存在，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;用户不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//(2) 将数据库形式的 roles 解析为 UserDetails 的权限集合</span></span><br><span class="line">        <span class="comment">// AuthorityUtils.commaSeparatedStringToAuthorityList() 是 Spring Security 提供的方法，用于将逗号隔开的权限集字符串切割为可用权限对象列表</span></span><br><span class="line">        user.setAuthorities(AuthorityUtils.commaSeparatedStringToAuthorityList(user.getRoles()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//(3) 返回 UserDetails 对象</span></span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义短信验证码认证方式配置类">自定义短信验证码认证方式配置类</h3>
<ol>
<li>将上述组件进行管理，仿照 SecurityConfigurerAdapter类进行编写</li>
<li>绑定到最终的安全配置类 SpringSecurityConfig 中</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MobileAuthenticationConfig</span> <span class="keyword">extends</span> <span class="title class_">SecurityConfigurerAdapter</span>&lt;DefaultSecurityFilterChain, HttpSecurity&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CustomAuthenticationSuccessHandler customAuthenticationSuccessHandler;  <span class="comment">// 自定义认证成功处理器</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CustomAuthenticationFailureHandler customAuthenticationFailureHandler;  <span class="comment">// 自定义认证失败处理器</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MobileCodeValidateFilter mobileCodeValidaterFilter;  <span class="comment">// 手机短信验证码校验过滤器</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MobileUserDetailsService userDetailsService;  <span class="comment">// 手机短信验证方式的 UserDetail</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//(1) 将短信验证码认证的自定义过滤器绑定到 HttpSecurity 中</span></span><br><span class="line">        <span class="comment">//(1.1) 创建手机短信验证码认证过滤器的实例 filer</span></span><br><span class="line">        <span class="type">MobileAuthenticationFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MobileAuthenticationFilter</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//(1.2) 设置 filter 使用 AuthenticationManager(ProviderManager 接口实现类) 认证管理器</span></span><br><span class="line">        <span class="comment">// 多种登录方式应该使用同一个认证管理器实例，所以获取 Spring 容器中已经存在的 AuthenticationManager 实例</span></span><br><span class="line">        <span class="type">AuthenticationManager</span> <span class="variable">authenticationManager</span> <span class="operator">=</span> http.getSharedObject(AuthenticationManager.class);</span><br><span class="line">        filter.setAuthenticationManager(authenticationManager);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//(1.3) 设置 filter 使用自定义成功和失败处理器</span></span><br><span class="line">        filter.setAuthenticationSuccessHandler(customAuthenticationSuccessHandler);</span><br><span class="line">        filter.setAuthenticationFailureHandler(customAuthenticationFailureHandler);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//(1.4) 设置 filter 使用 SessionAuthenticationStrategy 会话管理器</span></span><br><span class="line">        <span class="comment">// 多种登录方式应该使用同一个会话管理器实例，获取 Spring 容器已经存在的 SessionAuthenticationStrategy 实例</span></span><br><span class="line">        <span class="type">SessionAuthenticationStrategy</span> <span class="variable">sessionAuthenticationStrategy</span> <span class="operator">=</span> http.getSharedObject(SessionAuthenticationStrategy.class);</span><br><span class="line">        filter.setSessionAuthenticationStrategy(sessionAuthenticationStrategy);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//(1.5) 在 UsernamePasswordAuthenticationFilter 过滤器之前添加 MobileCodeValidateFilter 过滤器</span></span><br><span class="line">        <span class="comment">// 在 UsernamePasswordAuthenticationFilter 过滤器之后添加 MobileAuthenticationFilter 过滤器</span></span><br><span class="line">        http.addFilterBefore(mobileCodeValidaterFilter, UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">        http.addFilterAfter(filter, UsernamePasswordAuthenticationFilter.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//(2) 将自定义的 MobileAuthenticationProvider 处理器绑定到 HttpSecurity 中</span></span><br><span class="line">        <span class="comment">//(2.1) 创建手机短信验证码认证过滤器的 AuthenticationProvider 实例，并指定所使用的 UserDetailsService</span></span><br><span class="line">        <span class="type">MobileAuthenticationProvider</span> <span class="variable">provider</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MobileAuthenticationProvider</span>();</span><br><span class="line">        provider.setUserDetailsService(userDetailsService);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//(2.2) 将该 AuthenticationProvider 实例绑定到 HttpSecurity 中</span></span><br><span class="line">        http.authenticationProvider(provider);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringSecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailServiceImpl userDetailsService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CustomAuthenticationSuccessHandler authenticationSuccessHandler; <span class="comment">// 自定义认证成功处理器</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CustomAuthenticationFailureHandler authenticationFailureHandler; <span class="comment">// 自定义认证失败处理器</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ImageCodeValidateFilter imageCodeValidateFilter; <span class="comment">// 自定义过滤器（图形验证码校验）</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MobileAuthenticationConfig mobileAuthenticationConfig; <span class="comment">// 手机短信验证码认证方式的配置类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 密码编码器，密码不能明文存储</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> BCryptPasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 BCryptPasswordEncoder 密码编码器，该编码器会将随机产生的 salt 混入最终生成的密文中</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定制用户认证管理器来实现用户认证</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;       </span><br><span class="line">        <span class="comment">// 不再使用内存方式存储用户认证信息，而是动态从数据库中获取</span></span><br><span class="line">        auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定制基于 HTTP 请求的用户访问控制</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 启动 form 表单登录</span></span><br><span class="line">        http.formLogin()</span><br><span class="line">        <span class="comment">// 设置登录页面的访问路径，默认为 /login，GET 请求；该路径不设限访问</span></span><br><span class="line">        .loginPage(<span class="string">&quot;/login/page&quot;</span>)</span><br><span class="line">        <span class="comment">// 设置登录表单提交路径，默认为 loginPage() 设置的路径，POST 请求</span></span><br><span class="line">        .loginProcessingUrl(<span class="string">&quot;/login/form&quot;</span>)</span><br><span class="line">        <span class="comment">// 使用自定义的认证成功和失败处理器</span></span><br><span class="line">        .successHandler(authenticationSuccessHandler)</span><br><span class="line">        .failureHandler(authenticationFailureHandler);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启基于 HTTP 请求访问控制</span></span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">        <span class="comment">// 以下访问不需要任何权限，任何人都可以访问</span></span><br><span class="line">        .antMatchers(<span class="string">&quot;/login/page&quot;</span>, <span class="string">&quot;/code/image&quot;</span>,<span class="string">&quot;/mobile/page&quot;</span>, <span class="string">&quot;/code/mobile&quot;</span>).permitAll()</span><br><span class="line">        <span class="comment">// 其它任何请求访问都需要先通过认证</span></span><br><span class="line">        .anyRequest().authenticated();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭 csrf 防护</span></span><br><span class="line">        http.csrf().disable();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将自定义过滤器（图形验证码校验）添加到 UsernamePasswordAuthenticationFilter 之前</span></span><br><span class="line">        http.addFilterBefore(imageCodeValidateFilter, UsernamePasswordAuthenticationFilter.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将手机短信验证码认证的配置与当前的配置绑定</span></span><br><span class="line">        http.apply(mobileAuthenticationConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定制一些全局性的安全配置，例如：不拦截静态资源的访问</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 静态资源的访问不需要拦截，直接放行</span></span><br><span class="line">        web.ignoring().antMatchers(<span class="string">&quot;/**/*.css&quot;</span>, <span class="string">&quot;/**/*.js&quot;</span>, <span class="string">&quot;/**/*.png&quot;</span>, <span class="string">&quot;/**/*.jpg&quot;</span>, <span class="string">&quot;/**/*.jpeg&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringSecurity5（3-密码解析器）</title>
    <url>/blog/2024/12/31/Java/SpringSecurity/SpringSecurity5/SpringSecurity5%EF%BC%883-%E5%AF%86%E7%A0%81%E8%A7%A3%E6%9E%90%E5%99%A8%EF%BC%89/</url>
    <content><![CDATA[<h2 id="PasswordEncoder">PasswordEncoder</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PasswordEncoder</span> &#123;</span><br><span class="line">    <span class="comment">//加密</span></span><br><span class="line">    String <span class="title function_">encode</span><span class="params">(CharSequence var1)</span>;</span><br><span class="line">	<span class="comment">//比较密码</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(CharSequence var1, String var2)</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">upgradeEncoding</span><span class="params">(String encodedPassword)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="1.png" alt=""></p>
<h2 id="工作流程">工作流程</h2>
<p>WebSecurityConfigurerAdapter 初始化密码解析器时，如果没有自定义 Bean 的话，会默认初始化 DelegatingPasswordEncoder</p>
<p><img src="2.png" alt=""></p>
<p><img src="3.png" alt=""></p>
<p><img src="4.png" alt=""></p>
<p>DaoAuthenticationProvider 在 additionalAuthenticationChecks 方法中会获取 Spring 容器中的 PasswordEncoder 来对用户输入的密码进行比较</p>
<p><strong>BCryptPasswordEncoder 密码匹配流程</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BCryptPasswordEncoder</span> <span class="keyword">implements</span> <span class="title class_">PasswordEncoder</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">Pattern</span> <span class="variable">BCRYPT_PATTERN</span> <span class="operator">=</span> Pattern</span><br><span class="line">			.compile(<span class="string">&quot;\\A\\$2(a|y|b)?\\$(\\d\\d)\\$[./0-9A-Za-z]&#123;53&#125;&quot;</span>);</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Log</span> <span class="variable">logger</span> <span class="operator">=</span> LogFactory.getLog(getClass());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> strength;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> BCryptVersion version;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> SecureRandom random;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数：原密码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">encode</span><span class="params">(CharSequence rawPassword)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (rawPassword == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;rawPassword cannot be null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String salt;</span><br><span class="line">        <span class="keyword">if</span> (random != <span class="literal">null</span>) &#123;</span><br><span class="line">            salt = BCrypt.gensalt(version.getVersion(), strength, random);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            salt = BCrypt.gensalt(version.getVersion(), strength);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> BCrypt.hashpw(rawPassword.toString(), salt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数一：原密码，</span></span><br><span class="line"><span class="comment">     * 参数二：加密后保存在数据库的密码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(CharSequence rawPassword, String encodedPassword)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (encodedPassword == <span class="literal">null</span> || encodedPassword.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Empty encoded password&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!BCRYPT_PATTERN.matcher(encodedPassword).matches()) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Encoded password does not look like BCrypt&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> BCrypt.checkpw(rawPassword.toString(), encodedPassword);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从数据库得到的“密码”（参数： salt ）进行一系列校验（长度校验等）并截取“密码”中相应的密码盐，利用这个密码盐进行同样的一系列计算 Hash 操作和 Base64 编码拼接一些标识符生成所谓的“密码”，最后 equalsNoEarlyReturn 方法对同一个密码盐生成的两个“密码”进行匹配</p>
<ol>
<li>每次使用 BCryptPasswordEncoder 编码同一个密码都是不一样的，因为用到的随机密码盐每次都是不一样的，同一个密码和不同的密码盐组合计算出来的 Hash 值不一样</li>
<li>BCryptPasswordEncoder 编码同一个密码后结果都不一样，怎么进行匹配？因为密码盐是随机生成的，但是可以根据数据库查询出来的“密码”拿到密码盐，同一个密码盐+原密码计算 Hash 结果值是能匹配的</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BCrypt</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">hashpw</span><span class="params">(String password, String salt)</span> &#123;</span><br><span class="line">        <span class="type">byte</span> passwordb[];</span><br><span class="line">        passwordb = password.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        <span class="keyword">return</span> hashpw(passwordb, salt);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">hashpw</span><span class="params">(<span class="type">byte</span> passwordb[], String salt)</span> &#123;</span><br><span class="line">        BCrypt B;</span><br><span class="line">        String real_salt;</span><br><span class="line">        <span class="type">byte</span> saltb[], hashed[];</span><br><span class="line">        <span class="type">char</span> <span class="variable">minor</span> <span class="operator">=</span> (<span class="type">char</span>) <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> rounds, off;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">if</span> (salt == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;salt cannot be null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">saltLength</span> <span class="operator">=</span> salt.length();</span><br><span class="line">        <span class="keyword">if</span> (saltLength &lt; <span class="number">28</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid salt&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (salt.charAt(<span class="number">0</span>) != <span class="string">&#x27;$&#x27;</span> || salt.charAt(<span class="number">1</span>) != <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span> (<span class="string">&quot;Invalid salt version&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (salt.charAt(<span class="number">2</span>) == <span class="string">&#x27;$&#x27;</span>)</span><br><span class="line">            off = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            minor = salt.charAt(<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> ((minor != <span class="string">&#x27;a&#x27;</span> &amp;&amp; minor != <span class="string">&#x27;x&#x27;</span> &amp;&amp; minor != <span class="string">&#x27;y&#x27;</span> &amp;&amp; minor != <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">                    || salt.charAt(<span class="number">3</span>) != <span class="string">&#x27;$&#x27;</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span> (<span class="string">&quot;Invalid salt revision&quot;</span>);</span><br><span class="line">            off = <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Extract number of rounds</span></span><br><span class="line">        <span class="keyword">if</span> (salt.charAt(off + <span class="number">2</span>) &gt; <span class="string">&#x27;$&#x27;</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span> (<span class="string">&quot;Missing salt rounds&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (off == <span class="number">4</span> &amp;&amp; saltLength &lt; <span class="number">29</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid salt&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        rounds = Integer.parseInt(salt.substring(off, off + <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        real_salt = salt.substring(off + <span class="number">3</span>, off + <span class="number">25</span>);</span><br><span class="line">        saltb = decode_base64(real_salt, BCRYPT_SALT_LEN);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (minor &gt;= <span class="string">&#x27;a&#x27;</span>) <span class="comment">// add null terminator</span></span><br><span class="line">            passwordb = Arrays.copyOf(passwordb, passwordb.length + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        B = <span class="keyword">new</span> <span class="title class_">BCrypt</span>();</span><br><span class="line">        hashed = B.crypt_raw(passwordb, saltb, rounds, minor == <span class="string">&#x27;x&#x27;</span>, minor == <span class="string">&#x27;a&#x27;</span> ? <span class="number">0x10000</span> : <span class="number">0</span>);</span><br><span class="line">        rs.append(<span class="string">&quot;$2&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (minor &gt;= <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">            rs.append(minor);</span><br><span class="line">        rs.append(<span class="string">&quot;$&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (rounds &lt; <span class="number">10</span>)</span><br><span class="line">            rs.append(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        rs.append(rounds);</span><br><span class="line">        rs.append(<span class="string">&quot;$&quot;</span>);</span><br><span class="line">        encode_base64(saltb, saltb.length, rs);</span><br><span class="line">        encode_base64(hashed, bf_crypt_ciphertext.length * <span class="number">4</span> - <span class="number">1</span>, rs);</span><br><span class="line">        <span class="keyword">return</span> rs.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkpw</span><span class="params">(String plaintext, String hashed)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> equalsNoEarlyReturn(hashed, hashpw(plaintext, hashed));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">equalsNoEarlyReturn</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> MessageDigest.isEqual(a.getBytes(StandardCharsets.UTF_8), b.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义密码解析器">自定义密码解析器</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMD5PasswordEncoder</span> <span class="keyword">implements</span> <span class="title class_">PasswordEncoder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> charSequence  明文字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">encode</span><span class="params">(CharSequence charSequence)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">MessageDigest</span> <span class="variable">digest</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> toHexString(digest.digest(charSequence.toString().getBytes()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 密码校验</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> charSequence 明文，页面收集密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 密文 ，数据库中存放密码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(CharSequence charSequence, String s)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s.equals(encode(charSequence));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tmp 转 16 进制字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 饭回 16 进制字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">toHexString</span><span class="params">(<span class="type">byte</span> [] tmp)</span>&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b :tmp)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> Integer.toHexString(b &amp; <span class="number">0xFF</span>);</span><br><span class="line">            <span class="keyword">if</span> (s.length()==<span class="number">1</span>)&#123;</span><br><span class="line">                builder.append(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            builder.append(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> builder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//return new BCryptPasswordEncoder(); //自带的</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyMD5PasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDetailServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String s)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> passwordEncoder.encode(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;登录用户：&#123;&#125;，密码：&#123;&#125;&quot;</span>, s, password);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(s, password, AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="string">&quot;admin&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>Easyexcel（1-注解使用）</title>
    <url>/blog/2024/10/26/Java/excel/easyexcel/Easyexcel%EF%BC%881-%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8%EF%BC%89/</url>
    <content><![CDATA[<h2 id="版本依赖">版本依赖</h2>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>easyexcel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="ExcelProperty">@ExcelProperty</h2>
<p>指定当前字段对应excel中的那一列，可以根据名字或者Index去匹配，当然也可以不写。</p>
<ol>
<li>value：指定写入的列头，如果不指定则使用成员变量的名字作为列头；如果要设置复杂的头，可以为value指定多个值</li>
<li>order：优先级高于value，会根据order的顺序来匹配实体和excel中数据的顺序</li>
<li>index：优先级高于value和order，指定写到第几列，如果不指定则根据成员变量位置排序；默认第一个字段就是index=0</li>
<li>converter：指定当前字段用什么转换器，默认会自动选择。可以用来设置类型转换器，需要实现Converter接口</li>
</ol>
<h3 id="value">value</h3>
<h4 id="指定属性名">指定属性名</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">(HttpServletResponse response)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            response.setContentType(<span class="string">&quot;application/vnd.ms-excel&quot;</span>);</span><br><span class="line">            response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> URLEncoder.encode(<span class="string">&quot;test1&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>).replaceAll(<span class="string">&quot;\\+&quot;</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">            response.setHeader(<span class="string">&quot;Content-disposition&quot;</span>, <span class="string">&quot;attachment;filename&quot;</span> + fileName + <span class="string">&quot;.xls&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">            user.setUserId(<span class="number">123</span>);</span><br><span class="line">            user.setName(<span class="string">&quot;as&quot;</span>);</span><br><span class="line">            user.setPhone(<span class="string">&quot;15213&quot;</span>);</span><br><span class="line">            user.setEmail(<span class="string">&quot;5456&quot;</span>);</span><br><span class="line">            user.setCreateTime(<span class="number">13213L</span>);</span><br><span class="line">            EasyExcel.write(response.getOutputStream(), User.class)</span><br><span class="line">                    .sheet(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">                    .doWrite(Arrays.asList(user));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="1.png" alt=""></p>
<p>默认情况下，使用类的属性名作为Excel的列表，当然也可以使用@ExcelProperty 注解来重新指定属性名称。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;用户Id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;姓名&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;手机&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;邮箱&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;创建时间&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="2.png" alt=""></p>
<h4 id="表头合并">表头合并</h4>
<p>value在写的时候，如果指定了多个值，会自动进行合并</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;用户Id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExcelProperty(value = &#123;&quot;用户基本信息&quot;, &quot;姓名&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExcelProperty(value = &#123;&quot;用户基本信息&quot;, &quot;手机&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExcelProperty(value = &#123;&quot;用户基本信息&quot;, &quot;邮箱&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;创建时间&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="3.png" alt=""></p>
<h3 id="index">index</h3>
<h4 id="指定位置">指定位置</h4>
<p>@ExcelProperty注解有两个属性index和order，如果不指定则按照属性在类中的排列顺序来。index是指定该属性在Excel中列的下标，下标从0开始</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;用户Id&quot;, index = 2)</span></span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;姓名&quot;, index = 1)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;手机&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;邮箱&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;创建时间&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="5.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;用户Id&quot;, index = 2)</span></span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;姓名&quot;, index = 1)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;手机&quot;, index = 10)</span></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;邮箱&quot;, index = 12)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;创建时间&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="6.png" alt=""></p>
<h3 id="order">order</h3>
<h4 id="指定顺序">指定顺序</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;用户Id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;姓名&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;手机&quot;, order = 11)</span></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;邮箱&quot;, order = 10)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;创建时间&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long createTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="7.png" alt=""></p>
<p>order的默认值为Integer.MAX_VALUE，通过效果我们可以得出结论：order值越小，越排在前面</p>
<p>注意：</p>
<ol>
<li>优先级：index &gt; order &gt; 默认配置</li>
<li>index相当于绝对位置，下标从0开始</li>
<li>order相当于相对位置，值越小的排在越前面</li>
</ol>
<h3 id="convert">convert</h3>
<h4 id="自定义转换器">自定义转换器</h4>
<p>在读写EXCEL时，有时候需要我们进行数据类型转换，例如我们这里的创建时间，在实体对象中是Long类型，但是这样直接导出到Excel中不太直观。我们需要转换成yyyy-MM-dd HH:mm:ss 格式，此时我们就可以用到转换器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateTimeConverter</span> <span class="keyword">implements</span> <span class="title class_">Converter</span>&lt;Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">DateTimeFormatter</span> <span class="variable">dateTimeFormatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 支持导入的Java类型</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; supportJavaTypeKey() &#123;</span><br><span class="line">        <span class="keyword">return</span> Long.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 支持导出的Excel类型</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> CellDataTypeEnum <span class="title function_">supportExcelTypeKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> CellDataTypeEnum.STRING;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换为Java</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">convertToJavaData</span><span class="params">(ReadCellData&lt;?&gt; cellData, ExcelContentProperty contentProperty, GlobalConfiguration globalConfiguration)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换为Excel</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> WriteCellData&lt;?&gt; convertToExcelData(Long value, ExcelContentProperty contentProperty, GlobalConfiguration globalConfiguration) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WriteCellData</span>(CellDataTypeEnum.STRING, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.ofInstant(Instant.ofEpochMilli(value), ZoneId.systemDefault());</span><br><span class="line">        <span class="type">String</span> <span class="variable">dateStr</span> <span class="operator">=</span> localDateTime.format(dateTimeFormatter);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WriteCellData</span>(dateStr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;用户Id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;姓名&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;手机&quot;, order = 11)</span></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;邮箱&quot;, order = 10)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;创建时间&quot;, converter = DateTimeConverter.class)</span></span><br><span class="line">    <span class="keyword">private</span> Long createTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="8.png" alt=""></p>
<h4 id="枚举转换">枚举转换</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Excel 性别转换器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenderConverter</span> <span class="keyword">implements</span> <span class="title class_">Converter</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; supportJavaTypeKey() &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> CellDataTypeEnum <span class="title function_">supportExcelTypeKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> CellDataTypeEnum.STRING;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">convertToJavaData</span><span class="params">(ReadConverterContext&lt;?&gt; context)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> GenderEnum.convert(context.getReadCellData().getStringValue()).getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> WriteCellData&lt;?&gt; convertToExcelData(WriteConverterContext&lt;Integer&gt; context) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WriteCellData</span>&lt;&gt;(GenderEnum.convert(context.getValue()).getDescription());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 性别枚举</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">GenderEnum</span> &#123;</span><br><span class="line"></span><br><span class="line">    UNKNOWN(<span class="number">0</span>, <span class="string">&quot;未知&quot;</span>),</span><br><span class="line"></span><br><span class="line">    MALE(<span class="number">1</span>, <span class="string">&quot;男性&quot;</span>),</span><br><span class="line"></span><br><span class="line">    FEMALE(<span class="number">2</span>, <span class="string">&quot;女性&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String description;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GenderEnum <span class="title function_">convert</span><span class="params">(Integer value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Stream.of(values())</span><br><span class="line">                .filter(bean -&gt; bean.value.equals(value))</span><br><span class="line">                .findAny()</span><br><span class="line">                .orElse(UNKNOWN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GenderEnum <span class="title function_">convert</span><span class="params">(String description)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Stream.of(values())</span><br><span class="line">                .filter(bean -&gt; bean.description.equals(description))</span><br><span class="line">                .findAny()</span><br><span class="line">                .orElse(UNKNOWN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ExcelIgnore">@ExcelIgnore</h2>
<p>默认所有字段都会和excel去匹配，加了这个注解会忽略该字段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;用户Id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;姓名&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;手机&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;邮箱&quot;)</span></span><br><span class="line">    <span class="meta">@ExcelIgnore</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;创建时间&quot;, converter = DateTimeConverter.class)</span></span><br><span class="line">    <span class="meta">@ExcelIgnore</span></span><br><span class="line">    <span class="keyword">private</span> Long createTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="9.png" alt=""></p>
<h2 id="ExcelIgnoreUnannotated">@ExcelIgnoreUnannotated</h2>
<p>不标注该注解时，默认类中所有成员变量都会参与读写，无论是否在成员变量上加了@ExcelProperty 的注解。标注该注解后，类中的成员变量如果没有标注 @ExcelProperty 注解将不会参与读写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExcelIgnoreUnannotated</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;用户Id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;姓名&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;手机&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long createTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="10.png" alt=""></p>
<h2 id="ColumnWidth">@ColumnWidth</h2>
<p>用于设置表格列的宽度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ColumnWidth(200)</span></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;用户Id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;姓名&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;手机&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;邮箱&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;创建时间&quot;, converter = DateTimeConverter.class)</span></span><br><span class="line">    <span class="keyword">private</span> Long createTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="11.png" alt=""></p>
<h2 id="ContentRowHeight">@ContentRowHeight</h2>
<p>标注在类上，指定内容行高</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ContentRowHeight(value = 50)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;用户Id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;姓名&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;手机&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;邮箱&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;创建时间&quot;, converter = DateTimeConverter.class)</span></span><br><span class="line">    <span class="keyword">private</span> Long createTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="12.png" alt=""></p>
<h2 id="HeadRowHeight">@HeadRowHeight</h2>
<p>标注在类上，指定列头行高</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@HeadRowHeight(80)</span></span><br><span class="line"><span class="meta">@ContentRowHeight(value = 50)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;用户Id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;姓名&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;手机&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;邮箱&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;创建时间&quot;, converter = DateTimeConverter.class)</span></span><br><span class="line">    <span class="keyword">private</span> Long createTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="13.png" alt=""></p>
<h2 id="ContentStyle">@ContentStyle</h2>
<p>用于设置内容格式注解</p>
<ol>
<li>dataFormat：日期格式</li>
<li>hidden：设置单元格使用此样式隐藏</li>
<li>locked：设置单元格使用此样式锁定</li>
<li>quotePrefix：在单元格前面增加`符号，数字或公式将以字符串形式展示</li>
<li>horizontalAlignment：设置是否水平居中</li>
<li>wrapped：设置文本是否应换行。将此标志设置为true通过在多行上显示使单元格中的所有内容可见</li>
<li>verticalAlignment：设置是否垂直居中</li>
<li>rotation：设置单元格中文本旋转角度。03版本的Excel旋转角度区间为-90°90°，07版本的Excel旋转角度区间为0°180°</li>
<li>indent：设置单元格中缩进文本的空格数</li>
<li>borderLeft：设置左边框的样式</li>
<li>borderRight：设置右边框样式</li>
<li>borderTop：设置上边框样式</li>
<li>borderBottom：设置下边框样式</li>
<li>leftBorderColor：设置左边框颜色</li>
<li>rightBorderColor：设置右边框颜色</li>
<li>topBorderColor：设置上边框颜色</li>
<li>bottomBorderColor：设置下边框颜色</li>
<li>fillPatternType：设置填充类型</li>
<li>fillBackgroundColor：设置背景色</li>
<li>fillForegroundColor：设置前景色</li>
<li>shrinkToFit：设置自动单元格自动大小</li>
</ol>
<h2 id="ContentFontStyle">@ContentFontStyle</h2>
<p>用于设置单元格内容字体格式的注解</p>
<ol>
<li>fontName：字体名称</li>
<li>fontHeightInPoints：字体高度</li>
<li>italic：是否斜体</li>
<li>strikeout：是否设置删除水平线</li>
<li>color：字体颜色</li>
<li>typeOffset：偏移量</li>
<li>underline：下划线</li>
<li>bold：是否加粗</li>
<li>charset：编码格式</li>
</ol>
<h2 id="HeadStyle">@HeadStyle</h2>
<p>用于设置标题样式</p>
<ol>
<li>dataFormat：日期格式</li>
<li>hidden：设置单元格使用此样式隐藏</li>
<li>locked：设置单元格使用此样式锁定</li>
<li>quotePrefix：在单元格前面增加`符号，数字或公式将以字符串形式展示</li>
<li>horizontalAlignment：设置是否水平居中</li>
<li>wrapped：设置文本是否应换行。将此标志设置为true通过在多行上显示使单元格中的所有内容可见</li>
<li>verticalAlignment：设置是否垂直居中</li>
<li>rotation：设置单元格中文本旋转角度。03版本的Excel旋转角度区间为-90°90°，07版本的Excel旋转角度区间为0°180°</li>
<li>indent：设置单元格中缩进文本的空格数</li>
<li>borderLeft：设置左边框的样式</li>
<li>borderRight：设置右边框样式</li>
<li>borderTop：设置上边框样式</li>
<li>borderBottom：设置下边框样式</li>
<li>leftBorderColor：设置左边框颜色</li>
<li>rightBorderColor：设置右边框颜色</li>
<li>topBorderColor：设置上边框颜色</li>
<li>bottomBorderColor：设置下边框颜色</li>
<li>fillPatternType：设置填充类型</li>
<li>fillBackgroundColor：设置背景色</li>
<li>fillForegroundColor：设置前景色</li>
<li>shrinkToFit：设置自动单元格自动大小</li>
</ol>
<h2 id="HeadFontStyle">@HeadFontStyle</h2>
<p>用于定制标题字体格式</p>
<ol>
<li>fontName：设置字体名称</li>
<li>fontHeightInPoints：设置字体高度</li>
<li>italic：设置字体是否斜体</li>
<li>strikeout：是否设置删除线</li>
<li>color：设置字体颜色</li>
<li>typeOffset：设置偏移量</li>
<li>underline：设置下划线</li>
<li>charset：设置字体编码</li>
<li>bold：设置字体是否加粗</li>
</ol>
<h2 id="ContentLoopMerge">@ContentLoopMerge</h2>
<p>用于设置合并单元格的注解，作用于字段上</p>
<ol>
<li>eachRow：合并列</li>
<li>columnExtend：合并行</li>
</ol>
<h2 id="OnceAbsoluteMerge">@OnceAbsoluteMerge</h2>
<p>用于指定位置的单元格合并，作用于类上</p>
<ol>
<li>firstRowIndex：第一行下标</li>
<li>lastRowIndex：最后一行下标</li>
<li>firstColumnIndex：第一列下标</li>
<li>lastColumnIndex：最后一列下标</li>
</ol>
<h2 id="DateTimeFormat">@DateTimeFormat</h2>
<p>日期转换，读取Excel文件时用String去接收excel日期格式的数据会调用这个注解。里面的value参照java.text.SimpleDateFormat</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;用户Id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;姓名&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;手机&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;邮箱&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DateTimeFormat(&quot;yyyy-MM-dd&quot;)</span></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;创建时间&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="NumberFormat">@NumberFormat</h2>
<p>数字转换，用String去接收excel数字格式的数据会调用这个注解。里面的value参照java.text.DecimalFormat</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Excel</tag>
        <tag>EasyExcel</tag>
      </tags>
  </entry>
  <entry>
    <title>Easyexcel（2-文件读取）</title>
    <url>/blog/2024/10/27/Java/excel/easyexcel/Easyexcel%EF%BC%882-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%EF%BC%89/</url>
    <content><![CDATA[<h2 id="同步读取">同步读取</h2>
<h3 id="读取单个Sheet">读取单个Sheet</h3>
<ol>
<li>通过sheet方法指定对应的Sheet名称或下标读取文件信息</li>
<li>通过doReadSync方法实现同步读取</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserExcel</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelIgnore</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(index = 0, value = &quot;姓名&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(index = 1, value = &quot;年龄&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DateTimeFormat(value = &quot;yyyy-MM-dd&quot;)</span></span><br><span class="line">    <span class="meta">@ExcelProperty(index = 2, value = &quot;出生日期&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test02Controller</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上传单个文件, 同步读取excel文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/uploadFile&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uploadFile</span><span class="params">(MultipartFile file)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> file.getInputStream()) &#123;</span><br><span class="line">            List&lt;UserExcel&gt; userExcelList = EasyExcel.read(in)</span><br><span class="line">                    <span class="comment">// 读取第一个sheet</span></span><br><span class="line">                    .sheet(<span class="number">0</span>)</span><br><span class="line">                    <span class="comment">// 如果第一行才是标题，第二行是数据，从第二行开始读取</span></span><br><span class="line">                    .headRowNumber(<span class="number">1</span>)</span><br><span class="line">                    .head(UserExcel.class)</span><br><span class="line">                    .doReadSync();</span><br><span class="line">            <span class="keyword">for</span> (UserExcel userExcel : userExcelList) &#123;</span><br><span class="line">                System.out.println(userExcel);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读取多个Sheet（同一个对象）">读取多个Sheet（同一个对象）</h3>
<p>使用doReadAllSync方法读取所有Sheet，适用于每个Sheet的对象都一致的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/uploadFile2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uploadFile2</span><span class="params">(MultipartFile file)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> file.getInputStream()) &#123;</span><br><span class="line">        List&lt;UserExcel&gt; userExcelList = EasyExcel.read(in)</span><br><span class="line">                <span class="comment">// 如果第一行才是标题，第二行是数据，从第二行开始读取</span></span><br><span class="line">                .headRowNumber(<span class="number">1</span>)</span><br><span class="line">                .head(UserExcel.class)</span><br><span class="line">                .doReadAllSync();</span><br><span class="line">        <span class="keyword">for</span> (UserExcel userExcel : userExcelList) &#123;</span><br><span class="line">            System.out.println(userExcel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读取多个Sheet（不同对象）">读取多个Sheet（不同对象）</h3>
<p>当每个Sheet的对象不一致的情况下，使用doReadAllSync方法无法指定每个Sheet的对象，可以依次读取Sheet进行解析</p>
<p>注意：依次读取Sheet会出现重复读取流对象的情况，而一个流对象只能读取一次，重复使用会导致异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/uploadFile4&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uploadFile4</span><span class="params">(MultipartFile file)</span> &#123;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        in = file.getInputStream();</span><br><span class="line">        List&lt;UserExcel&gt; userExcelList1 = EasyExcel.read(in)</span><br><span class="line">                <span class="comment">// 读取第一个sheet</span></span><br><span class="line">                .sheet(<span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 如果第一行才是标题，第二行是数据，从第二行开始读取</span></span><br><span class="line">                .headRowNumber(<span class="number">1</span>)</span><br><span class="line">                .head(UserExcel.class)</span><br><span class="line">                .doReadSync();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取剩余的sheet</span></span><br><span class="line">        in = file.getInputStream();</span><br><span class="line">        List&lt;UserExcel&gt; userExcelList2 = EasyExcel.read(in)</span><br><span class="line">                .sheet(<span class="number">1</span>)</span><br><span class="line">                <span class="comment">// 如果第一行才是标题，第二行是数据，从第二行开始读取</span></span><br><span class="line">                .headRowNumber(<span class="number">1</span>)</span><br><span class="line">                .head(UserExcel.class)</span><br><span class="line">                .doReadSync();</span><br><span class="line"></span><br><span class="line">        List&lt;UserExcel&gt; userExcelList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        userExcelList.addAll(userExcelList1);</span><br><span class="line">        userExcelList.addAll(userExcelList2);</span><br><span class="line">        <span class="keyword">for</span> (UserExcel userExcel : userExcelList) &#123;</span><br><span class="line">            System.out.println(userExcel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (in != <span class="literal">null</span>) &#123;</span><br><span class="line">                in.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="异步读取">异步读取</h2>
<h3 id="监听器">监听器</h3>
<p>查看监听器源码，通过实现ReadListener接口或继承AnalysisEventListener类可以自定义读取Sheet监听器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ReadListener</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Listener</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在转换异常 获取其他异常下会调用本接口。抛出异常则停止读取。如果这里不抛出异常则继续读取下一行</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">onException</span><span class="params">(Exception exception, AnalysisContext context)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">throw</span> exception;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取表头数据</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">invokeHead</span><span class="params">(Map&lt;Integer, ReadCellData&lt;?&gt;&gt; headMap, AnalysisContext context)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 一行行读取表格内容</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(T data, AnalysisContext context)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 读取条额外信息:批注、超链接、合并单元格信息等</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">extra</span><span class="params">(CellExtra extra, AnalysisContext context)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">   	<span class="comment">// 读取完成后的操作</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doAfterAllAnalysed</span><span class="params">(AnalysisContext context)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 是否还有数据</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">(AnalysisContext context)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AnalysisEventListener</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">ReadListener</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析表头数据</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invokeHead</span><span class="params">(Map&lt;Integer, ReadCellData&lt;?&gt;&gt; headMap, AnalysisContext context)</span> &#123;</span><br><span class="line">        invokeHeadMap(ConverterUtils.convertToStringMap(headMap, context), context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invokeHeadMap</span><span class="params">(Map&lt;Integer, String&gt; headMap, AnalysisContext context)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="异常处理">异常处理</h3>
<h4 id="ExcelDateConvertException">ExcelDateConvertException</h4>
<p>表示数据转换异常错误，出现该异常时会继续解析文件信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExcelDataConvertException</span> <span class="keyword">extends</span> <span class="title class_">ExcelRuntimeException</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer rowIndex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer columnIndex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CellData&lt;?&gt; cellData;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ExcelContentProperty excelContentProperty;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExcelDataConvertException</span><span class="params">(Integer rowIndex, Integer columnIndex, CellData&lt;?&gt; cellData,</span></span><br><span class="line"><span class="params">        ExcelContentProperty excelContentProperty, String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">        <span class="built_in">this</span>.rowIndex = rowIndex;</span><br><span class="line">        <span class="built_in">this</span>.columnIndex = columnIndex;</span><br><span class="line">        <span class="built_in">this</span>.cellData = cellData;</span><br><span class="line">        <span class="built_in">this</span>.excelContentProperty = excelContentProperty;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExcelDataConvertException</span><span class="params">(Integer rowIndex, Integer columnIndex, CellData&lt;?&gt; cellData,</span></span><br><span class="line"><span class="params">        ExcelContentProperty excelContentProperty, String message, Throwable cause)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message, cause);</span><br><span class="line">        <span class="built_in">this</span>.rowIndex = rowIndex;</span><br><span class="line">        <span class="built_in">this</span>.columnIndex = columnIndex;</span><br><span class="line">        <span class="built_in">this</span>.cellData = cellData;</span><br><span class="line">        <span class="built_in">this</span>.excelContentProperty = excelContentProperty;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ExcelAnalysisStopException">ExcelAnalysisStopException</h4>
<p>非数据转换异常错误，在onexcetpion中抛出该异常后停止解析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExcelAnalysisStopException</span> <span class="keyword">extends</span> <span class="title class_">ExcelAnalysisException</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExcelAnalysisStopException</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExcelAnalysisStopException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExcelAnalysisStopException</span><span class="params">(String message, Throwable cause)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExcelAnalysisStopException</span><span class="params">(Throwable cause)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读取单个Sheet（不指定对象）">读取单个Sheet（不指定对象）</h3>
<p>读取文件时使用doRead方法进行异步操作，同时指定对应的监听器解析文件数据</p>
<p>Map&lt;Integer, String&gt;中的key表示列号、value表示数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserExcelListener1</span> <span class="keyword">extends</span> <span class="title class_">AnalysisEventListener</span>&lt;Map&lt;Integer, String&gt;&gt; &#123;</span><br><span class="line">    <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Map&lt;Integer, String&gt;&gt; userExcelList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Map&lt;Integer, String&gt; map, AnalysisContext analysisContext)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;解析到一条数据:&#123;&#125;&quot;</span>, JSON.toJSONString(map));</span><br><span class="line">        userExcelList.add(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfterAllAnalysed</span><span class="params">(AnalysisContext analysisContext)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;已解析完所有数据!&quot;</span>);</span><br><span class="line">        userExcelList.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onException</span><span class="params">(Exception exception, AnalysisContext context)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> ExcelDataConvertException) &#123;</span><br><span class="line">            <span class="type">ExcelDataConvertException</span> <span class="variable">convertException</span> <span class="operator">=</span> (ExcelDataConvertException) exception;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">row</span> <span class="operator">=</span> convertException.getRowIndex();</span><br><span class="line">            log.error(<span class="string">&quot;第&#123;&#125;行数据转换失败，异常信息：&#123;&#125;&quot;</span>, row, exception.getMessage());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.error(<span class="string">&quot;导入其他异常信息：&#123;&#125;&quot;</span>, exception.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Map&lt;Integer, String&gt;&gt; <span class="title function_">getUserExcelList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userExcelList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserExcelList</span><span class="params">(List&lt;Map&lt;Integer, String&gt;&gt; userExcelList)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userExcelList = userExcelList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/uploadFile1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uploadFile1</span><span class="params">(MultipartFile file)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> file.getInputStream()) &#123;</span><br><span class="line">        <span class="type">UserExcelListener1</span> <span class="variable">listener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserExcelListener1</span>();</span><br><span class="line">        EasyExcel.read(in, listener)</span><br><span class="line">                .sheet(<span class="number">0</span>)</span><br><span class="line">                .headRowNumber(<span class="number">1</span>) <span class="comment">// 第一行是标题, 从第二行开始读取</span></span><br><span class="line">                .doRead();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读取单个Sheet（指定对象）">读取单个Sheet（指定对象）</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserExcelListener</span> <span class="keyword">extends</span> <span class="title class_">AnalysisEventListener</span>&lt;UserExcel&gt; &#123;</span><br><span class="line">    <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;UserExcel&gt; userExcelList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(UserExcel userExcel, AnalysisContext analysisContext)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;解析到一条数据:&#123;&#125;&quot;</span>, JSON.toJSONString(userExcel));</span><br><span class="line">        userExcelList.add(userExcel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfterAllAnalysed</span><span class="params">(AnalysisContext analysisContext)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;已解析完所有数据!&quot;</span>);</span><br><span class="line">        userExcelList.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onException</span><span class="params">(Exception exception, AnalysisContext context)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> ExcelDataConvertException) &#123;</span><br><span class="line">            <span class="type">ExcelDataConvertException</span> <span class="variable">convertException</span> <span class="operator">=</span> (ExcelDataConvertException) exception;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">row</span> <span class="operator">=</span> convertException.getRowIndex();</span><br><span class="line">            log.error(<span class="string">&quot;第&#123;&#125;行数据转换失败，异常信息：&#123;&#125;&quot;</span>, row, exception.getMessage());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.error(<span class="string">&quot;导入其他异常信息：&#123;&#125;&quot;</span>, exception.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;UserExcel&gt; <span class="title function_">getUserExcelList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userExcelList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserExcelList</span><span class="params">(List&lt;UserExcel&gt; userExcelList)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userExcelList = userExcelList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/uploadFile5&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uploadFile5</span><span class="params">(MultipartFile file)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> file.getInputStream()) &#123;</span><br><span class="line">        <span class="type">UserExcelListener</span> <span class="variable">listener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserExcelListener</span>();</span><br><span class="line">        EasyExcel.read(in, UserExcel.class, listener)</span><br><span class="line">                .sheet(<span class="number">0</span>)</span><br><span class="line">                .headRowNumber(<span class="number">1</span>) <span class="comment">// 第一行是标题, 从第二行开始读取</span></span><br><span class="line">                .doRead();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读取多个Sheet">读取多个Sheet</h3>
<ol>
<li>获取Sheet的总数，通过循环遍历的方式指定每个Sheet的监听器进行解析</li>
<li>使用构造器的方式传入Sheet对应的下标，在抛出异常时获取SheetNo和对应的行号，方便进行排查</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserExcelListener2</span> <span class="keyword">extends</span> <span class="title class_">AnalysisEventListener</span>&lt;UserExcel&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer sheetNo;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> List&lt;UserExcel&gt; userExcelList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserExcelListener2</span><span class="params">(Integer sheetNo)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sheetNo = sheetNo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(UserExcel userExcel, AnalysisContext analysisContext)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;解析到一条数据:&#123;&#125;&quot;</span>, JSON.toJSONString(userExcel));</span><br><span class="line">        userExcelList.add(userExcel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfterAllAnalysed</span><span class="params">(AnalysisContext analysisContext)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;已解析完所有数据!&quot;</span>);</span><br><span class="line">        userExcelList.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onException</span><span class="params">(Exception exception, AnalysisContext context)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> ExcelDataConvertException) &#123;</span><br><span class="line">            <span class="type">ExcelDataConvertException</span> <span class="variable">convertException</span> <span class="operator">=</span> (ExcelDataConvertException) exception;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">row</span> <span class="operator">=</span> convertException.getRowIndex();</span><br><span class="line">            log.error(<span class="string">&quot;sheetNo：&#123;&#125;，第&#123;&#125;行数据转换失败，异常信息：&#123;&#125;&quot;</span>, sheetNo, row, exception.getMessage());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.error(<span class="string">&quot;导入其他异常信息：&#123;&#125;&quot;</span>, exception.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;UserExcel&gt; <span class="title function_">getUserExcelList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userExcelList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserExcelList</span><span class="params">(List&lt;UserExcel&gt; userExcelList)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userExcelList = userExcelList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/uploadFile6&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uploadFile6</span><span class="params">(MultipartFile file)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> file.getInputStream();</span><br><span class="line">         <span class="type">ExcelReader</span> <span class="variable">build</span> <span class="operator">=</span> EasyExcel.read(in).build();) &#123;</span><br><span class="line">        List&lt;ReadSheet&gt; readSheets = build.excelExecutor().sheetList();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, len = readSheets.size(); i &lt; len; i++) &#123;</span><br><span class="line">            <span class="type">UserExcelListener2</span> <span class="variable">listener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserExcelListener2</span>(i);</span><br><span class="line">            <span class="type">ReadSheet</span> <span class="variable">sheet</span> <span class="operator">=</span> EasyExcel.readSheet(readSheets.get(i).getSheetNo())</span><br><span class="line">                    .head(UserExcel.class)</span><br><span class="line">                    .headRowNumber(<span class="number">1</span>)</span><br><span class="line">                    .registerReadListener(listener)</span><br><span class="line">                    .build();</span><br><span class="line">            build.read(sheet);</span><br><span class="line">        &#125;</span><br><span class="line">        build.finish();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分批读取（线程池操作）">分批读取（线程池操作）</h3>
<ol>
<li>使用构造器的方式传入Sheet对应的下标和自定义线程池，使用这种分批处理的方式，避免内存的消耗，加快文件的解析入库</li>
<li>数据库入库时可以使用MySQL的批量插入语法，同时指定每次插入数据的大小，相较于MyBatisPlus的批量插入方法较快（<strong>疑问：在MyBatisPlus的批量插入方法时出现数据部分丢失的情况</strong>）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UserListener 不能被spring管理，要每次读取excel都要new，</span></span><br><span class="line"><span class="comment"> * 然后里面用到spring可以构造方法传进去</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserExcelListener3</span> <span class="keyword">extends</span> <span class="title class_">AnalysisEventListener</span>&lt;UserExcel&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">BATCH_SIZE</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer sheetNo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Executor executor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;UserExcel&gt; userExcelList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserExcelListener3</span><span class="params">(Integer sheetNo, Executor executor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sheetNo = sheetNo;</span><br><span class="line">        <span class="built_in">this</span>.executor = executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(UserExcel userExcel, AnalysisContext analysisContext)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;解析到一条数据:&#123;&#125;&quot;</span>, JSON.toJSONString(userExcel));</span><br><span class="line">        userExcelList.add(userExcel);</span><br><span class="line">        <span class="keyword">if</span> (userExcelList.size() &gt;= BATCH_SIZE) &#123;</span><br><span class="line">            List&lt;UserExcel&gt; userExcels = BeanUtil.copyToList(userExcelList, UserExcel.class);</span><br><span class="line">            CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">                <span class="comment">// 业务操作</span></span><br><span class="line">                <span class="comment">// saveToDB(userExcels);</span></span><br><span class="line">            &#125;, executor);</span><br><span class="line">            userExcelList.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfterAllAnalysed</span><span class="params">(AnalysisContext analysisContext)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;已解析完所有数据!&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!userExcelList.isEmpty()) &#123;</span><br><span class="line">            List&lt;UserExcel&gt; userExcels = BeanUtil.copyToList(userExcelList, UserExcel.class);</span><br><span class="line">            CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">                <span class="comment">// 业务操作</span></span><br><span class="line">                <span class="comment">// saveToDB(userExcels);</span></span><br><span class="line">            &#125;, executor);</span><br><span class="line">            userExcelList.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onException</span><span class="params">(Exception exception, AnalysisContext context)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> ExcelDataConvertException) &#123;</span><br><span class="line">            <span class="type">ExcelDataConvertException</span> <span class="variable">convertException</span> <span class="operator">=</span> (ExcelDataConvertException) exception;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">row</span> <span class="operator">=</span> convertException.getRowIndex();</span><br><span class="line">            log.error(<span class="string">&quot;sheetNo：&#123;&#125;，第&#123;&#125;行数据转换失败，异常信息：&#123;&#125;&quot;</span>, sheetNo, row, exception.getMessage());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.error(<span class="string">&quot;导入其他异常信息：&#123;&#125;&quot;</span>, exception.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/uploadFile7&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uploadFile77</span><span class="params">(MultipartFile file)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> file.getInputStream();</span><br><span class="line">         <span class="type">ExcelReader</span> <span class="variable">build</span> <span class="operator">=</span> EasyExcel.read(in).build();) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">60L</span>,</span><br><span class="line">                TimeUnit.MILLISECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1000</span>), <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line">        List&lt;ReadSheet&gt; readSheets = build.excelExecutor().sheetList();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, len = readSheets.size(); i &lt; len; i++) &#123;</span><br><span class="line">            <span class="type">UserExcelListener3</span> <span class="variable">listener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserExcelListener3</span>(i, executor);</span><br><span class="line">            <span class="type">ReadSheet</span> <span class="variable">sheet</span> <span class="operator">=</span> EasyExcel.readSheet(readSheets.get(i).getSheetNo())</span><br><span class="line">                    .head(UserExcel.class)</span><br><span class="line">                    .headRowNumber(<span class="number">1</span>)</span><br><span class="line">                    .registerReadListener(listener)</span><br><span class="line">                    .build();</span><br><span class="line">            build.read(sheet);</span><br><span class="line">        &#125;</span><br><span class="line">        build.finish();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="事务操作">事务操作</h3>
<p>当使用监听器读取文件数据，使用分批插入数据的方法时，因为监听器不归Spring管理，所以无法使用Spring的事务注解进行事务的相关操作，怎么保证事务？</p>
<p>可以通过构造器的方式传入事务管理器，手动提交和回滚事务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDataListener</span> <span class="keyword">extends</span> <span class="title class_">AnalysisEventListener</span>&lt;Test&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//每隔5条存储数据库，实际使用中可以设置为2500条，然后清理list ，方便内存回收</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BATCH_COUNT</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Test&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//事务管理</span></span><br><span class="line">    <span class="keyword">private</span> DataSourceTransactionManager dataSourceTransactionManager;</span><br><span class="line">    <span class="comment">//事务定义</span></span><br><span class="line">    <span class="keyword">private</span> DefaultTransactionDefinition transactionDefinition;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">TransactionStatus</span> <span class="variable">transactionStatus</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TestService testService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TestDataListener</span><span class="params">(TestService testService,</span></span><br><span class="line"><span class="params">                            DataSourceTransactionManager dataSourceTransactionManager,</span></span><br><span class="line"><span class="params">                            TransactionDefinition transactionDefinition)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.testService = testService;</span><br><span class="line">        <span class="built_in">this</span>.dataSourceTransactionManager = dataSourceTransactionManager;</span><br><span class="line">        <span class="built_in">this</span>.transactionDefinition = <span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>(transactionDefinition);</span><br><span class="line">        <span class="comment">//设置事务的隔离级别 ：未提交读写</span></span><br><span class="line">        <span class="built_in">this</span>.transactionDefinition.setIsolationLevel(TransactionDefinition.ISOLATION_READ_UNCOMMITTED);</span><br><span class="line">        <span class="comment">// 手动开启事务</span></span><br><span class="line">        <span class="built_in">this</span>.transactionStatus = dataSourceTransactionManager.getTransaction(transactionDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Test data, AnalysisContext context)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;解析到一条数据:&#123;&#125;&quot;</span>, JSON.toJSONString(data));</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">hasCompleted</span> <span class="operator">=</span> transactionStatus.isCompleted();</span><br><span class="line">        <span class="comment">// 如果事务已经关闭，不执行业务代码</span></span><br><span class="line">        <span class="keyword">if</span> (hasCompleted)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(data);</span><br><span class="line">        <span class="keyword">if</span> (list.size() &gt;= BATCH_COUNT) &#123;</span><br><span class="line">            saveData();</span><br><span class="line">            list.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个方法会在easyexcel读取完文件中所有数据后执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfterAllAnalysed</span><span class="params">(AnalysisContext context)</span> &#123;</span><br><span class="line">        <span class="comment">//判断事务是否已被处理，未处理则进行提交事务</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">hasCompleted</span> <span class="operator">=</span> transactionStatus.isCompleted();</span><br><span class="line">        <span class="keyword">if</span> (hasCompleted)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        saveData();</span><br><span class="line">        log.info(<span class="string">&quot;所有数据解析完成！&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!hasCompleted)&#123;</span><br><span class="line">            <span class="comment">//提交事务</span></span><br><span class="line">            dataSourceTransactionManager.commit(transactionStatus);</span><br><span class="line">            log.info(<span class="string">&quot;SensitiveWordListener doAfterAllAnalysed：当前事务已提交&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onException</span><span class="params">(Exception exception, AnalysisContext context)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        log.info(<span class="string">&quot;导入过程中出现异常会进入该方法，重写了父类方法&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;结束前事务状态：&quot;</span>+  transactionStatus.isCompleted());</span><br><span class="line">        dataSourceTransactionManager.rollback(transactionStatus);</span><br><span class="line">        log.info(<span class="string">&quot;结束后事务状态：&quot;</span>+  transactionStatus.isCompleted());</span><br><span class="line">        <span class="keyword">throw</span> exception;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加上存储数据库</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">saveData</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;条数据，开始存储数据库！&quot;</span>, list.size());</span><br><span class="line">        <span class="keyword">if</span> (!CollectionUtils.isEmpty(list)) &#123;</span><br><span class="line">            testService.saveBatch(list);</span><br><span class="line">            System.out.println(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//TODO 这里是测试事务，如有需要可以打开注释</span></span><br><span class="line">        <span class="comment">//int a = 1/0;</span></span><br><span class="line">        log.info(<span class="string">&quot;存储数据库成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Excel</tag>
        <tag>EasyExcel</tag>
      </tags>
  </entry>
  <entry>
    <title>Easyexcel（4-模板文件）</title>
    <url>/blog/2024/10/28/Java/excel/easyexcel/Easyexcel%EF%BC%884-%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6%EF%BC%89/</url>
    <content><![CDATA[<h2 id="文件导出">文件导出</h2>
<p>获取 resources 目录下的文件，使用 withTemplate 获取文件流导出文件模板</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/download1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download1</span><span class="params">(HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;测试.xls&quot;</span>).getInputStream()) &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/vnd.ms-excel&quot;</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 这里URLEncoder.encode可以防止中文乱码 当然和easyexcel没有关系</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> URLEncoder.encode(<span class="string">&quot;测试&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>).replaceAll(<span class="string">&quot;\\+&quot;</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-disposition&quot;</span>, <span class="string">&quot;attachment;filename=&quot;</span> + fileName + <span class="string">&quot;.xls&quot;</span>);</span><br><span class="line"></span><br><span class="line">        EasyExcel.write(response.getOutputStream())</span><br><span class="line">                .withTemplate(in)</span><br><span class="line">                .sheet(<span class="string">&quot;sheet1&quot;</span>)</span><br><span class="line">                .doWrite(Collections.emptyList());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：获取 resources 目录下的文件需要在 maven 中添加以下配置，过滤对应的文件，防止编译生成后的 class 文件找不到对应的文件信息</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">nonFilteredFileExtensions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">nonFilteredFileExtension</span>&gt;</span>xls<span class="tag">&lt;/<span class="name">nonFilteredFileExtension</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">nonFilteredFileExtension</span>&gt;</span>xlsx<span class="tag">&lt;/<span class="name">nonFilteredFileExtension</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">nonFilteredFileExtensions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="对象填充导出">对象填充导出</h2>
<p><strong>模板文件信息</strong></p>
<p><img src="1.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;用户Id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;姓名&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;手机&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;邮箱&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;创建时间&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/download5&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download5</span><span class="params">(HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;测试3.xls&quot;</span>).getInputStream()) &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/vnd.ms-excel&quot;</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 这里URLEncoder.encode可以防止中文乱码 当然和easyexcel没有关系</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> URLEncoder.encode(<span class="string">&quot;测试3&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>).replaceAll(<span class="string">&quot;\\+&quot;</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-disposition&quot;</span>, <span class="string">&quot;attachment;filename=&quot;</span> + fileName + <span class="string">&quot;.xls&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;张三&quot;</span>, <span class="string">&quot;12345678901&quot;</span>, <span class="string">&quot;zhangsan@qq.com&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        EasyExcel.write(response.getOutputStream(), User.class)</span><br><span class="line">                .withTemplate(in)</span><br><span class="line">                .sheet(<span class="string">&quot;模板&quot;</span>)</span><br><span class="line">                .doFill(user);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：填充模板跟写文件使用的方法不一致，模板填充使用的方法是 doFill，而不是 doWrite</p>
<p><strong>导出文件内容</strong></p>
<p><img src="9.png" alt=""></p>
<h2 id="List-填充导出">List 填充导出</h2>
<h3 id="对象导出">对象导出</h3>
<p><strong>模板文件信息</strong></p>
<p><img src="1.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;用户Id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;姓名&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;手机&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;邮箱&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;创建时间&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/download2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download2</span><span class="params">(HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;测试.xls&quot;</span>).getInputStream()) &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/vnd.ms-excel&quot;</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 这里URLEncoder.encode可以防止中文乱码 当然和easyexcel没有关系</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> URLEncoder.encode(<span class="string">&quot;测试&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>).replaceAll(<span class="string">&quot;\\+&quot;</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-disposition&quot;</span>, <span class="string">&quot;attachment;filename=&quot;</span> + fileName + <span class="string">&quot;.xls&quot;</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; userList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        userList.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;张三&quot;</span>, <span class="string">&quot;12345678901&quot;</span>, <span class="string">&quot;zhangsan@qq.com&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">        userList.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">2</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;12345678902&quot;</span>, <span class="string">&quot;lisi@qq.com&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">        EasyExcel.write(response.getOutputStream(), User.class)</span><br><span class="line">                .withTemplate(in)</span><br><span class="line">                .sheet(<span class="string">&quot;模板&quot;</span>)</span><br><span class="line">                .doFill(userList);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>导出文件内容</strong></p>
<p><img src="2.png" alt=""></p>
<h3 id="对象嵌套对象（默认不支持）">对象嵌套对象（默认不支持）</h3>
<h4 id="原因排查">原因排查</h4>
<p><strong>模板文件信息</strong></p>
<p><img src="3.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;用户Id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;姓名&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;手机&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;邮箱&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;学生&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Student stu;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@ExcelProperty(&quot;姓名&quot;)</span></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@ExcelProperty(&quot;年龄&quot;)</span></span><br><span class="line">        <span class="keyword">private</span> Integer age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/download3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download3</span><span class="params">(HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;测试2.xls&quot;</span>).getInputStream()) &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/vnd.ms-excel&quot;</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 这里URLEncoder.encode可以防止中文乱码 当然和easyexcel没有关系</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> URLEncoder.encode(<span class="string">&quot;测试2&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>).replaceAll(<span class="string">&quot;\\+&quot;</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-disposition&quot;</span>, <span class="string">&quot;attachment;filename=&quot;</span> + fileName + <span class="string">&quot;.xls&quot;</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; userList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        userList.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;张三&quot;</span>, <span class="string">&quot;12345678901&quot;</span>, <span class="string">&quot;zhangsan@qq.com&quot;</span>, <span class="keyword">new</span> <span class="title class_">User</span>.Student(<span class="string">&quot;张三&quot;</span>, <span class="number">12</span>)));</span><br><span class="line">        userList.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">2</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;12345678902&quot;</span>, <span class="string">&quot;lisi@qq.com&quot;</span>, <span class="keyword">new</span> <span class="title class_">User</span>.Student(<span class="string">&quot;李四&quot;</span>, <span class="number">13</span>)));</span><br><span class="line">        EasyExcel.write(response.getOutputStream(), User.class)</span><br><span class="line">                .withTemplate(in)</span><br><span class="line">                .sheet(<span class="string">&quot;模板&quot;</span>)</span><br><span class="line">                .doFill(userList);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>导出文件内容</strong></p>
<p>结果：Student 类的内容没有填充到模板文件中</p>
<p><img src="4.png" alt=""></p>
<p><strong>查看 ExcelWriteFillExecutor 源码</strong></p>
<p>可以看到 dataKeySet 集合中的数据只有 stu（没有 <a href="http://stu.name">stu.name</a> 和 stu.age），在! dataKeySet.contains(variable)方法中判断没有包含该字段信息，所以被过滤掉</p>
<p><img src="5.png" alt=""></p>
<p><img src="6.png" alt=""></p>
<h4 id="修改源码支持">修改源码支持</h4>
<p>在 com.alibaba.excel.write.executor 包下创建 ExcelWriteFillExecutor 类，跟源码中的类名称一致，尝试修改 analysisCell.getOnlyOneVariable()方法中的逻辑以便支持嵌套对象，修改如下：</p>
<p>根据分隔符.进行划分，循环获取对象中字段的数据，同时在 FieldUtils.getFieldClass 方法中重新设置 map 对象和字段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (analysisCell.getOnlyOneVariable()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">variable</span> <span class="operator">=</span> analysisCell.getVariableList().get(<span class="number">0</span>);</span><br><span class="line">    String[] split = variable.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> BeanUtil.copyProperties(dataMap, Map.class);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (split.length == <span class="number">1</span>) &#123;</span><br><span class="line">        value = map.get(variable);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> split.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> map.get(split[i]);</span><br><span class="line">            map = BeanMapUtils.create(o);</span><br><span class="line">        &#125;</span><br><span class="line">        value = map.get(split[split.length - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">ExcelContentProperty</span> <span class="variable">excelContentProperty</span> <span class="operator">=</span> ClassUtils.declaredExcelContentProperty(map,</span><br><span class="line">            writeContext.currentWriteHolder().excelWriteHeadProperty().getHeadClazz(), split[split.length - <span class="number">1</span>],</span><br><span class="line">            writeContext.currentWriteHolder());</span><br><span class="line">    cellWriteHandlerContext.setExcelContentProperty(excelContentProperty);</span><br><span class="line"></span><br><span class="line">    createCell(analysisCell, fillConfig, cellWriteHandlerContext, rowWriteHandlerContext);</span><br><span class="line">    cellWriteHandlerContext.setOriginalValue(value);</span><br><span class="line">    cellWriteHandlerContext.setOriginalFieldClass(FieldUtils.getFieldClass(map, split[split.length - <span class="number">1</span>], value));</span><br><span class="line"></span><br><span class="line">    converterAndSet(cellWriteHandlerContext);</span><br><span class="line">    WriteCellData&lt;?&gt; cellData = cellWriteHandlerContext.getFirstCellData();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Restyle</span></span><br><span class="line">    <span class="keyword">if</span> (fillConfig.getAutoStyle()) &#123;</span><br><span class="line">        Optional.ofNullable(collectionFieldStyleCache.get(currentUniqueDataFlag))</span><br><span class="line">                .map(collectionFieldStyleMap -&gt; collectionFieldStyleMap.get(analysisCell))</span><br><span class="line">                .ifPresent(cellData::setOriginCellStyle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>导出文件内容</strong></p>
<p>查看导出的文件内容，此时发现嵌套对象的内容可以导出了</p>
<p><img src="10.png" alt=""></p>
<h3 id="对象嵌套-List（默认不支持）">对象嵌套 List（默认不支持）</h3>
<h4 id="原因排查-2">原因排查</h4>
<p><strong>模板文件信息</strong></p>
<p><img src="13.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;用户Id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;姓名&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;手机&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;邮箱&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;创建时间&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;id列表&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; idList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/download4&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download4</span><span class="params">(HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;测试2.xls&quot;</span>).getInputStream()) &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/vnd.ms-excel&quot;</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 这里URLEncoder.encode可以防止中文乱码 当然和easyexcel没有关系</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> URLEncoder.encode(<span class="string">&quot;测试&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>).replaceAll(<span class="string">&quot;\\+&quot;</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-disposition&quot;</span>, <span class="string">&quot;attachment;filename=&quot;</span> + fileName + <span class="string">&quot;.xls&quot;</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; userList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        userList.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;张三&quot;</span>, <span class="string">&quot;12345678901&quot;</span>, <span class="string">&quot;zhangsan@qq.com&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), Arrays.asList(<span class="string">&quot;234&quot;</span>, <span class="string">&quot;465&quot;</span>)));</span><br><span class="line">        userList.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">2</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;12345678902&quot;</span>, <span class="string">&quot;lisi@qq.com&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), Arrays.asList(<span class="string">&quot;867&quot;</span>, <span class="string">&quot;465&quot;</span>)));</span><br><span class="line">        EasyExcel.write(response.getOutputStream(), User.class)</span><br><span class="line">                .withTemplate(in)</span><br><span class="line">                .sheet(<span class="string">&quot;模板&quot;</span>)</span><br><span class="line">                .doFill(userList);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行后会发现报错 Can not find ‘Converter’ support class ArrayList.</p>
<p>EasyExcel 默认不支持对象嵌套 List 的，可以通过自定义转换器的方式修改导出的内容</p>
<h4 id="自定义转换器">自定义转换器</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListConvert</span> <span class="keyword">implements</span> <span class="title class_">Converter</span>&lt;List&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> WriteCellData&lt;?&gt; convertToExcelData(List value, ExcelContentProperty contentProperty, GlobalConfiguration globalConfiguration) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">null</span> || value.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WriteCellData</span>&lt;&gt;(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">val</span> <span class="operator">=</span> (String) value.stream().collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WriteCellData</span>&lt;&gt;(val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List <span class="title function_">convertToJavaData</span><span class="params">(ReadCellData&lt;?&gt; cellData, ExcelContentProperty contentProperty, GlobalConfiguration globalConfiguration)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cellData.getStringValue() == <span class="literal">null</span> || cellData.getStringValue().isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        String[] items = cellData.getStringValue().split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        Collections.addAll(list, items);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;用户Id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;姓名&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;手机&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;邮箱&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;创建时间&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;id列表&quot;, converter = ListConvert.class)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; idList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>导出文件内容</strong></p>
<p>可以看到 List 列表的数据导出内容为 String 字符串，显示在一个单元格内</p>
<p><img src="14.png" alt=""></p>
<h2 id="Map-填充导出">Map 填充导出</h2>
<h3 id="简单导出">简单导出</h3>
<p><strong>模板文件信息</strong></p>
<p><img src="11.png" alt=""></p>
<p>注意：map跟对象导出有所区别，最前面没有.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/download4&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download4</span><span class="params">(HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;测试3.xls&quot;</span>).getInputStream()) &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/vnd.ms-excel&quot;</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 这里URLEncoder.encode可以防止中文乱码 当然和easyexcel没有关系</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> URLEncoder.encode(<span class="string">&quot;测试&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>).replaceAll(<span class="string">&quot;\\+&quot;</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-disposition&quot;</span>, <span class="string">&quot;attachment;filename=&quot;</span> + fileName + <span class="string">&quot;.xls&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;userId&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;phone&quot;</span>, <span class="string">&quot;12345678901&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;email&quot;</span>, <span class="string">&quot;zhangsan@qq.com&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;createTime&quot;</span>, <span class="string">&quot;2021-01-01&quot;</span>);</span><br><span class="line">        EasyExcel.write(response.getOutputStream(), User.class)</span><br><span class="line">                .withTemplate(in)</span><br><span class="line">                .sheet(<span class="string">&quot;模板&quot;</span>)</span><br><span class="line">                .doFill(map);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>导出文件内容</strong></p>
<p><img src="12.png" alt=""></p>
<h3 id="嵌套方式（不支持）">嵌套方式（不支持）</h3>
<p><strong>模板文件信息</strong></p>
<p><img src="7.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/download4&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download4</span><span class="params">(HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;测试3.xls&quot;</span>).getInputStream()) &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/vnd.ms-excel&quot;</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 这里URLEncoder.encode可以防止中文乱码 当然和easyexcel没有关系</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> URLEncoder.encode(<span class="string">&quot;测试&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>).replaceAll(<span class="string">&quot;\\+&quot;</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-disposition&quot;</span>, <span class="string">&quot;attachment;filename=&quot;</span> + fileName + <span class="string">&quot;.xls&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;userId&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;phone&quot;</span>, <span class="string">&quot;12345678901&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;email&quot;</span>, <span class="string">&quot;zhangsan@qq.com&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;createTime&quot;</span>, <span class="string">&quot;2021-01-01&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;student.name&quot;</span>, <span class="string">&quot;小张&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;student.age&quot;</span>, <span class="string">&quot;23&quot;</span>);</span><br><span class="line">        EasyExcel.write(response.getOutputStream(), User.class)</span><br><span class="line">                .withTemplate(in)</span><br><span class="line">                .sheet(<span class="string">&quot;模板&quot;</span>)</span><br><span class="line">                .doFill(map);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>导出文件内容</strong></p>
<p>注意：Easyexcel 不支持嵌套的方式导出数据</p>
<p><img src="8.png" alt=""></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Excel</tag>
        <tag>EasyExcel</tag>
      </tags>
  </entry>
  <entry>
    <title>Easyexcel（3-文件导出）</title>
    <url>/blog/2024/10/27/Java/excel/easyexcel/Easyexcel%EF%BC%883-%E6%96%87%E4%BB%B6%E5%AF%BC%E5%87%BA%EF%BC%89/</url>
    <content><![CDATA[<h2 id="响应头设置">响应头设置</h2>
<p>通过设置文件导出的响应头，可以自定义文件导出的名字信息等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//编码格式为UTF-8</span></span><br><span class="line">response.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//让服务器告诉浏览器它发送的数据属于excel文件类型</span></span><br><span class="line">response.setContentType(<span class="string">&quot;application/vnd.ms-excel;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//描述内容在传输过程中的编码格式，BINARY可能不止包含非ASCII字符，还可能不是一个短行（超过1000字符）。</span></span><br><span class="line">response.setHeader(<span class="string">&quot;Content-Transfer-Encoding&quot;</span>, <span class="string">&quot;binary&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//must-revalidate：强制页面不缓存，post-check=0, pre-check=0：0秒后，在显示给用户之前，该对象被选中进行更新过</span></span><br><span class="line">response.setHeader(<span class="string">&quot;Cache-Control&quot;</span>, <span class="string">&quot;must-revalidate, post-check=0, pre-check=0&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//表示响应可能是任何缓存的，即使它只是通常是非缓存或可缓存的仅在非共享缓存中</span></span><br><span class="line">response.setHeader(<span class="string">&quot;Pragma&quot;</span>, <span class="string">&quot;public&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//告诉浏览器这个文件的名字和类型，attachment：作为附件下载；inline：直接打开</span></span><br><span class="line">response.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment;filename=&quot;</span> + fileName + <span class="string">&quot;.xls&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="写入单个Sheet">写入单个Sheet</h2>
<h3 id="一次性写入数据">一次性写入数据</h3>
<p>指定导出内容所对应的对象信息，通过doWrite写入数据</p>
<p>注意：doWrite方法必须传入的是集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;用户Id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;姓名&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;手机&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;邮箱&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;创建时间&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/download1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download1</span><span class="params">(HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/vnd.ms-excel&quot;</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 这里URLEncoder.encode可以防止中文乱码 当然和easyexcel没有关系</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> URLEncoder.encode(<span class="string">&quot;测试&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>).replaceAll(<span class="string">&quot;\\+&quot;</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-disposition&quot;</span>, <span class="string">&quot;attachment;filename=&quot;</span> + fileName + <span class="string">&quot;.xls&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setUserId(<span class="number">123</span>);</span><br><span class="line">        user.setName(<span class="string">&quot;as&quot;</span>);</span><br><span class="line">        user.setPhone(<span class="string">&quot;15213&quot;</span>);</span><br><span class="line">        user.setEmail(<span class="string">&quot;5456&quot;</span>);</span><br><span class="line">        user.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        EasyExcel.write(response.getOutputStream(), User.class)</span><br><span class="line">                .sheet(<span class="string">&quot;模板&quot;</span>)</span><br><span class="line">                .doWrite(Arrays.asList(user));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分批写入数据">分批写入数据</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/download2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download2</span><span class="params">(HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="type">ExcelWriter</span> <span class="variable">excelWriter</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/vnd.ms-excel&quot;</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 这里URLEncoder.encode可以防止中文乱码 当然和easyexcel没有关系</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> URLEncoder.encode(<span class="string">&quot;测试&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>).replaceAll(<span class="string">&quot;\\+&quot;</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-disposition&quot;</span>, <span class="string">&quot;attachment;filename=&quot;</span> + fileName + <span class="string">&quot;.xls&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setUserId(<span class="number">123</span>);</span><br><span class="line">        user.setName(<span class="string">&quot;as&quot;</span>);</span><br><span class="line">        user.setPhone(<span class="string">&quot;15213&quot;</span>);</span><br><span class="line">        user.setEmail(<span class="string">&quot;5456&quot;</span>);</span><br><span class="line">        user.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line">        excelWriter = EasyExcel.write(response.getOutputStream(), User.class).build();</span><br><span class="line">        <span class="type">WriteSheet</span> <span class="variable">writeSheet</span> <span class="operator">=</span> EasyExcel.writerSheet(<span class="string">&quot;测试&quot;</span>).build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 业务逻辑处理，分页查询</span></span><br><span class="line">        excelWriter.write(Arrays.asList(user), writeSheet);</span><br><span class="line">        excelWriter.write(Arrays.asList(user), writeSheet);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (excelWriter != <span class="literal">null</span>) &#123;</span><br><span class="line">            excelWriter.finish();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过WriteSheet对象可以指定要写入的Sheet，通过上面方式我们可以手工控制流的关闭，这样我们就可以实现多次写。可以实现分页查询获取数据，然后将数据写入Excel中，避免一次性加载的数据过多，导致内存溢出</p>
<p>在使用excelWriter.write方式时务必保证至少执行一次write，这样是为了将sheet和表头写入excel，否则打开excel时会报错。write的第一个参数可以为null</p>
<h3 id="导出表头自定义">导出表头自定义</h3>
<p>使用注解的方式定义表头时不能动态控制，每次修改表头内容时只能重新修改代码，这时可以通过head方法动态传参自定义表头</p>
<p>注意：内容结构必须是List&lt;List&lt;T&gt;&gt;，如果使用List&lt;T&gt;会出现问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/download3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download3</span><span class="params">(HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="type">ExcelWriter</span> <span class="variable">excelWriter</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/vnd.ms-excel&quot;</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 这里URLEncoder.encode可以防止中文乱码 当然和easyexcel没有关系</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> URLEncoder.encode(<span class="string">&quot;测试&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>).replaceAll(<span class="string">&quot;\\+&quot;</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-disposition&quot;</span>, <span class="string">&quot;attachment;filename=&quot;</span> + fileName + <span class="string">&quot;.xls&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setUserId(<span class="number">123</span>);</span><br><span class="line">        user.setName(<span class="string">&quot;as&quot;</span>);</span><br><span class="line">        user.setPhone(<span class="string">&quot;15213&quot;</span>);</span><br><span class="line">        user.setEmail(<span class="string">&quot;5456&quot;</span>);</span><br><span class="line">        user.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; heads = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        heads.add(Arrays.asList(<span class="string">&quot;姓名&quot;</span>));</span><br><span class="line">        heads.add(Arrays.asList(<span class="string">&quot;年龄&quot;</span>));</span><br><span class="line">        heads.add(Arrays.asList(<span class="string">&quot;地址&quot;</span>));</span><br><span class="line">        excelWriter = EasyExcel.write(response.getOutputStream()).head(heads).build();</span><br><span class="line">        <span class="type">WriteSheet</span> <span class="variable">writeSheet</span> <span class="operator">=</span> EasyExcel.writerSheet(<span class="string">&quot;测试&quot;</span>).build();</span><br><span class="line">        excelWriter.write(Arrays.asList(user), writeSheet);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (excelWriter != <span class="literal">null</span>) &#123;</span><br><span class="line">            excelWriter.finish();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="1.png" alt=""></p>
<h3 id="导出内容自定义">导出内容自定义</h3>
<p>当导出的内容不是某个固定的实体类时，希望导出不同的内容时可以通过List&lt;List&lt;String&gt;&gt;自定义要写入的内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/download5&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download5</span><span class="params">(HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="type">ExcelWriter</span> <span class="variable">excelWriter</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/vnd.ms-excel&quot;</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 这里URLEncoder.encode可以防止中文乱码 当然和easyexcel没有关系</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> URLEncoder.encode(<span class="string">&quot;测试&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>).replaceAll(<span class="string">&quot;\\+&quot;</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-disposition&quot;</span>, <span class="string">&quot;attachment;filename=&quot;</span> + fileName + <span class="string">&quot;.xls&quot;</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; heads = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        heads.add(Arrays.asList(<span class="string">&quot;姓名&quot;</span>));</span><br><span class="line">        heads.add(Arrays.asList(<span class="string">&quot;年龄&quot;</span>));</span><br><span class="line">        heads.add(Arrays.asList(<span class="string">&quot;地址&quot;</span>));</span><br><span class="line">        excelWriter = EasyExcel.write(response.getOutputStream()).head(heads).build();</span><br><span class="line">        <span class="type">WriteSheet</span> <span class="variable">writeSheet</span> <span class="operator">=</span> EasyExcel.writerSheet(<span class="string">&quot;测试&quot;</span>).build();</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; dataList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dataList.add(Arrays.asList(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;18&quot;</span>, <span class="string">&quot;上海&quot;</span>));</span><br><span class="line">        dataList.add(Arrays.asList(<span class="string">&quot;李四&quot;</span>, <span class="string">&quot;28&quot;</span>));</span><br><span class="line">        excelWriter.write(dataList, writeSheet);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (excelWriter != <span class="literal">null</span>) &#123;</span><br><span class="line">            excelWriter.finish();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="2.png" alt=""></p>
<h3 id="写入多个表头">写入多个表头</h3>
<p>若业务需求要求在同一个Sheet中写多个表，就需要用到WriteTable了。只定义一个WriteSheet，有几个表就定义几个WriteTable即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/download4&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download4</span><span class="params">(HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="type">ExcelWriter</span> <span class="variable">excelWriter</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/vnd.ms-excel&quot;</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 这里URLEncoder.encode可以防止中文乱码 当然和easyexcel没有关系</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> URLEncoder.encode(<span class="string">&quot;测试&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>).replaceAll(<span class="string">&quot;\\+&quot;</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-disposition&quot;</span>, <span class="string">&quot;attachment;filename=&quot;</span> + fileName + <span class="string">&quot;.xls&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setUserId(<span class="number">123</span>);</span><br><span class="line">        user.setName(<span class="string">&quot;as&quot;</span>);</span><br><span class="line">        user.setPhone(<span class="string">&quot;15213&quot;</span>);</span><br><span class="line">        user.setEmail(<span class="string">&quot;5456&quot;</span>);</span><br><span class="line">        user.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line">        excelWriter = EasyExcel.write(response.getOutputStream()).build();</span><br><span class="line">        <span class="type">WriteSheet</span> <span class="variable">writeSheet</span> <span class="operator">=</span> EasyExcel.writerSheet(<span class="string">&quot;测试&quot;</span>).build();</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; heads1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        heads1.add(Arrays.asList(<span class="string">&quot;姓名&quot;</span>));</span><br><span class="line">        heads1.add(Arrays.asList(<span class="string">&quot;年龄&quot;</span>));</span><br><span class="line">        heads1.add(Arrays.asList(<span class="string">&quot;地址&quot;</span>));</span><br><span class="line">        <span class="type">WriteTable</span> <span class="variable">writeTable1</span> <span class="operator">=</span> EasyExcel.writerTable(<span class="number">1</span>).head(heads1).needHead(<span class="literal">true</span>).build();</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; heads2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        heads2.add(Arrays.asList(<span class="string">&quot;姓名&quot;</span>));</span><br><span class="line">        heads2.add(Arrays.asList(<span class="string">&quot;年龄&quot;</span>));</span><br><span class="line">        heads2.add(Arrays.asList(<span class="string">&quot;地址&quot;</span>));</span><br><span class="line">        heads2.add(Arrays.asList(<span class="string">&quot;出生日期&quot;</span>));</span><br><span class="line">        <span class="type">WriteTable</span> <span class="variable">writeTable2</span> <span class="operator">=</span> EasyExcel.writerTable(<span class="number">2</span>).head(heads2).needHead(<span class="literal">true</span>).build();</span><br><span class="line"></span><br><span class="line">        excelWriter.write(Arrays.asList(user), writeSheet, writeTable1);</span><br><span class="line">        excelWriter.write(Arrays.asList(user), writeSheet, writeTable2);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (excelWriter != <span class="literal">null</span>) &#123;</span><br><span class="line">            excelWriter.finish();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="3.png" alt=""></p>
<h2 id="写入多个Sheet">写入多个Sheet</h2>
<p>通过EasyExcel.writerSheet创建对应的sheet，然后在写入sheet时指定对应的WriteSheet即可，同时可指定每个Sheet对应的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/download6&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download6</span><span class="params">(HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="type">ExcelWriter</span> <span class="variable">excelWriter</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/vnd.ms-excel&quot;</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 这里URLEncoder.encode可以防止中文乱码 当然和easyexcel没有关系</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> URLEncoder.encode(<span class="string">&quot;测试&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>).replaceAll(<span class="string">&quot;\\+&quot;</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-disposition&quot;</span>, <span class="string">&quot;attachment;filename=&quot;</span> + fileName + <span class="string">&quot;.xls&quot;</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; heads = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        heads.add(Arrays.asList(<span class="string">&quot;姓名&quot;</span>));</span><br><span class="line">        heads.add(Arrays.asList(<span class="string">&quot;年龄&quot;</span>));</span><br><span class="line">        heads.add(Arrays.asList(<span class="string">&quot;地址&quot;</span>));</span><br><span class="line">        excelWriter = EasyExcel.write(response.getOutputStream()).head(heads).build();</span><br><span class="line"></span><br><span class="line">        <span class="type">WriteSheet</span> <span class="variable">writeSheet1</span> <span class="operator">=</span> EasyExcel.writerSheet(<span class="number">0</span>, <span class="string">&quot;测试1&quot;</span>).build();</span><br><span class="line">        <span class="type">WriteSheet</span> <span class="variable">writeSheet2</span> <span class="operator">=</span> EasyExcel.writerSheet(<span class="number">1</span>, <span class="string">&quot;测试2&quot;</span>).build();</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setUserId(<span class="number">123</span>);</span><br><span class="line">        user.setName(<span class="string">&quot;as&quot;</span>);</span><br><span class="line">        user.setPhone(<span class="string">&quot;15213&quot;</span>);</span><br><span class="line">        user.setEmail(<span class="string">&quot;5456&quot;</span>);</span><br><span class="line">        user.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        excelWriter.write(Arrays.asList(user), writeSheet1);</span><br><span class="line">        excelWriter.write(Arrays.asList(user), writeSheet2);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (excelWriter != <span class="literal">null</span>) &#123;</span><br><span class="line">            excelWriter.finish();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="4.png" alt=""></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Excel</tag>
        <tag>EasyExcel</tag>
      </tags>
  </entry>
  <entry>
    <title>Easyexcel（6-单元格合并）</title>
    <url>/blog/2024/11/03/Java/excel/easyexcel/Easyexcel%EF%BC%886-%E5%8D%95%E5%85%83%E6%A0%BC%E5%90%88%E5%B9%B6%EF%BC%89/</url>
    <content><![CDATA[<h2 id="注解">注解</h2>
<h3 id="ContentLoopMerge">@ContentLoopMerge</h3>
<p>用于设置合并单元格的注解，作用于字段上</p>
<ol>
<li>eachRow：每隔几行合并</li>
<li>columnExtend：合并列的下标</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ContentLoopMerge(eachRow = 2, columnExtend = 1)</span></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;用户Id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;姓名&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;手机&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;邮箱&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;创建时间&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="OnceAbsoluteMerge">@OnceAbsoluteMerge</h3>
<p>用于指定位置的单元格合并，作用于类上</p>
<ol>
<li>firstRowIndex：第一行下标</li>
<li>lastRowIndex：最后一行下标</li>
<li>firstColumnIndex：第一列下标</li>
<li>lastColumnIndex：最后一列下标</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@OnceAbsoluteMerge(firstColumnIndex = 0, lastColumnIndex = 0, firstRowIndex = 1, lastRowIndex = 2)</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;用户Id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;姓名&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;手机&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;邮箱&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;创建时间&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类方法">类方法</h2>
<h3 id="LoopMergeStrategy">LoopMergeStrategy</h3>
<h4 id="源码查看">源码查看</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoopMergeStrategy</span> <span class="keyword">implements</span> <span class="title class_">RowWriteHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每隔几行合并</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> eachRow;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并几列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> columnExtend;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> columnIndex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LoopMergeStrategy</span><span class="params">(<span class="type">int</span> eachRow, <span class="type">int</span> columnIndex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(eachRow, <span class="number">1</span>, columnIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LoopMergeStrategy</span><span class="params">(<span class="type">int</span> eachRow, <span class="type">int</span> columnExtend, <span class="type">int</span> columnIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (eachRow &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;EachRows must be greater than 1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (columnExtend &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;ColumnExtend must be greater than 1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (columnExtend == <span class="number">1</span> &amp;&amp; eachRow == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;ColumnExtend or eachRows must be greater than 1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (columnIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;ColumnIndex must be greater than 0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.eachRow = eachRow;</span><br><span class="line">        <span class="built_in">this</span>.columnExtend = columnExtend;</span><br><span class="line">        <span class="built_in">this</span>.columnIndex = columnIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LoopMergeStrategy</span><span class="params">(LoopMergeProperty loopMergeProperty, Integer columnIndex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(loopMergeProperty.getEachRow(), loopMergeProperty.getColumnExtend(), columnIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterRowDispose</span><span class="params">(RowWriteHandlerContext context)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否为表头</span></span><br><span class="line">        <span class="keyword">if</span> (context.getHead() || context.getRelativeRowIndex() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 循环进行单元格合并</span></span><br><span class="line">        <span class="keyword">if</span> (context.getRelativeRowIndex() % eachRow == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">CellRangeAddress</span> <span class="variable">cellRangeAddress</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CellRangeAddress</span>(context.getRowIndex(),</span><br><span class="line">                context.getRowIndex() + eachRow - <span class="number">1</span>,</span><br><span class="line">                columnIndex, columnIndex + columnExtend - <span class="number">1</span>);</span><br><span class="line">            context.getWriteSheetHolder().getSheet().addMergedRegionUnsafe(cellRangeAddress);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="基本使用">基本使用</h4>
<p>通过 registerWriteHandler 方法设置单元格合并策略，用于指定某几列每相差几行进行单元格合并</p>
<ol>
<li>指定单列合并</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/download1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download1</span><span class="params">(HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/vnd.ms-excel&quot;</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 这里URLEncoder.encode可以防止中文乱码 当然和easyexcel没有关系</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> URLEncoder.encode(<span class="string">&quot;测试&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>).replaceAll(<span class="string">&quot;\\+&quot;</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-disposition&quot;</span>, <span class="string">&quot;attachment;filename=&quot;</span> + fileName + <span class="string">&quot;.xls&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user1.setUserId(<span class="number">123</span>);</span><br><span class="line">        user1.setName(<span class="string">&quot;as&quot;</span>);</span><br><span class="line">        user1.setPhone(<span class="string">&quot;15213&quot;</span>);</span><br><span class="line">        user1.setEmail(<span class="string">&quot;5456&quot;</span>);</span><br><span class="line">        user1.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user2.setUserId(<span class="number">123</span>);</span><br><span class="line">        user2.setName(<span class="string">&quot;asbnm&quot;</span>);</span><br><span class="line">        user2.setPhone(<span class="string">&quot;15213&quot;</span>);</span><br><span class="line">        user2.setEmail(<span class="string">&quot;5456&quot;</span>);</span><br><span class="line">        user2.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user3.setUserId(<span class="number">123</span>);</span><br><span class="line">        user3.setName(<span class="string">&quot;as&quot;</span>);</span><br><span class="line">        user3.setPhone(<span class="string">&quot;46543213&quot;</span>);</span><br><span class="line">        user3.setEmail(<span class="string">&quot;5456&quot;</span>);</span><br><span class="line">        user3.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第1列每隔2行合并一次</span></span><br><span class="line">        <span class="type">LoopMergeStrategy</span> <span class="variable">loopMergeStrategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoopMergeStrategy</span>(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        EasyExcel.write(response.getOutputStream(), User.class)</span><br><span class="line">                .registerWriteHandler(loopMergeStrategy)</span><br><span class="line">                .sheet(<span class="string">&quot;模板&quot;</span>)</span><br><span class="line">                .doWrite(Arrays.asList(user1, user2, user3));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="1.png" alt=""></p>
<ol start="2">
<li>指定多列合并</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/download1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download1</span><span class="params">(HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/vnd.ms-excel&quot;</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 这里URLEncoder.encode可以防止中文乱码 当然和easyexcel没有关系</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> URLEncoder.encode(<span class="string">&quot;测试&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>).replaceAll(<span class="string">&quot;\\+&quot;</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-disposition&quot;</span>, <span class="string">&quot;attachment;filename=&quot;</span> + fileName + <span class="string">&quot;.xls&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user1.setUserId(<span class="number">123</span>);</span><br><span class="line">        user1.setName(<span class="string">&quot;as&quot;</span>);</span><br><span class="line">        user1.setPhone(<span class="string">&quot;15213&quot;</span>);</span><br><span class="line">        user1.setEmail(<span class="string">&quot;5456&quot;</span>);</span><br><span class="line">        user1.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user2.setUserId(<span class="number">123</span>);</span><br><span class="line">        user2.setName(<span class="string">&quot;asbnm&quot;</span>);</span><br><span class="line">        user2.setPhone(<span class="string">&quot;15213&quot;</span>);</span><br><span class="line">        user2.setEmail(<span class="string">&quot;5456&quot;</span>);</span><br><span class="line">        user2.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user3.setUserId(<span class="number">123</span>);</span><br><span class="line">        user3.setName(<span class="string">&quot;as&quot;</span>);</span><br><span class="line">        user3.setPhone(<span class="string">&quot;46543213&quot;</span>);</span><br><span class="line">        user3.setEmail(<span class="string">&quot;5456&quot;</span>);</span><br><span class="line">        user3.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="comment">// 第2列开始每隔2行合并一次，从第2列开始的两列进行合并</span></span><br><span class="line">        <span class="type">LoopMergeStrategy</span> <span class="variable">loopMergeStrategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoopMergeStrategy</span>(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        EasyExcel.write(response.getOutputStream(), User.class)</span><br><span class="line">                .registerWriteHandler(loopMergeStrategy)</span><br><span class="line">                .sheet(<span class="string">&quot;模板&quot;</span>)</span><br><span class="line">                .doWrite(Arrays.asList(user1, user2, user3));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="2.png" alt=""></p>
<h3 id="OnceAbsoluteMergeStrategy">OnceAbsoluteMergeStrategy</h3>
<h4 id="源码查看-2">源码查看</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OnceAbsoluteMergeStrategy</span> <span class="keyword">implements</span> <span class="title class_">SheetWriteHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> firstRowIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后一行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> lastRowIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> firstColumnIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后一列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> lastColumnIndex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OnceAbsoluteMergeStrategy</span><span class="params">(<span class="type">int</span> firstRowIndex, <span class="type">int</span> lastRowIndex, <span class="type">int</span> firstColumnIndex, <span class="type">int</span> lastColumnIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (firstRowIndex &lt; <span class="number">0</span> || lastRowIndex &lt; <span class="number">0</span> || firstColumnIndex &lt; <span class="number">0</span> || lastColumnIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;All parameters must be greater than 0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.firstRowIndex = firstRowIndex;</span><br><span class="line">        <span class="built_in">this</span>.lastRowIndex = lastRowIndex;</span><br><span class="line">        <span class="built_in">this</span>.firstColumnIndex = firstColumnIndex;</span><br><span class="line">        <span class="built_in">this</span>.lastColumnIndex = lastColumnIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OnceAbsoluteMergeStrategy</span><span class="params">(OnceAbsoluteMergeProperty onceAbsoluteMergeProperty)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(onceAbsoluteMergeProperty.getFirstRowIndex(), onceAbsoluteMergeProperty.getLastRowIndex(),</span><br><span class="line">            onceAbsoluteMergeProperty.getFirstColumnIndex(), onceAbsoluteMergeProperty.getLastColumnIndex());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterSheetCreate</span><span class="params">(WriteWorkbookHolder writeWorkbookHolder, WriteSheetHolder writeSheetHolder)</span> &#123;</span><br><span class="line">        <span class="type">CellRangeAddress</span> <span class="variable">cellRangeAddress</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">CellRangeAddress</span>(firstRowIndex, lastRowIndex, firstColumnIndex, lastColumnIndex);</span><br><span class="line">        writeSheetHolder.getSheet().addMergedRegionUnsafe(cellRangeAddress);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="基本使用-2">基本使用</h4>
<p>通过 registerWriteHandler 方法设置单元格合并策略，用于指定一个区域内的单元格进行合并</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/download2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download2</span><span class="params">(HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/vnd.ms-excel&quot;</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 这里URLEncoder.encode可以防止中文乱码 当然和easyexcel没有关系</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> URLEncoder.encode(<span class="string">&quot;测试&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>).replaceAll(<span class="string">&quot;\\+&quot;</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-disposition&quot;</span>, <span class="string">&quot;attachment;filename=&quot;</span> + fileName + <span class="string">&quot;.xls&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user1.setUserId(<span class="number">123</span>);</span><br><span class="line">        user1.setName(<span class="string">&quot;as&quot;</span>);</span><br><span class="line">        user1.setPhone(<span class="string">&quot;15213&quot;</span>);</span><br><span class="line">        user1.setEmail(<span class="string">&quot;5456&quot;</span>);</span><br><span class="line">        user1.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user2.setUserId(<span class="number">123</span>);</span><br><span class="line">        user2.setName(<span class="string">&quot;asbnm&quot;</span>);</span><br><span class="line">        user2.setPhone(<span class="string">&quot;15213&quot;</span>);</span><br><span class="line">        user2.setEmail(<span class="string">&quot;5456&quot;</span>);</span><br><span class="line">        user2.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user3.setUserId(<span class="number">123</span>);</span><br><span class="line">        user3.setName(<span class="string">&quot;as&quot;</span>);</span><br><span class="line">        user3.setPhone(<span class="string">&quot;46543213&quot;</span>);</span><br><span class="line">        user3.setEmail(<span class="string">&quot;5456&quot;</span>);</span><br><span class="line">        user3.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="comment">// 从第1行第3列合并到第3行第3列</span></span><br><span class="line">        <span class="type">OnceAbsoluteMergeStrategy</span> <span class="variable">onceAbsoluteMergeStrategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OnceAbsoluteMergeStrategy</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        EasyExcel.write(response.getOutputStream(), User.class)</span><br><span class="line">                .registerWriteHandler(onceAbsoluteMergeStrategy)</span><br><span class="line">                .sheet(<span class="string">&quot;模板&quot;</span>)</span><br><span class="line">                .doWrite(Arrays.asList(user1, user2, user3));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="3.png" alt=""></p>
<h2 id="合并单元格工具类">合并单元格工具类</h2>
<h3 id="AbstractMergeStrategy">AbstractMergeStrategy</h3>
<h4 id="基本思路">基本思路</h4>
<ol>
<li>继承 AbstractMergeStrategy 抽象合并策略，重写 merge 方法</li>
<li>传入要合并的数据列表，循环判断上下行是否是相同的数据，如果是则为同一个组，否则为另一个组，使用 List 保存每个组的数量</li>
<li>单元格渲染时，循环遍历每个组的值后，计算要合并的单元格的上下标</li>
</ol>
<h4 id="使用">使用</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义合并策略 该类继承了AbstractMergeStrategy抽象合并策略，需要重写merge()方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomMergeStrategy</span> <span class="keyword">extends</span> <span class="title class_">AbstractMergeStrategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分组，每几行合并一次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; exportFieldGroupCountList;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 目标合并列index</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer targetColumnIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要开始合并单元格的首行index</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer rowIndex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomMergeStrategy</span><span class="params">(List&lt;String&gt; exportDataList, Integer targetColumnIndex, Integer rowIndex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.exportFieldGroupCountList = getGroupCountList(exportDataList, rowIndex);</span><br><span class="line">        <span class="built_in">this</span>.targetColumnIndex = targetColumnIndex;</span><br><span class="line">        <span class="built_in">this</span>.rowIndex = rowIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该方法将目标列根据值是否相同连续可合并，存储可合并的行数</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; <span class="title function_">getGroupCountList</span><span class="params">(List&lt;String&gt; exportDataList, Integer rowIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(exportDataList)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; groupCountList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> rowIndex + <span class="number">1</span>, len = exportDataList.size(); i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 判断上一列和当前列的值是否相同</span></span><br><span class="line">            <span class="keyword">if</span> (exportDataList.get(i).equals(exportDataList.get(i - <span class="number">1</span>))) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                groupCountList.add(count);</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理完最后一条后</span></span><br><span class="line">        groupCountList.add(count);</span><br><span class="line">        <span class="keyword">return</span> groupCountList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(Sheet sheet, Cell cell, Head head, Integer relativeRowIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == rowIndex) &#123;</span><br><span class="line">            rowIndex = cell.getRowIndex();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 仅从首行以及目标列的单元格开始合并，忽略其他</span></span><br><span class="line">        <span class="keyword">if</span> (cell.getRowIndex() == rowIndex + <span class="number">1</span> &amp;&amp; cell.getColumnIndex() == targetColumnIndex) &#123;</span><br><span class="line">            mergeGroupColumn(sheet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mergeGroupColumn</span><span class="params">(Sheet sheet)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rowCount</span> <span class="operator">=</span> rowIndex + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer count : exportFieldGroupCountList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">                rowCount += count;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 合并单元格</span></span><br><span class="line">            <span class="type">CellRangeAddress</span> <span class="variable">cellRangeAddress</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CellRangeAddress</span>(rowCount, rowCount + count - <span class="number">1</span>, targetColumnIndex, targetColumnIndex);</span><br><span class="line">            sheet.addMergedRegionUnsafe(cellRangeAddress);</span><br><span class="line">            rowCount += count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>从首行开始合并单元格</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/download3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download3</span><span class="params">(HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/vnd.ms-excel&quot;</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 这里URLEncoder.encode可以防止中文乱码 当然和easyexcel没有关系</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> URLEncoder.encode(<span class="string">&quot;测试&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>).replaceAll(<span class="string">&quot;\\+&quot;</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-disposition&quot;</span>, <span class="string">&quot;attachment;filename=&quot;</span> + fileName + <span class="string">&quot;.xls&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user1.setUserId(<span class="number">123</span>);</span><br><span class="line">        user1.setName(<span class="string">&quot;as&quot;</span>);</span><br><span class="line">        user1.setPhone(<span class="string">&quot;15213&quot;</span>);</span><br><span class="line">        user1.setEmail(<span class="string">&quot;5456&quot;</span>);</span><br><span class="line">        user1.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user2.setUserId(<span class="number">123</span>);</span><br><span class="line">        user2.setName(<span class="string">&quot;asbnm&quot;</span>);</span><br><span class="line">        user2.setPhone(<span class="string">&quot;15213&quot;</span>);</span><br><span class="line">        user2.setEmail(<span class="string">&quot;5456&quot;</span>);</span><br><span class="line">        user2.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user3.setUserId(<span class="number">123</span>);</span><br><span class="line">        user3.setName(<span class="string">&quot;as&quot;</span>);</span><br><span class="line">        user3.setPhone(<span class="string">&quot;46543213&quot;</span>);</span><br><span class="line">        user3.setEmail(<span class="string">&quot;5456&quot;</span>);</span><br><span class="line">        user3.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; userList = Arrays.asList(user1, user2, user3);</span><br><span class="line">        <span class="type">CustomMergeStrategy</span> <span class="variable">customMergeStrategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomMergeStrategy</span>(userList.stream().map(e -&gt;</span><br><span class="line">                String.valueOf(e.getUserId())).collect(Collectors.toList()), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        EasyExcel.write(response.getOutputStream(), User.class)</span><br><span class="line">                .registerWriteHandler(customMergeStrategy)</span><br><span class="line">                .sheet(<span class="string">&quot;模板&quot;</span>)</span><br><span class="line">                .doWrite(userList);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="4.png" alt=""></p>
<ol start="2">
<li>从指定行开始合并单元格</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/download3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download3</span><span class="params">(HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/vnd.ms-excel&quot;</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 这里URLEncoder.encode可以防止中文乱码 当然和easyexcel没有关系</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> URLEncoder.encode(<span class="string">&quot;测试&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>).replaceAll(<span class="string">&quot;\\+&quot;</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-disposition&quot;</span>, <span class="string">&quot;attachment;filename=&quot;</span> + fileName + <span class="string">&quot;.xls&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user1.setUserId(<span class="number">123</span>);</span><br><span class="line">        user1.setName(<span class="string">&quot;as&quot;</span>);</span><br><span class="line">        user1.setPhone(<span class="string">&quot;15213&quot;</span>);</span><br><span class="line">        user1.setEmail(<span class="string">&quot;5456&quot;</span>);</span><br><span class="line">        user1.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user2.setUserId(<span class="number">123</span>);</span><br><span class="line">        user2.setName(<span class="string">&quot;asbnm&quot;</span>);</span><br><span class="line">        user2.setPhone(<span class="string">&quot;15213&quot;</span>);</span><br><span class="line">        user2.setEmail(<span class="string">&quot;5456&quot;</span>);</span><br><span class="line">        user2.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user3.setUserId(<span class="number">123</span>);</span><br><span class="line">        user3.setName(<span class="string">&quot;as&quot;</span>);</span><br><span class="line">        user3.setPhone(<span class="string">&quot;46543213&quot;</span>);</span><br><span class="line">        user3.setEmail(<span class="string">&quot;5456&quot;</span>);</span><br><span class="line">        user3.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; userList = Arrays.asList(user1, user2, user3);</span><br><span class="line">        <span class="type">CustomMergeStrategy</span> <span class="variable">customMergeStrategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomMergeStrategy</span>(userList.stream().map(e -&gt;</span><br><span class="line">                String.valueOf(e.getUserId())).collect(Collectors.toList()), <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        EasyExcel.write(response.getOutputStream(), User.class)</span><br><span class="line">                .registerWriteHandler(customMergeStrategy)</span><br><span class="line">                .sheet(<span class="string">&quot;模板&quot;</span>)</span><br><span class="line">                .doWrite(userList);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="5.png" alt=""></p>
<h3 id="CellWriteHandler">CellWriteHandler</h3>
<h4 id="基本思路-2">基本思路</h4>
<ol>
<li>实现 CellWriteHandler 类的 afterCellDispose 方法，在每个单元格完全创建完之后执行合并单元格操作</li>
<li>判断当前列是否为要合并的列，且当前行是否已经到达要操作的行数</li>
<li>如果是，则判断上一行和当前行的数据是否一致，且序号是否一致</li>
<li>如果是，则进行合并单元格操作，如果上一行已经被合并过了，则进行移除，然后再重新合并单元格</li>
</ol>
<h4 id="使用-2">使用</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * excel合并单元格导出工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EasyExcelUtil</span> <span class="keyword">implements</span> <span class="title class_">CellWriteHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要合并的列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] mergeColumnIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从哪一行开始合并</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mergeRowIndex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EasyExcelUtil</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EasyExcelUtil</span><span class="params">(<span class="type">int</span> mergeRowIndex, <span class="type">int</span>[] mergeColumnIndex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mergeRowIndex = mergeRowIndex;</span><br><span class="line">        <span class="built_in">this</span>.mergeColumnIndex = mergeColumnIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建每个单元格之前执行</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> writeSheetHolder</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> writeTableHolder</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> row</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> columnIndex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> relativeRowIndex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> isHead</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeCellCreate</span><span class="params">(WriteSheetHolder writeSheetHolder, WriteTableHolder writeTableHolder, Row row,</span></span><br><span class="line"><span class="params">                                 Head head, Integer columnIndex, Integer relativeRowIndex, Boolean isHead)</span> &#123;</span><br><span class="line">        CellWriteHandler.<span class="built_in">super</span>.beforeCellCreate(writeSheetHolder, writeTableHolder, row, head, columnIndex, relativeRowIndex, isHead);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每个单元格数据内容渲染之后执行</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> writeSheetHolder</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> writeTableHolder</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cellData</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cell</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> relativeRowIndex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> isHead</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCellDataConverted</span><span class="params">(WriteSheetHolder writeSheetHolder, WriteTableHolder writeTableHolder, WriteCellData&lt;?&gt; cellData,</span></span><br><span class="line"><span class="params">                                       Cell cell, Head head, Integer relativeRowIndex, Boolean isHead)</span> &#123;</span><br><span class="line">        CellWriteHandler.<span class="built_in">super</span>.afterCellDataConverted(writeSheetHolder, writeTableHolder, cellData, cell, head, relativeRowIndex, isHead);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每个单元格完全创建完之后执行</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> writeSheetHolder</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> writeTableHolder</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cellDataList</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cell</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> relativeRowIndex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> isHead</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCellDispose</span><span class="params">(WriteSheetHolder writeSheetHolder, WriteTableHolder writeTableHolder, List&lt;WriteCellData&lt;?&gt;&gt; cellDataList,</span></span><br><span class="line"><span class="params">                                 Cell cell, Head head, Integer relativeRowIndex, Boolean isHead)</span> &#123;</span><br><span class="line">        <span class="comment">//当前行</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">curRowIndex</span> <span class="operator">=</span> cell.getRowIndex();</span><br><span class="line">        <span class="comment">//当前列</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">curColIndex</span> <span class="operator">=</span> cell.getColumnIndex();</span><br><span class="line">        <span class="comment">//判断当前行是否已经到达要合并的行数</span></span><br><span class="line">        <span class="keyword">if</span> (curRowIndex &gt; mergeRowIndex) &#123;</span><br><span class="line">            <span class="comment">//判断是否是合并列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> columnIndex : mergeColumnIndex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (curColIndex == columnIndex) &#123;</span><br><span class="line">                    mergeWithPrevRow(writeSheetHolder, cell, curRowIndex, curColIndex);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前单元格向上合并</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> writeSheetHolder</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cell             当前单元格</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> curRowIndex      当前行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> curColIndex      当前列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mergeWithPrevRow</span><span class="params">(WriteSheetHolder writeSheetHolder, Cell cell, <span class="type">int</span> curRowIndex, <span class="type">int</span> curColIndex)</span> &#123;</span><br><span class="line">        <span class="type">Cell</span> <span class="variable">cell1</span> <span class="operator">=</span> cell.getSheet().getRow(curRowIndex).getCell(<span class="number">0</span>);</span><br><span class="line">        <span class="type">Cell</span> <span class="variable">cell2</span> <span class="operator">=</span> cell.getSheet().getRow(curRowIndex - <span class="number">1</span>).getCell(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (cell1 == <span class="literal">null</span> || cell2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取当前单元格的数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">curData</span> <span class="operator">=</span> cell.getCellType() == CellType.STRING ? cell.getStringCellValue() : cell.getNumericCellValue();</span><br><span class="line">        <span class="comment">// 获取上一行单元格的数据</span></span><br><span class="line">        <span class="type">Cell</span> <span class="variable">preCell</span> <span class="operator">=</span> cell.getSheet().getRow(curRowIndex - <span class="number">1</span>).getCell(curColIndex);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">preData</span> <span class="operator">=</span> preCell.getCellType() == CellType.STRING ? preCell.getStringCellValue() : preCell.getNumericCellValue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将当前单元格数据与上一个单元格数据比较，然后判断其序号是否相同</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">dataBool</span> <span class="operator">=</span> preData.equals(curData);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">val1</span> <span class="operator">=</span> cell1.getCellType() == CellType.STRING ? cell1.getStringCellValue() : cell1.getNumericCellValue();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">val2</span> <span class="operator">=</span> cell2.getCellType() == CellType.STRING ? cell2.getStringCellValue() : cell2.getNumericCellValue();</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">bool</span> <span class="operator">=</span> Objects.equals(val1, val2);</span><br><span class="line">        <span class="keyword">if</span> (dataBool &amp;&amp; bool) &#123;</span><br><span class="line">            <span class="type">Sheet</span> <span class="variable">sheet</span> <span class="operator">=</span> writeSheetHolder.getSheet();</span><br><span class="line">            List&lt;CellRangeAddress&gt; mergeRegions = sheet.getMergedRegions();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isMerged</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, len = mergeRegions.size(); i &lt; len &amp;&amp; !isMerged; ++i) &#123;</span><br><span class="line">                <span class="type">CellRangeAddress</span> <span class="variable">cellRangeAddr</span> <span class="operator">=</span> mergeRegions.get(i);</span><br><span class="line">                <span class="comment">// 若上一个单元格已经被合并，则先移出原有的合并单元，再重新添加合并单元</span></span><br><span class="line">                <span class="keyword">if</span> (cellRangeAddr.isInRange(curRowIndex - <span class="number">1</span>, curColIndex)) &#123;</span><br><span class="line">                    sheet.removeMergedRegion(i);</span><br><span class="line">                    cellRangeAddr.setLastRow(curRowIndex);</span><br><span class="line">                    sheet.addMergedRegion(cellRangeAddr);</span><br><span class="line">                    isMerged = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 若上一个单元格未被合并，则新增合并单元</span></span><br><span class="line">            <span class="keyword">if</span> (!isMerged) &#123;</span><br><span class="line">                <span class="type">CellRangeAddress</span> <span class="variable">cellRangeAddress</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CellRangeAddress</span>(curRowIndex - <span class="number">1</span>, curRowIndex, curColIndex, curColIndex);</span><br><span class="line">                sheet.addMergedRegion(cellRangeAddress);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/download4&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download4</span><span class="params">(HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/vnd.ms-excel&quot;</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 这里URLEncoder.encode可以防止中文乱码 当然和easyexcel没有关系</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> URLEncoder.encode(<span class="string">&quot;测试&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>).replaceAll(<span class="string">&quot;\\+&quot;</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-disposition&quot;</span>, <span class="string">&quot;attachment;filename=&quot;</span> + fileName + <span class="string">&quot;.xls&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user1.setUserId(<span class="number">123</span>);</span><br><span class="line">        user1.setName(<span class="string">&quot;as&quot;</span>);</span><br><span class="line">        user1.setPhone(<span class="string">&quot;15213&quot;</span>);</span><br><span class="line">        user1.setEmail(<span class="string">&quot;5456&quot;</span>);</span><br><span class="line">        user1.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user2.setUserId(<span class="number">123</span>);</span><br><span class="line">        user2.setName(<span class="string">&quot;asbnm&quot;</span>);</span><br><span class="line">        user2.setPhone(<span class="string">&quot;15213&quot;</span>);</span><br><span class="line">        user2.setEmail(<span class="string">&quot;5456&quot;</span>);</span><br><span class="line">        user2.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user3.setUserId(<span class="number">123</span>);</span><br><span class="line">        user3.setName(<span class="string">&quot;as&quot;</span>);</span><br><span class="line">        user3.setPhone(<span class="string">&quot;46543213&quot;</span>);</span><br><span class="line">        user3.setEmail(<span class="string">&quot;5456&quot;</span>);</span><br><span class="line">        user3.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; userList = Arrays.asList(user1, user2, user3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//            EasyExcel.write(response.getOutputStream(), User.class)</span></span><br><span class="line"><span class="comment">//                    .registerWriteHandler(new EasyExcelUtil(0, new int[]&#123;0, 2&#125;))</span></span><br><span class="line"><span class="comment">//                    .sheet(&quot;模板&quot;)</span></span><br><span class="line"><span class="comment">//                    .doWrite(userList);</span></span><br><span class="line">        EasyExcel.write(response.getOutputStream(), User.class)</span><br><span class="line">                .registerWriteHandler(<span class="keyword">new</span> <span class="title class_">EasyExcelUtil</span>(<span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>&#125;))</span><br><span class="line">                .registerWriteHandler(<span class="keyword">new</span> <span class="title class_">EasyExcelUtil</span>(<span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">2</span>&#125;))</span><br><span class="line">                .sheet(<span class="string">&quot;模板&quot;</span>)</span><br><span class="line">                .doWrite(userList);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="6.png" alt=""></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Excel</tag>
        <tag>EasyExcel</tag>
      </tags>
  </entry>
  <entry>
    <title>Easyexcel（5-自定义列宽）</title>
    <url>/blog/2024/11/02/Java/excel/easyexcel/Easyexcel%EF%BC%885-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%97%E5%AE%BD%EF%BC%89/</url>
    <content><![CDATA[<h2 id="注解">注解</h2>
<h3 id="ColumnWidth">@ColumnWidth</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WidthAndHeightData</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;字符串标题&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String string;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;日期标题&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ColumnWidth(50)</span></span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;数字标题&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Double doubleData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注解使用时表头长度无法做到动态调整，只能固定设置，每次调整表头长度时只能重新修改代码</p>
<p>注意：@ColumnWidth最大值只能为255，超过255*256长度时会报错</p>
<p><strong>查看XSSFSheet源码</strong></p>
<p><img src="5.png" alt=""></p>
<h2 id="类方法">类方法</h2>
<p><img src="6.png" alt=""></p>
<h3 id="AbstractHeadColumnWidthStyleStrategy">AbstractHeadColumnWidthStyleStrategy</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractHeadColumnWidthStyleStrategy</span> <span class="keyword">extends</span> <span class="title class_">AbstractColumnWidthStyleStrategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setColumnWidth</span><span class="params">(WriteSheetHolder writeSheetHolder, List&lt;WriteCellData&lt;?&gt;&gt; cellDataList, Cell cell, Head head,</span></span><br><span class="line"><span class="params">        Integer relativeRowIndex, Boolean isHead)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否满足 当前行索引不为空 &amp;&amp; （当前是表头 || 当前行索引是首行）</span></span><br><span class="line">        <span class="comment">// 如果不满足，则说明不是表头，不需要设置</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">needSetWidth</span> <span class="operator">=</span> relativeRowIndex != <span class="literal">null</span> &amp;&amp; (isHead || relativeRowIndex == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (!needSetWidth) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">width</span> <span class="operator">=</span> columnWidth(head, cell.getColumnIndex());</span><br><span class="line">        <span class="keyword">if</span> (width != <span class="literal">null</span>) &#123;</span><br><span class="line">            width = width * <span class="number">256</span>;</span><br><span class="line">            writeSheetHolder.getSheet().setColumnWidth(cell.getColumnIndex(), width);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> Integer <span class="title function_">columnWidth</span><span class="params">(Head head, Integer columnIndex)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过继承AbstractHeadColumnWidthStyleStrategy类，实现columnWidth方法获取其对应列的宽度</p>
<h3 id="SimpleColumnWidthStyleStrategy">SimpleColumnWidthStyleStrategy</h3>
<h4 id="源码查看">源码查看</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleColumnWidthStyleStrategy</span> <span class="keyword">extends</span> <span class="title class_">AbstractHeadColumnWidthStyleStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer columnWidth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleColumnWidthStyleStrategy</span><span class="params">(Integer columnWidth)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.columnWidth = columnWidth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">columnWidth</span><span class="params">(Head head, Integer columnIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> columnWidth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="基本使用">基本使用</h4>
<p>通过registerWriteHandler设置策略方法调整每列的固定宽度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;用户Id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;姓名&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;手机&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;邮箱&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;创建时间&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/download2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download2</span><span class="params">(HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/vnd.ms-excel&quot;</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 这里URLEncoder.encode可以防止中文乱码 当然和easyexcel没有关系</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> URLEncoder.encode(<span class="string">&quot;测试&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>).replaceAll(<span class="string">&quot;\\+&quot;</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-disposition&quot;</span>, <span class="string">&quot;attachment;filename=&quot;</span> + fileName + <span class="string">&quot;.xls&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setUserId(<span class="number">123</span>);</span><br><span class="line">        user.setName(<span class="string">&quot;asplplplplpplplplplpl&quot;</span>);</span><br><span class="line">        user.setPhone(<span class="string">&quot;15245413&quot;</span>);</span><br><span class="line">        user.setEmail(<span class="string">&quot;54565454@qq.com&quot;</span>);</span><br><span class="line">        user.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        EasyExcel.write(response.getOutputStream(), User.class)</span><br><span class="line">                .sheet(<span class="string">&quot;模板&quot;</span>)</span><br><span class="line">                .registerWriteHandler(<span class="keyword">new</span> <span class="title class_">SimpleColumnWidthStyleStrategy</span>(<span class="number">20</span>))</span><br><span class="line">                .doWrite(Arrays.asList(user));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="1.png" alt=""></p>
<h3 id="LongestMatchColumnWidthStyleStrategy">LongestMatchColumnWidthStyleStrategy</h3>
<h4 id="源码查看-2">源码查看</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongestMatchColumnWidthStyleStrategy</span> <span class="keyword">extends</span> <span class="title class_">AbstractColumnWidthStyleStrategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_COLUMN_WIDTH</span> <span class="operator">=</span> <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; cache = MapUtils.newHashMapWithExpectedSize(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setColumnWidth</span><span class="params">(WriteSheetHolder writeSheetHolder, List&lt;WriteCellData&lt;?&gt;&gt; cellDataList, Cell cell,</span></span><br><span class="line"><span class="params">        Head head,</span></span><br><span class="line"><span class="params">        Integer relativeRowIndex, Boolean isHead)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断 是否为表头 || 导出内容是否为空</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">needSetWidth</span> <span class="operator">=</span> isHead || !CollectionUtils.isEmpty(cellDataList);</span><br><span class="line">        <span class="keyword">if</span> (!needSetWidth) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, Integer&gt; maxColumnWidthMap = cache.computeIfAbsent(writeSheetHolder.getSheetNo(), key -&gt; <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>));</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">columnWidth</span> <span class="operator">=</span> dataLength(cellDataList, cell, isHead);</span><br><span class="line">        <span class="keyword">if</span> (columnWidth &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 超过最大值255时则设置为255</span></span><br><span class="line">        <span class="keyword">if</span> (columnWidth &gt; MAX_COLUMN_WIDTH) &#123;</span><br><span class="line">            columnWidth = MAX_COLUMN_WIDTH;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 比较该列的宽度，如果比原来的宽度大，则重新设置</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">maxColumnWidth</span> <span class="operator">=</span> maxColumnWidthMap.get(cell.getColumnIndex());</span><br><span class="line">        <span class="keyword">if</span> (maxColumnWidth == <span class="literal">null</span> || columnWidth &gt; maxColumnWidth) &#123;</span><br><span class="line">            maxColumnWidthMap.put(cell.getColumnIndex(), columnWidth);</span><br><span class="line">            writeSheetHolder.getSheet().setColumnWidth(cell.getColumnIndex(), columnWidth * <span class="number">256</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer <span class="title function_">dataLength</span><span class="params">(List&lt;WriteCellData&lt;?&gt;&gt; cellDataList, Cell cell, Boolean isHead)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是表头，则返回表头的宽度</span></span><br><span class="line">        <span class="keyword">if</span> (isHead) &#123;</span><br><span class="line">            <span class="keyword">return</span> cell.getStringCellValue().getBytes().length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是单元格内容，则根据类型返回其内容的宽度</span></span><br><span class="line">        WriteCellData&lt;?&gt; cellData = cellDataList.get(<span class="number">0</span>);</span><br><span class="line">        <span class="type">CellDataTypeEnum</span> <span class="variable">type</span> <span class="operator">=</span> cellData.getType();</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> STRING:</span><br><span class="line">                <span class="keyword">return</span> cellData.getStringValue().getBytes().length;</span><br><span class="line">            <span class="keyword">case</span> BOOLEAN:</span><br><span class="line">                <span class="keyword">return</span> cellData.getBooleanValue().toString().getBytes().length;</span><br><span class="line">            <span class="keyword">case</span> NUMBER:</span><br><span class="line">                <span class="keyword">return</span> cellData.getNumberValue().toString().getBytes().length;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LongestMatchColumnWidthStyleStrategy是一个列宽自适应策略。当我们在写入Excel数据时，如果希望根据数据的实际长度来自适应调整列宽，就可以使用这个策略。它会遍历指定列的所有数据（包括表头），找出最长的数据，然后根据这个最长数据的长度来设定该列的宽度，确保数据在单元格内不会被截断。</p>
<p>根据官网介绍：这个目前不是很好用，比如有数字就会导致换行。而且长度也不是刚好和实际长度一致。 所以需要精确到刚好列宽的慎用。</p>
<h4 id="基本使用-2">基本使用</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/download1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download1</span><span class="params">(HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/vnd.ms-excel&quot;</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 这里URLEncoder.encode可以防止中文乱码 当然和easyexcel没有关系</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> URLEncoder.encode(<span class="string">&quot;测试&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>).replaceAll(<span class="string">&quot;\\+&quot;</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-disposition&quot;</span>, <span class="string">&quot;attachment;filename=&quot;</span> + fileName + <span class="string">&quot;.xls&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setUserId(<span class="number">123</span>);</span><br><span class="line">        user.setName(<span class="string">&quot;asplplplplpplplplplpl&quot;</span>);</span><br><span class="line">        user.setPhone(<span class="string">&quot;15245413&quot;</span>);</span><br><span class="line">        user.setEmail(<span class="string">&quot;54565454@qq.com&quot;</span>);</span><br><span class="line">        user.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        EasyExcel.write(response.getOutputStream(), User.class)</span><br><span class="line">                .sheet(<span class="string">&quot;模板&quot;</span>)</span><br><span class="line">                .registerWriteHandler(<span class="keyword">new</span> <span class="title class_">LongestMatchColumnWidthStyleStrategy</span>())</span><br><span class="line">                .doWrite(Arrays.asList(user));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="2.png" alt=""></p>
<h2 id="表头宽度工具类">表头宽度工具类</h2>
<p>仿照LongestMatchColumnWidthStyleStrategy源码自定义工具类</p>
<p>使用构造器传参的方式，用户可以自定义通过表头或者单元格内容长度来设置列宽，通过修改常数值和比例可以自己设置想调整的列宽</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表头宽度根据表头或数据内容自适应</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomWidthStyleStrategy</span> <span class="keyword">extends</span> <span class="title class_">AbstractColumnWidthStyleStrategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1-根据表头宽度，2-根据单元格内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomWidthStyleStrategy</span><span class="params">(Integer type)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置列宽</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> writeSheetHolder 写入Sheet的持有者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cellDataList 当前列的单元格数据列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cell 当前单元格</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head 表头</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> relativeRowIndex 当前行的相对索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> isHead 是否为表头</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setColumnWidth</span><span class="params">(WriteSheetHolder writeSheetHolder, List&lt;WriteCellData&lt;?&gt;&gt; cellDataList, Cell cell, Head head, Integer relativeRowIndex, Boolean isHead)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isHead) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">columnWidth</span> <span class="operator">=</span> cell.getStringCellValue().length();</span><br><span class="line">                columnWidth = Math.max(columnWidth * <span class="number">2</span>, <span class="number">20</span>);</span><br><span class="line">                <span class="keyword">if</span> (columnWidth &gt; <span class="number">255</span>) &#123;</span><br><span class="line">                    columnWidth = <span class="number">255</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                writeSheetHolder.getSheet().setColumnWidth(cell.getColumnIndex(), columnWidth * <span class="number">256</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不把标头计算在内</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">needSetWidth</span> <span class="operator">=</span> isHead || !CollectionUtils.isEmpty(cellDataList);</span><br><span class="line">        <span class="keyword">if</span> (needSetWidth) &#123;</span><br><span class="line">            Map&lt;Integer, Integer&gt; maxColumnWidthMap = cache.get(writeSheetHolder.getSheetNo());</span><br><span class="line">            <span class="keyword">if</span> (maxColumnWidthMap == <span class="literal">null</span>) &#123;</span><br><span class="line">                maxColumnWidthMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">                cache.put(writeSheetHolder.getSheetNo(), maxColumnWidthMap);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">columnWidth</span> <span class="operator">=</span> <span class="built_in">this</span>.dataLength(cellDataList, cell, isHead);</span><br><span class="line">            <span class="keyword">if</span> (columnWidth &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (columnWidth &gt; <span class="number">255</span>) &#123;</span><br><span class="line">                    columnWidth = <span class="number">255</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">maxColumnWidth</span> <span class="operator">=</span> maxColumnWidthMap.get(cell.getColumnIndex());</span><br><span class="line">                <span class="keyword">if</span> (maxColumnWidth == <span class="literal">null</span> || columnWidth &gt; maxColumnWidth) &#123;</span><br><span class="line">                    maxColumnWidthMap.put(cell.getColumnIndex(), columnWidth);</span><br><span class="line">                    writeSheetHolder.getSheet().setColumnWidth(cell.getColumnIndex(), columnWidth * <span class="number">256</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据长度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cellDataList</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cell</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> isHead</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer <span class="title function_">dataLength</span><span class="params">(List&lt;WriteCellData&lt;?&gt;&gt; cellDataList, Cell cell, Boolean isHead)</span> &#123;</span><br><span class="line">        <span class="comment">//头直接返回原始长度</span></span><br><span class="line">        <span class="keyword">if</span> (isHead) &#123;</span><br><span class="line">            <span class="keyword">return</span> cell.getStringCellValue().getBytes().length;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//不是头的话  看是什么类型  用数字加就可以了</span></span><br><span class="line">            <span class="type">WriteCellData</span> <span class="variable">cellData</span> <span class="operator">=</span> cellDataList.get(<span class="number">0</span>);</span><br><span class="line">            <span class="type">CellDataTypeEnum</span> <span class="variable">type</span> <span class="operator">=</span> cellData.getType();</span><br><span class="line">            <span class="keyword">if</span> (type == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">                    <span class="keyword">case</span> STRING:</span><br><span class="line">                        <span class="keyword">return</span> cellData.getStringValue().getBytes().length + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">case</span> BOOLEAN:</span><br><span class="line">                        <span class="keyword">return</span> cellData.getBooleanValue().toString().getBytes().length;</span><br><span class="line">                    <span class="keyword">case</span> NUMBER:</span><br><span class="line">                        <span class="keyword">return</span> cellData.getNumberValue().toString().getBytes().length * <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">case</span> DATE:</span><br><span class="line">                        <span class="keyword">return</span> cellData.getDateValue().toString().length() + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/download3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download3</span><span class="params">(HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/vnd.ms-excel&quot;</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 这里URLEncoder.encode可以防止中文乱码 当然和easyexcel没有关系</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> URLEncoder.encode(<span class="string">&quot;测试&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>).replaceAll(<span class="string">&quot;\\+&quot;</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-disposition&quot;</span>, <span class="string">&quot;attachment;filename=&quot;</span> + fileName + <span class="string">&quot;.xls&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setUserId(<span class="number">123</span>);</span><br><span class="line">        user.setName(<span class="string">&quot;asplplplplpplplplplpl&quot;</span>);</span><br><span class="line">        user.setPhone(<span class="string">&quot;15245413&quot;</span>);</span><br><span class="line">        user.setEmail(<span class="string">&quot;54565454@qq.com&quot;</span>);</span><br><span class="line">        user.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        EasyExcel.write(response.getOutputStream(), User.class)</span><br><span class="line">                .sheet(<span class="string">&quot;模板&quot;</span>)</span><br><span class="line">                .registerWriteHandler(<span class="keyword">new</span> <span class="title class_">CustomWidthStyleStrategy</span>(<span class="number">1</span>))</span><br><span class="line">                .doWrite(Arrays.asList(user));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/download4&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download4</span><span class="params">(HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/vnd.ms-excel&quot;</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 这里URLEncoder.encode可以防止中文乱码 当然和easyexcel没有关系</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> URLEncoder.encode(<span class="string">&quot;测试&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>).replaceAll(<span class="string">&quot;\\+&quot;</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-disposition&quot;</span>, <span class="string">&quot;attachment;filename=&quot;</span> + fileName + <span class="string">&quot;.xls&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setUserId(<span class="number">123</span>);</span><br><span class="line">        user.setName(<span class="string">&quot;asplplplplpplplplplpl&quot;</span>);</span><br><span class="line">        user.setPhone(<span class="string">&quot;15245413&quot;</span>);</span><br><span class="line">        user.setEmail(<span class="string">&quot;54565454@qq.com&quot;</span>);</span><br><span class="line">        user.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        EasyExcel.write(response.getOutputStream(), User.class)</span><br><span class="line">                .sheet(<span class="string">&quot;模板&quot;</span>)</span><br><span class="line">                .registerWriteHandler(<span class="keyword">new</span> <span class="title class_">CustomWidthStyleStrategy</span>(<span class="number">2</span>))</span><br><span class="line">                .doWrite(Arrays.asList(user));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果</strong></p>
<ol>
<li>使用表头设置的列宽</li>
</ol>
<p><img src="3.png" alt=""></p>
<ol start="2">
<li>使用单元格内容设置的列宽</li>
</ol>
<p><img src="4.png" alt=""></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Excel</tag>
        <tag>EasyExcel</tag>
      </tags>
  </entry>
  <entry>
    <title>Easyexcel（7-自定义样式）</title>
    <url>/blog/2024/11/05/Java/excel/easyexcel/Easyexcel%EF%BC%887-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%B7%E5%BC%8F%EF%BC%89/</url>
    <content><![CDATA[<h2 id="注解">注解</h2>
<h3 id="ContentStyle">@ContentStyle</h3>
<p>用于设置内容格式注解，可作用于类和字段上</p>
<ol>
<li>dataFormat：日期格式</li>
<li>hidden：设置单元格使用此样式隐藏</li>
<li>locked：设置单元格使用此样式锁定</li>
<li>quotePrefix：在单元格前面增加`符号，数字或公式将以字符串形式展示</li>
<li>horizontalAlignment：设置是否水平居中</li>
<li>wrapped：设置文本是否应换行。将此标志设置为true通过在多行上显示使单元格中的所有内容可见</li>
<li>verticalAlignment：设置是否垂直居中</li>
<li>rotation：设置单元格中文本旋转角度。03版本的Excel旋转角度区间为-90°90°，07版本的Excel旋转角度区间为0°180°</li>
<li>indent：设置单元格中缩进文本的空格数</li>
<li>borderLeft：设置左边框的样式</li>
<li>borderRight：设置右边框样式</li>
<li>borderTop：设置上边框样式</li>
<li>borderBottom：设置下边框样式</li>
<li>leftBorderColor：设置左边框颜色</li>
<li>rightBorderColor：设置右边框颜色</li>
<li>topBorderColor：设置上边框颜色</li>
<li>bottomBorderColor：设置下边框颜色</li>
<li>fillPatternType：设置填充类型</li>
<li>fillBackgroundColor：设置背景色</li>
<li>fillForegroundColor：设置前景色</li>
<li>shrinkToFit：设置自动单元格自动大小</li>
</ol>
<h3 id="ContentFontStyle">@ContentFontStyle</h3>
<p>用于设置单元格内容字体格式的注解，可作用于类和字段上</p>
<ol>
<li>fontName：字体名称</li>
<li>fontHeightInPoints：字体高度</li>
<li>italic：是否斜体</li>
<li>strikeout：是否设置删除水平线</li>
<li>color：字体颜色</li>
<li>typeOffset：偏移量</li>
<li>underline：下划线</li>
<li>bold：是否加粗</li>
<li>charset：编码格式</li>
</ol>
<h3 id="HeadStyle">@HeadStyle</h3>
<p>用于设置标题样式，可作用于类和字段上</p>
<ol>
<li>dataFormat：日期格式</li>
<li>hidden：设置单元格使用此样式隐藏</li>
<li>locked：设置单元格使用此样式锁定</li>
<li>quotePrefix：在单元格前面增加`符号，数字或公式将以字符串形式展示</li>
<li>horizontalAlignment：设置是否水平居中</li>
<li>wrapped：设置文本是否应换行。将此标志设置为true通过在多行上显示使单元格中的所有内容可见</li>
<li>verticalAlignment：设置是否垂直居中</li>
<li>rotation：设置单元格中文本旋转角度。03版本的Excel旋转角度区间为-90°90°，07版本的Excel旋转角度区间为0°180°</li>
<li>indent：设置单元格中缩进文本的空格数</li>
<li>borderLeft：设置左边框的样式</li>
<li>borderRight：设置右边框样式</li>
<li>borderTop：设置上边框样式</li>
<li>borderBottom：设置下边框样式</li>
<li>leftBorderColor：设置左边框颜色</li>
<li>rightBorderColor：设置右边框颜色</li>
<li>topBorderColor：设置上边框颜色</li>
<li>bottomBorderColor：设置下边框颜色</li>
<li>fillPatternType：设置填充类型</li>
<li>fillBackgroundColor：设置背景色</li>
<li>fillForegroundColor：设置前景色</li>
<li>shrinkToFit：设置自动单元格自动大小</li>
</ol>
<h3 id="HeadFontStyle">@HeadFontStyle</h3>
<p>用于定制标题字体格式，可作用于类和字段上</p>
<ol>
<li>fontName：设置字体名称</li>
<li>fontHeightInPoints：设置字体高度</li>
<li>italic：设置字体是否斜体</li>
<li>strikeout：是否设置删除线</li>
<li>color：设置字体颜色</li>
<li>typeOffset：设置偏移量</li>
<li>underline：设置下划线</li>
<li>charset：设置字体编码</li>
<li>bold：设置字体是否加粗</li>
</ol>
<h2 id="类方法">类方法</h2>
<p><img src="3.png" alt=""></p>
<h3 id="AbstractCellStyleStrategy">AbstractCellStyleStrategy</h3>
<p>通过继承AbstractCellStyleStrategy类，实现其setHeadCellStyle和setContentCellStyle方法可以自定义设置表头和单元格内容样式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractCellStyleStrategy</span> <span class="keyword">implements</span> <span class="title class_">CellWriteHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">order</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> OrderConstant.DEFINE_STYLE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCellDispose</span><span class="params">(CellWriteHandlerContext context)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (context.getHead() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (context.getHead()) &#123;</span><br><span class="line">            setHeadCellStyle(context);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            setContentCellStyle(context);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置表头样式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setHeadCellStyle</span><span class="params">(CellWriteHandlerContext context)</span> &#123;</span><br><span class="line">        setHeadCellStyle(context.getCell(), context.getHeadData(), context.getRelativeRowIndex());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置表头样式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setHeadCellStyle</span><span class="params">(Cell cell, Head head, Integer relativeRowIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;Custom styles must override the setHeadCellStyle method.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置单元格内容样式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setContentCellStyle</span><span class="params">(CellWriteHandlerContext context)</span> &#123;</span><br><span class="line">        setContentCellStyle(context.getCell(), context.getHeadData(), context.getRelativeRowIndex());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置单元格内容样式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setContentCellStyle</span><span class="params">(Cell cell, Head head, Integer relativeRowIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;Custom styles must override the setContentCellStyle method.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="HorizontalCellStyleStrategy">HorizontalCellStyleStrategy</h3>
<p>HorizontalCellStyleStrategy 是提供的一个水平样式策略，只需实现CellWriteHandlerContext类自定义样式即可，通过设置构建这个策略对象基本上可以满足一般的要求了，比如：设置表头和内容的边框、底色、对齐方式、文字字体、文字颜色、文字大小等。设置完之后，需要创建 HorizontalCellStyleStrategy 对象，然后在导出文件时注册这个策略的 handler 即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HorizontalCellStyleStrategy</span> <span class="keyword">extends</span> <span class="title class_">AbstractCellStyleStrategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> WriteCellStyle headWriteCellStyle;</span><br><span class="line">    <span class="keyword">private</span> List&lt;WriteCellStyle&gt; contentWriteCellStyleList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HorizontalCellStyleStrategy</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HorizontalCellStyleStrategy</span><span class="params">(WriteCellStyle headWriteCellStyle,</span></span><br><span class="line"><span class="params">        List&lt;WriteCellStyle&gt; contentWriteCellStyleList)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.headWriteCellStyle = headWriteCellStyle;</span><br><span class="line">        <span class="built_in">this</span>.contentWriteCellStyleList = contentWriteCellStyleList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HorizontalCellStyleStrategy</span><span class="params">(WriteCellStyle headWriteCellStyle, WriteCellStyle contentWriteCellStyle)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.headWriteCellStyle = headWriteCellStyle;</span><br><span class="line">        <span class="keyword">if</span> (contentWriteCellStyle != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.contentWriteCellStyleList = ListUtils.newArrayList(contentWriteCellStyle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置表头样式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setHeadCellStyle</span><span class="params">(CellWriteHandlerContext context)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stopProcessing(context) || headWriteCellStyle == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        WriteCellData&lt;?&gt; cellData = context.getFirstCellData();</span><br><span class="line">        WriteCellStyle.merge(headWriteCellStyle, cellData.getOrCreateStyle());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置单元格内容样式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setContentCellStyle</span><span class="params">(CellWriteHandlerContext context)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stopProcessing(context) || CollectionUtils.isEmpty(contentWriteCellStyleList)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        WriteCellData&lt;?&gt; cellData = context.getFirstCellData();</span><br><span class="line">        <span class="keyword">if</span> (context.getRelativeRowIndex() == <span class="literal">null</span> || context.getRelativeRowIndex() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            WriteCellStyle.merge(contentWriteCellStyleList.get(<span class="number">0</span>), cellData.getOrCreateStyle());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            WriteCellStyle.merge(</span><br><span class="line">                contentWriteCellStyleList.get(context.getRelativeRowIndex() % contentWriteCellStyleList.size()),</span><br><span class="line">                cellData.getOrCreateStyle());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断单元格是否为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">stopProcessing</span><span class="params">(CellWriteHandlerContext context)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> context.getFirstCellData() == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DefaultStyle">DefaultStyle</h3>
<p>Easyexcel在导出文件内容时默认使用DefaultStyle类来设置表头和单元格样式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultStyle</span> <span class="keyword">extends</span> <span class="title class_">HorizontalCellStyleStrategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">order</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> OrderConstant.DEFAULT_DEFINE_STYLE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DefaultStyle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="type">WriteCellStyle</span> <span class="variable">headWriteCellStyle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WriteCellStyle</span>();</span><br><span class="line">        headWriteCellStyle.setWrapped(<span class="literal">true</span>);</span><br><span class="line">        headWriteCellStyle.setVerticalAlignment(VerticalAlignment.CENTER);</span><br><span class="line">        headWriteCellStyle.setHorizontalAlignment(HorizontalAlignment.CENTER);</span><br><span class="line">        headWriteCellStyle.setLocked(<span class="literal">true</span>);</span><br><span class="line">        headWriteCellStyle.setFillPatternType(FillPatternType.SOLID_FOREGROUND);</span><br><span class="line">        headWriteCellStyle.setFillForegroundColor(IndexedColors.GREY_25_PERCENT.getIndex());</span><br><span class="line">        headWriteCellStyle.setBorderTop(BorderStyle.THIN);</span><br><span class="line">        headWriteCellStyle.setBorderBottom(BorderStyle.THIN);</span><br><span class="line">        headWriteCellStyle.setBorderLeft(BorderStyle.THIN);</span><br><span class="line">        headWriteCellStyle.setBorderRight(BorderStyle.THIN);</span><br><span class="line">        <span class="type">WriteFont</span> <span class="variable">headWriteFont</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WriteFont</span>();</span><br><span class="line">        headWriteFont.setFontName(<span class="string">&quot;宋体&quot;</span>);</span><br><span class="line">        headWriteFont.setFontHeightInPoints((<span class="type">short</span>)<span class="number">14</span>);</span><br><span class="line">        headWriteFont.setBold(<span class="literal">true</span>);</span><br><span class="line">        headWriteCellStyle.setWriteFont(headWriteFont);</span><br><span class="line"></span><br><span class="line">        setHeadWriteCellStyle(headWriteCellStyle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Easyexcel的默认风格是，对于表头会显示灰色背景，但是如果取消使用默认风格之后，表头的背景颜色就会恢复白色</p>
<p>Easyexcel控制是否开启默认风格的属性方法是：<code>useDefaultStyle(false)</code></p>
<p>注意：useDefaultStyle方法一定要放在sheet方法前面，否则会失效（放在后面会因为在构造ExcelWriter类时获取不到useDefaultStyle的值，从而导致使用的是默认风格）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> &#123;</span><br><span class="line">    EasyExcel.write(<span class="string">&quot;test01.xlsx&quot;</span>, DemoData.class)</span><br><span class="line">			<span class="comment">//禁用默认风格</span></span><br><span class="line">            .useDefaultStyle(<span class="literal">false</span>)</span><br><span class="line">            .sheet(<span class="string">&quot;testSheet01&quot;</span>)</span><br><span class="line">            .doWrite(demoData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="1.png" alt=""></p>
<h2 id="样式工具类">样式工具类</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * EasyExcel 样式工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomExcelStyleUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标题样式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> WriteCellStyle <span class="title function_">getHeadStyle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 头的策略</span></span><br><span class="line">        <span class="type">WriteCellStyle</span> <span class="variable">headWriteCellStyle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WriteCellStyle</span>();</span><br><span class="line">        <span class="comment">// 背景颜色</span></span><br><span class="line">        <span class="comment">//headWriteCellStyle.setFillForegroundColor(IndexedColors.LIGHT_TURQUOISE1.getIndex());</span></span><br><span class="line">        <span class="comment">//headWriteCellStyle.setFillPatternType(FillPatternType.SOLID_FOREGROUND);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 字体</span></span><br><span class="line">        <span class="type">WriteFont</span> <span class="variable">headWriteFont</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WriteFont</span>();</span><br><span class="line">        headWriteFont.setFontName(<span class="string">&quot;宋体&quot;</span>);<span class="comment">//设置字体名字</span></span><br><span class="line">        headWriteFont.setFontHeightInPoints((<span class="type">short</span>) <span class="number">14</span>);<span class="comment">//设置字体大小</span></span><br><span class="line">        headWriteFont.setBold(<span class="literal">true</span>);<span class="comment">//字体加粗</span></span><br><span class="line">        headWriteCellStyle.setWriteFont(headWriteFont); <span class="comment">//在样式用应用设置的字体;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 样式</span></span><br><span class="line">        headWriteCellStyle.setBorderBottom(BorderStyle.THIN);<span class="comment">//设置底边框;</span></span><br><span class="line">        headWriteCellStyle.setBottomBorderColor((<span class="type">short</span>) <span class="number">0</span>);<span class="comment">//设置底边框颜色;</span></span><br><span class="line">        headWriteCellStyle.setBorderLeft(BorderStyle.THIN);  <span class="comment">//设置左边框;</span></span><br><span class="line">        headWriteCellStyle.setLeftBorderColor((<span class="type">short</span>) <span class="number">0</span>);<span class="comment">//设置左边框颜色;</span></span><br><span class="line">        headWriteCellStyle.setBorderRight(BorderStyle.THIN);<span class="comment">//设置右边框;</span></span><br><span class="line">        headWriteCellStyle.setRightBorderColor((<span class="type">short</span>) <span class="number">0</span>);<span class="comment">//设置右边框颜色;</span></span><br><span class="line">        headWriteCellStyle.setBorderTop(BorderStyle.THIN);<span class="comment">//设置顶边框;</span></span><br><span class="line">        headWriteCellStyle.setTopBorderColor((<span class="type">short</span>) <span class="number">0</span>); <span class="comment">//设置顶边框颜色;</span></span><br><span class="line"></span><br><span class="line">        headWriteCellStyle.setWrapped(<span class="literal">true</span>);  <span class="comment">//设置自动换行;</span></span><br><span class="line"></span><br><span class="line">        headWriteCellStyle.setHorizontalAlignment(HorizontalAlignment.CENTER);<span class="comment">//设置水平对齐的样式为居中对齐;</span></span><br><span class="line">        headWriteCellStyle.setVerticalAlignment(VerticalAlignment.CENTER);  <span class="comment">//设置垂直对齐的样式为居中对齐;</span></span><br><span class="line">        headWriteCellStyle.setShrinkToFit(<span class="literal">true</span>);<span class="comment">//设置文本收缩至合适</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> headWriteCellStyle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 内容样式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> WriteCellStyle <span class="title function_">getContentStyle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 内容的策略</span></span><br><span class="line">        <span class="type">WriteCellStyle</span> <span class="variable">contentWriteCellStyle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WriteCellStyle</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 背景颜色</span></span><br><span class="line">        <span class="comment">// 这里需要指定 FillPatternType 为FillPatternType.SOLID_FOREGROUND 不然无法显示背景颜色.头默认了 FillPatternType所以可以不指定</span></span><br><span class="line">        <span class="comment">//contentWriteCellStyle.setFillForegroundColor(IndexedColors.PALE_BLUE.getIndex());</span></span><br><span class="line">        <span class="comment">//contentWriteCellStyle.setFillPatternType(FillPatternType.SOLID_FOREGROUND);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置字体</span></span><br><span class="line">        <span class="type">WriteFont</span> <span class="variable">contentWriteFont</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WriteFont</span>();</span><br><span class="line">        contentWriteFont.setFontHeightInPoints((<span class="type">short</span>) <span class="number">12</span>);<span class="comment">//设置字体大小</span></span><br><span class="line">        contentWriteFont.setFontName(<span class="string">&quot;宋体&quot;</span>); <span class="comment">//设置字体名字</span></span><br><span class="line">        contentWriteCellStyle.setWriteFont(contentWriteFont);<span class="comment">//在样式用应用设置的字体;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置样式;</span></span><br><span class="line">        contentWriteCellStyle.setBorderBottom(BorderStyle.THIN);<span class="comment">//设置底边框;</span></span><br><span class="line">        contentWriteCellStyle.setBottomBorderColor((<span class="type">short</span>) <span class="number">0</span>);<span class="comment">//设置底边框颜色;</span></span><br><span class="line">        contentWriteCellStyle.setBorderLeft(BorderStyle.THIN);  <span class="comment">//设置左边框;</span></span><br><span class="line">        contentWriteCellStyle.setLeftBorderColor((<span class="type">short</span>) <span class="number">0</span>);<span class="comment">//设置左边框颜色;</span></span><br><span class="line">        contentWriteCellStyle.setBorderRight(BorderStyle.THIN);<span class="comment">//设置右边框;</span></span><br><span class="line">        contentWriteCellStyle.setRightBorderColor((<span class="type">short</span>) <span class="number">0</span>);<span class="comment">//设置右边框颜色;</span></span><br><span class="line">        contentWriteCellStyle.setBorderTop(BorderStyle.THIN);<span class="comment">//设置顶边框;</span></span><br><span class="line">        contentWriteCellStyle.setTopBorderColor((<span class="type">short</span>) <span class="number">0</span>); <span class="comment">///设置顶边框颜色;</span></span><br><span class="line"></span><br><span class="line">        contentWriteCellStyle.setHorizontalAlignment(HorizontalAlignment.CENTER);<span class="comment">// 水平居中</span></span><br><span class="line">        contentWriteCellStyle.setVerticalAlignment(VerticalAlignment.CENTER);<span class="comment">// 垂直居中</span></span><br><span class="line">        contentWriteCellStyle.setWrapped(<span class="literal">true</span>); <span class="comment">//设置自动换行;</span></span><br><span class="line">        contentWriteCellStyle.setShrinkToFit(<span class="literal">true</span>);<span class="comment">//设置文本收缩至合适</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> contentWriteCellStyle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;用户Id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;姓名&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;手机&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;邮箱&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;创建时间&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/download1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download1</span><span class="params">(HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/vnd.ms-excel&quot;</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 这里URLEncoder.encode可以防止中文乱码 当然和easyexcel没有关系</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> URLEncoder.encode(<span class="string">&quot;测试&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>).replaceAll(<span class="string">&quot;\\+&quot;</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-disposition&quot;</span>, <span class="string">&quot;attachment;filename=&quot;</span> + fileName + <span class="string">&quot;.xls&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setUserId(<span class="number">123</span>);</span><br><span class="line">        user.setName(<span class="string">&quot;as&quot;</span>);</span><br><span class="line">        user.setPhone(<span class="string">&quot;15213&quot;</span>);</span><br><span class="line">        user.setEmail(<span class="string">&quot;5456&quot;</span>);</span><br><span class="line">        user.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        EasyExcel.write(response.getOutputStream(), User.class)</span><br><span class="line">                .sheet(<span class="string">&quot;模板&quot;</span>)</span><br><span class="line">                .registerWriteHandler(<span class="keyword">new</span> <span class="title class_">HorizontalCellStyleStrategy</span>(CustomExcelStyleUtil.getHeadStyle(), CustomExcelStyleUtil.getContentStyle()))</span><br><span class="line">                .doWrite(Arrays.asList(user));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="2.png" alt=""></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Excel</tag>
        <tag>EasyExcel</tag>
      </tags>
  </entry>
  <entry>
    <title>Easyexcel（8-通用工具类）</title>
    <url>/blog/2024/11/06/Java/excel/easyexcel/Easyexcel%EF%BC%888-%E9%80%9A%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/</url>
    <content><![CDATA[<h2 id="EasyExcelUtils">EasyExcelUtils</h2>
<p>提供常见的文件同步和异步读取、文件导出、模板填充、自定义表头、自定义内容、从指定行开始读取数据、多Sheet导出等方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EasyExcelUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步无模型读（默认读取sheet0,从第2行开始读）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath excel文件的绝对路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Map&lt;Integer, String&gt;&gt; <span class="title function_">syncRead</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> EasyExcelFactory.read(filePath).sheet().doReadSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步无模型读（默认读取sheet0,从第2行开始读）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputStream excel文件的输入流</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Map&lt;Integer, String&gt;&gt; <span class="title function_">syncRead</span><span class="params">(InputStream inputStream)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> EasyExcelFactory.read(inputStream).sheet().doReadSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步无模型读（默认读取sheet0,从第2行开始读）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file excel文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Map&lt;Integer, String&gt;&gt; <span class="title function_">syncRead</span><span class="params">(File file)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> EasyExcelFactory.read(file).sheet().doReadSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步无模型读（自定义读取sheetX，从第2行开始读）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath excel文件的绝对路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetNo  sheet页号，从0开始</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Map&lt;Integer, String&gt;&gt; <span class="title function_">syncRead</span><span class="params">(String filePath, Integer sheetNo)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> EasyExcelFactory.read(filePath).sheet(sheetNo).doReadSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步无模型读（自定义读取sheetX，从第2行开始读）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputStream excel文件的输入流</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetNo  sheet页号，从0开始</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Map&lt;Integer, String&gt;&gt; <span class="title function_">syncRead</span><span class="params">(InputStream inputStream, Integer sheetNo)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> EasyExcelFactory.read(inputStream).sheet(sheetNo).doReadSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步无模型读（自定义读取sheetX，从第2行开始读）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file excel文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetNo  sheet页号，从0开始</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Map&lt;Integer, String&gt;&gt; <span class="title function_">syncRead</span><span class="params">(File file, Integer sheetNo)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> EasyExcelFactory.read(file).sheet(sheetNo).doReadSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步无模型读（指定sheet和表头占的行数）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetNo    sheet页号，从0开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headRowNum 表头占的行数，从0开始（如果要连表头一起读出来则传0）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Map&lt;Integer, String&gt;&gt; <span class="title function_">syncRead</span><span class="params">(String filePath, Integer sheetNo, Integer headRowNum)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> EasyExcelFactory.read(filePath).sheet(sheetNo).headRowNumber(headRowNum).doReadSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步无模型读（指定sheet和表头占的行数）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputStream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetNo     sheet页号，从0开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headRowNum  表头占的行数，从0开始（如果要连表头一起读出来则传0）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Map&lt;Integer, String&gt;&gt; <span class="title function_">syncRead</span><span class="params">(InputStream inputStream, Integer sheetNo, Integer headRowNum)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> EasyExcelFactory.read(inputStream).sheet(sheetNo).headRowNumber(headRowNum).doReadSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步无模型读（指定sheet和表头占的行数）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetNo    sheet页号，从0开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headRowNum 表头占的行数，从0开始（如果要连表头一起读出来则传0）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Map&lt;Integer, String&gt;&gt; <span class="title function_">syncRead</span><span class="params">(File file, Integer sheetNo, Integer headRowNum)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> EasyExcelFactory.read(file).sheet(sheetNo).headRowNumber(headRowNum).doReadSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步按模型读（默认读取sheet0,从第2行开始读）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz    模型的类类型（excel数据会按该类型转换成对象）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">syncReadModel</span><span class="params">(String filePath, Class clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> EasyExcelFactory.read(filePath).sheet().head(clazz).doReadSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步按模型读（默认读取sheet0,从第2行开始读）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputStream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz    模型的类类型（excel数据会按该类型转换成对象）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">syncReadModel</span><span class="params">(InputStream inputStream, Class clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> EasyExcelFactory.read(inputStream).sheet().head(clazz).doReadSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步按模型读（默认读取sheet0,从第2行开始读）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz    模型的类类型（excel数据会按该类型转换成对象）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">syncReadModel</span><span class="params">(File file, Class clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> EasyExcelFactory.read(file).sheet().head(clazz).doReadSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步按模型读（默认表头占一行，从第2行开始读）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz    模型的类类型（excel数据会按该类型转换成对象）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetNo  sheet页号，从0开始</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">syncReadModel</span><span class="params">(String filePath, Class clazz, Integer sheetNo)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> EasyExcelFactory.read(filePath).sheet(sheetNo).head(clazz).doReadSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步按模型读（默认表头占一行，从第2行开始读）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputStream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz    模型的类类型（excel数据会按该类型转换成对象）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetNo  sheet页号，从0开始</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">syncReadModel</span><span class="params">(InputStream inputStream, Class clazz, Integer sheetNo)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> EasyExcelFactory.read(inputStream).sheet(sheetNo).head(clazz).doReadSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步按模型读（默认表头占一行，从第2行开始读）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz    模型的类类型（excel数据会按该类型转换成对象）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetNo  sheet页号，从0开始</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">syncReadModel</span><span class="params">(File file, Class clazz, Integer sheetNo)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> EasyExcelFactory.read(file).sheet(sheetNo).head(clazz).doReadSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步按模型读（指定sheet和表头占的行数）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz      模型的类类型（excel数据会按该类型转换成对象）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetNo    sheet页号，从0开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headRowNum 表头占的行数，从0开始（如果要连表头一起读出来则传0）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">syncReadModel</span><span class="params">(String filePath, Class clazz, Integer sheetNo, Integer headRowNum)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> EasyExcelFactory.read(filePath).sheet(sheetNo).headRowNumber(headRowNum).head(clazz).doReadSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步按模型读（指定sheet和表头占的行数）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputStream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz       模型的类类型（excel数据会按该类型转换成对象）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetNo     sheet页号，从0开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headRowNum  表头占的行数，从0开始（如果要连表头一起读出来则传0）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">syncReadModel</span><span class="params">(InputStream inputStream, Class clazz, Integer sheetNo, Integer headRowNum)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> EasyExcelFactory.read(inputStream).sheet(sheetNo).headRowNumber(headRowNum).head(clazz).doReadSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步按模型读（指定sheet和表头占的行数）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz      模型的类类型（excel数据会按该类型转换成对象）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetNo    sheet页号，从0开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headRowNum 表头占的行数，从0开始（如果要连表头一起读出来则传0）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">syncReadModel</span><span class="params">(File file, Class clazz, Integer sheetNo, Integer headRowNum)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> EasyExcelFactory.read(file).sheet(sheetNo).headRowNumber(headRowNum).head(clazz).doReadSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异步无模型读（默认读取sheet0,从第2行开始读）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> excelListener 监听器，在监听器中可以处理行数据LinkedHashMap，表头数据，异常处理等</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath      表头占的行数，从0开始（如果要连表头一起读出来则传0）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">asyncRead</span><span class="params">(String filePath, AnalysisEventListener&lt;T&gt; excelListener)</span> &#123;</span><br><span class="line">        EasyExcelFactory.read(filePath, excelListener).sheet().doRead();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异步无模型读（默认读取sheet0,从第2行开始读）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> excelListener 监听器，在监听器中可以处理行数据LinkedHashMap，表头数据，异常处理等</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputStream      表头占的行数，从0开始（如果要连表头一起读出来则传0）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">asyncRead</span><span class="params">(InputStream inputStream, AnalysisEventListener&lt;T&gt; excelListener)</span> &#123;</span><br><span class="line">        EasyExcelFactory.read(inputStream, excelListener).sheet().doRead();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异步无模型读（默认读取sheet0,从第2行开始读）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> excelListener 监听器，在监听器中可以处理行数据LinkedHashMap，表头数据，异常处理等</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file      表头占的行数，从0开始（如果要连表头一起读出来则传0）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">asyncRead</span><span class="params">(File file, AnalysisEventListener&lt;T&gt; excelListener)</span> &#123;</span><br><span class="line">        EasyExcelFactory.read(file, excelListener).sheet().doRead();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异步无模型读（默认表头占一行，从第2行开始读）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath      表头占的行数，从0开始（如果要连表头一起读出来则传0）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> excelListener 监听器，在监听器中可以处理行数据LinkedHashMap，表头数据，异常处理等</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetNo       sheet页号，从0开始</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">asyncRead</span><span class="params">(String filePath, AnalysisEventListener&lt;T&gt; excelListener, Integer sheetNo)</span> &#123;</span><br><span class="line">        EasyExcelFactory.read(filePath, excelListener).sheet(sheetNo).doRead();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异步无模型读（默认表头占一行，从第2行开始读）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputStream      表头占的行数，从0开始（如果要连表头一起读出来则传0）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> excelListener 监听器，在监听器中可以处理行数据LinkedHashMap，表头数据，异常处理等</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetNo       sheet页号，从0开始</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">asyncRead</span><span class="params">(InputStream inputStream, AnalysisEventListener&lt;T&gt; excelListener, Integer sheetNo)</span> &#123;</span><br><span class="line">        EasyExcelFactory.read(inputStream, excelListener).sheet(sheetNo).doRead();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异步无模型读（默认表头占一行，从第2行开始读）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file      表头占的行数，从0开始（如果要连表头一起读出来则传0）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> excelListener 监听器，在监听器中可以处理行数据LinkedHashMap，表头数据，异常处理等</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetNo       sheet页号，从0开始</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">asyncRead</span><span class="params">(File file, AnalysisEventListener&lt;T&gt; excelListener, Integer sheetNo)</span> &#123;</span><br><span class="line">        EasyExcelFactory.read(file, excelListener).sheet(sheetNo).doRead();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异步无模型读（指定sheet和表头占的行数）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> excelListener 监听器，在监听器中可以处理行数据LinkedHashMap，表头数据，异常处理等</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetNo       sheet页号，从0开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headRowNum    表头占的行数，从0开始（如果要连表头一起读出来则传0）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">asyncRead</span><span class="params">(String filePath, AnalysisEventListener&lt;T&gt; excelListener, Integer sheetNo, Integer headRowNum)</span> &#123;</span><br><span class="line">        EasyExcelFactory.read(filePath, excelListener).sheet(sheetNo).headRowNumber(headRowNum).doRead();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异步无模型读（指定sheet和表头占的行数）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputStream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> excelListener 监听器，在监听器中可以处理行数据LinkedHashMap，表头数据，异常处理等</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetNo       sheet页号，从0开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headRowNum    表头占的行数，从0开始（如果要连表头一起读出来则传0）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">asyncRead</span><span class="params">(InputStream inputStream, AnalysisEventListener&lt;T&gt; excelListener, Integer sheetNo, Integer headRowNum)</span> &#123;</span><br><span class="line">        EasyExcelFactory.read(inputStream, excelListener).sheet(sheetNo).headRowNumber(headRowNum).doRead();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异步无模型读（指定sheet和表头占的行数）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> excelListener 监听器，在监听器中可以处理行数据LinkedHashMap，表头数据，异常处理等</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetNo       sheet页号，从0开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headRowNum    表头占的行数，从0开始（如果要连表头一起读出来则传0）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">asyncRead</span><span class="params">(File file, AnalysisEventListener&lt;T&gt; excelListener, Integer sheetNo, Integer headRowNum)</span> &#123;</span><br><span class="line">        EasyExcelFactory.read(file, excelListener).sheet(sheetNo).headRowNumber(headRowNum).doRead();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异步按模型读取（默认读取sheet0,从第2行开始读）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> excelListener 监听器，在监听器中可以处理行数据LinkedHashMap，表头数据，异常处理等</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz         模型的类类型（excel数据会按该类型转换成对象）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">asyncReadModel</span><span class="params">(String filePath, AnalysisEventListener&lt;T&gt; excelListener, Class clazz)</span> &#123;</span><br><span class="line">        EasyExcelFactory.read(filePath, clazz, excelListener).sheet().doRead();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异步按模型读取（默认读取sheet0,从第2行开始读）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputStream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> excelListener 监听器，在监听器中可以处理行数据LinkedHashMap，表头数据，异常处理等</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz         模型的类类型（excel数据会按该类型转换成对象）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">asyncReadModel</span><span class="params">(InputStream inputStream, AnalysisEventListener&lt;T&gt; excelListener, Class clazz)</span> &#123;</span><br><span class="line">        EasyExcelFactory.read(inputStream, clazz, excelListener).sheet().doRead();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异步按模型读取（默认读取sheet0,从第2行开始读）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> excelListener 监听器，在监听器中可以处理行数据LinkedHashMap，表头数据，异常处理等</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz         模型的类类型（excel数据会按该类型转换成对象）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">asyncReadModel</span><span class="params">(File file, AnalysisEventListener&lt;T&gt; excelListener, Class clazz)</span> &#123;</span><br><span class="line">        EasyExcelFactory.read(file, clazz, excelListener).sheet().doRead();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异步按模型读取（默认表头占一行，从第2行开始读）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> excelListener 监听器，在监听器中可以处理行数据LinkedHashMap，表头数据，异常处理等</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz         模型的类类型（excel数据会按该类型转换成对象）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetNo       sheet页号，从0开始</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">asyncReadModel</span><span class="params">(String filePath, AnalysisEventListener&lt;T&gt; excelListener, Class clazz, Integer sheetNo)</span> &#123;</span><br><span class="line">        EasyExcelFactory.read(filePath, clazz, excelListener).sheet(sheetNo).doRead();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异步按模型读取（默认表头占一行，从第2行开始读）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputStream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> excelListener 监听器，在监听器中可以处理行数据LinkedHashMap，表头数据，异常处理等</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz         模型的类类型（excel数据会按该类型转换成对象）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetNo       sheet页号，从0开始</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">asyncReadModel</span><span class="params">(InputStream inputStream, AnalysisEventListener&lt;T&gt; excelListener, Class clazz, Integer sheetNo)</span> &#123;</span><br><span class="line">        EasyExcelFactory.read(inputStream, clazz, excelListener).sheet(sheetNo).doRead();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异步按模型读取（默认表头占一行，从第2行开始读）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> excelListener 监听器，在监听器中可以处理行数据LinkedHashMap，表头数据，异常处理等</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz         模型的类类型（excel数据会按该类型转换成对象）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetNo       sheet页号，从0开始</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">asyncReadModel</span><span class="params">(File file, AnalysisEventListener&lt;T&gt; excelListener, Class clazz, Integer sheetNo)</span> &#123;</span><br><span class="line">        EasyExcelFactory.read(file, clazz, excelListener).sheet(sheetNo).doRead();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异步按模型读取</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> excelListener 监听器，在监听器中可以处理行数据LinkedHashMap，表头数据，异常处理等</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz         模型的类类型（excel数据会按该类型转换成对象）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetNo       sheet页号，从0开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headRowNum    表头占的行数，从0开始（如果要连表头一起读出来则传0）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">asyncReadModel</span><span class="params">(String filePath, AnalysisEventListener&lt;T&gt; excelListener, Class clazz, Integer sheetNo, Integer headRowNum)</span> &#123;</span><br><span class="line">        EasyExcelFactory.read(filePath, clazz, excelListener).sheet(sheetNo).headRowNumber(headRowNum).doRead();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异步按模型读取</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputStream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> excelListener 监听器，在监听器中可以处理行数据LinkedHashMap，表头数据，异常处理等</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz         模型的类类型（excel数据会按该类型转换成对象）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetNo       sheet页号，从0开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headRowNum    表头占的行数，从0开始（如果要连表头一起读出来则传0）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">asyncReadModel</span><span class="params">(InputStream inputStream, AnalysisEventListener&lt;T&gt; excelListener, Class clazz, Integer sheetNo, Integer headRowNum)</span> &#123;</span><br><span class="line">        EasyExcelFactory.read(inputStream, clazz, excelListener).sheet(sheetNo).headRowNumber(headRowNum).doRead();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异步按模型读取</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> excelListener 监听器，在监听器中可以处理行数据LinkedHashMap，表头数据，异常处理等</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz         模型的类类型（excel数据会按该类型转换成对象）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetNo       sheet页号，从0开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headRowNum    表头占的行数，从0开始（如果要连表头一起读出来则传0）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">asyncReadModel</span><span class="params">(File file, AnalysisEventListener&lt;T&gt; excelListener, Class clazz, Integer sheetNo, Integer headRowNum)</span> &#123;</span><br><span class="line">        EasyExcelFactory.read(file, clazz, excelListener).sheet(sheetNo).headRowNumber(headRowNum).doRead();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无模板写文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head     表头数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data     表内容数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String filePath, List&lt;List&lt;String&gt;&gt; head, List&lt;List&lt;Object&gt;&gt; data)</span> &#123;</span><br><span class="line">        EasyExcel.write(filePath).head(head).sheet().doWrite(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无模板写文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outputStream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head     表头数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data     表内容数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(OutputStream outputStream, List&lt;List&lt;String&gt;&gt; head, List&lt;List&lt;Object&gt;&gt; data)</span> &#123;</span><br><span class="line">        EasyExcel.write(outputStream).head(head).sheet().doWrite(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无模板写文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head      表头数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data      表内容数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetNo   sheet页号，从0开始</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String filePath, List&lt;List&lt;String&gt;&gt; head, List&lt;List&lt;Object&gt;&gt; data, Integer sheetNo)</span> &#123;</span><br><span class="line">        EasyExcel.write(filePath).head(head).sheet(sheetNo).doWrite(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无模板写文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outputStream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head      表头数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data      表内容数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetNo   sheet页号，从0开始</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(OutputStream outputStream, List&lt;List&lt;String&gt;&gt; head, List&lt;List&lt;Object&gt;&gt; data, Integer sheetNo)</span> &#123;</span><br><span class="line">        EasyExcel.write(outputStream).head(head).sheet(sheetNo).doWrite(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无模板写文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head      表头数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data      表内容数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetNo   sheet页号，从0开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetName sheet名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String filePath, List&lt;List&lt;String&gt;&gt; head, List&lt;List&lt;Object&gt;&gt; data, Integer sheetNo, String sheetName)</span> &#123;</span><br><span class="line">        EasyExcel.write(filePath).head(head).sheet(sheetNo, sheetName).doWrite(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无模板写文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outputStream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head      表头数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data      表内容数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetNo   sheet页号，从0开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetName sheet名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(OutputStream outputStream, List&lt;List&lt;String&gt;&gt; head, List&lt;List&lt;Object&gt;&gt; data, Integer sheetNo, String sheetName)</span> &#123;</span><br><span class="line">        EasyExcel.write(outputStream).head(head).sheet(sheetNo, sheetName).doWrite(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据excel模板文件写入文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> templateFileName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeTemplate</span><span class="params">(String filePath, String templateFileName, List data)</span> &#123;</span><br><span class="line">        EasyExcel.write(filePath).withTemplate(templateFileName).sheet().doFill(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据excel模板文件写入文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outputStream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> templateFileName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeTemplate</span><span class="params">(OutputStream outputStream, String templateFileName, List data)</span> &#123;</span><br><span class="line">        EasyExcel.write(outputStream).withTemplate(templateFileName).sheet().doFill(data);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据excel模板文件写入文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> templateFileName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeTemplate</span><span class="params">(File file, String templateFileName, List data)</span> &#123;</span><br><span class="line">        EasyExcel.write(file).withTemplate(templateFileName).sheet().doFill(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据excel模板文件写入文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> templateFileName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headClazz</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeTemplate</span><span class="params">(String filePath, String templateFileName, Class headClazz, List data)</span> &#123;</span><br><span class="line">        EasyExcel.write(filePath, headClazz).withTemplate(templateFileName).sheet().doFill(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据excel模板文件写入文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outputStream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> templateFileName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headClazz</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeTemplate</span><span class="params">(OutputStream outputStream, String templateFileName, Class headClazz, List data)</span> &#123;</span><br><span class="line">        EasyExcel.write(outputStream, headClazz).withTemplate(templateFileName).sheet().doFill(data);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据excel模板文件写入文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> templateFileName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headClazz</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeTemplate</span><span class="params">(File file, String templateFileName, Class headClazz, List data)</span> &#123;</span><br><span class="line">        EasyExcel.write(file, headClazz).withTemplate(templateFileName).sheet().doFill(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按模板写文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headClazz 表头模板</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data      数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String filePath, Class headClazz, List data)</span> &#123;</span><br><span class="line">        EasyExcel.write(filePath, headClazz).sheet().doWrite(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按模板写文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outputStream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headClazz 表头模板</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data      数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(OutputStream outputStream, Class headClazz, List data)</span> &#123;</span><br><span class="line">        EasyExcel.write(outputStream, headClazz).sheet().doWrite(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按模板写文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headClazz 表头模板</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data      数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(File file, Class headClazz, List data)</span> &#123;</span><br><span class="line">        EasyExcel.write(file, headClazz).sheet().doWrite(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按模板写文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headClazz 表头模板</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data      数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetNo   sheet页号，从0开始</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String filePath, Class headClazz, List data, Integer sheetNo)</span> &#123;</span><br><span class="line">        EasyExcel.write(filePath, headClazz).sheet(sheetNo).doWrite(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按模板写文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outputStream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headClazz 表头模板</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data      数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetNo   sheet页号，从0开始</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(OutputStream outputStream, Class headClazz, List data, Integer sheetNo)</span> &#123;</span><br><span class="line">        EasyExcel.write(outputStream, headClazz).sheet(sheetNo).doWrite(data);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按模板写文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headClazz 表头模板</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data      数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetNo   sheet页号，从0开始</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(File file, Class headClazz, List data, Integer sheetNo)</span> &#123;</span><br><span class="line">        EasyExcel.write(file, headClazz).sheet(sheetNo).doWrite(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按模板写文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headClazz 表头模板</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data      数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetNo   sheet页号，从0开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetName sheet名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String filePath, Class headClazz, List data, Integer sheetNo, String sheetName)</span> &#123;</span><br><span class="line">        EasyExcel.write(filePath, headClazz).sheet(sheetNo, sheetName).doWrite(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按模板写文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outputStream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headClazz 表头模板</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data      数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetNo   sheet页号，从0开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetName sheet名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(OutputStream outputStream, Class headClazz, List data, Integer sheetNo, String sheetName)</span> &#123;</span><br><span class="line">        EasyExcel.write(outputStream, headClazz).sheet(sheetNo, sheetName).doWrite(data);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按模板写文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headClazz 表头模板</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data      数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetNo   sheet页号，从0开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetName sheet名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(File file, Class headClazz, List data, Integer sheetNo, String sheetName)</span> &#123;</span><br><span class="line">        EasyExcel.write(file, headClazz).sheet(sheetNo, sheetName).doWrite(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按模板写文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headClazz    表头模板</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data         数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> writeHandler 自定义的处理器，比如设置table样式，设置超链接、单元格下拉框等等功能都可以通过这个实现（需要注册多个则自己通过链式去调用）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetNo      sheet页号，从0开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetName    sheet名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String filePath, Class headClazz, List data, WriteHandler writeHandler, Integer sheetNo, String sheetName)</span> &#123;</span><br><span class="line">        EasyExcel.write(filePath, headClazz).registerWriteHandler(writeHandler).sheet(sheetNo, sheetName).doWrite(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按模板写文件（包含某些字段）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headClazz   表头模板</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data        数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> includeCols 包含字段集合，根据字段名称显示</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetNo     sheet页号，从0开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetName   sheet名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeInclude</span><span class="params">(String filePath, Class headClazz, List data, Set&lt;String&gt; includeCols, Integer sheetNo, String sheetName)</span> &#123;</span><br><span class="line">        EasyExcel.write(filePath, headClazz).includeColumnFieldNames(includeCols).sheet(sheetNo, sheetName).doWrite(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按模板写文件（排除某些字段）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headClazz   表头模板</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data        数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> excludeCols 过滤排除的字段，根据字段名称过滤</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetNo     sheet页号，从0开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetName   sheet名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeExclude</span><span class="params">(String filePath, Class headClazz, List data, Set&lt;String&gt; excludeCols, Integer sheetNo, String sheetName)</span> &#123;</span><br><span class="line">        EasyExcel.write(filePath, headClazz).excludeColumnFieldNames(excludeCols).sheet(sheetNo, sheetName).doWrite(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 多个sheet页的数据链式写入</span></span><br><span class="line"><span class="comment">     * ExcelUtil.writeWithSheets(outputStream)</span></span><br><span class="line"><span class="comment">     * .writeModel(ExcelModel.class, excelModelList, &quot;sheetName1&quot;)</span></span><br><span class="line"><span class="comment">     * .write(headData, data,&quot;sheetName2&quot;)</span></span><br><span class="line"><span class="comment">     * .finish();</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outputStream</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EasyExcelWriterFactory <span class="title function_">writeWithSheets</span><span class="params">(OutputStream outputStream)</span> &#123;</span><br><span class="line">        <span class="type">EasyExcelWriterFactory</span> <span class="variable">excelWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EasyExcelWriterFactory</span>(outputStream);</span><br><span class="line">        <span class="keyword">return</span> excelWriter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 多个sheet页的数据链式写入</span></span><br><span class="line"><span class="comment">     * ExcelUtil.writeWithSheets(file)</span></span><br><span class="line"><span class="comment">     * .writeModel(ExcelModel.class, excelModelList, &quot;sheetName1&quot;)</span></span><br><span class="line"><span class="comment">     * .write(headData, data,&quot;sheetName2&quot;)</span></span><br><span class="line"><span class="comment">     * .finish();</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EasyExcelWriterFactory <span class="title function_">writeWithSheets</span><span class="params">(File file)</span> &#123;</span><br><span class="line">        <span class="type">EasyExcelWriterFactory</span> <span class="variable">excelWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EasyExcelWriterFactory</span>(file);</span><br><span class="line">        <span class="keyword">return</span> excelWriter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 多个sheet页的数据链式写入</span></span><br><span class="line"><span class="comment">     * ExcelUtil.writeWithSheets(filePath)</span></span><br><span class="line"><span class="comment">     * .writeModel(ExcelModel.class, excelModelList, &quot;sheetName1&quot;)</span></span><br><span class="line"><span class="comment">     * .write(headData, data,&quot;sheetName2&quot;)</span></span><br><span class="line"><span class="comment">     * .finish();</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EasyExcelWriterFactory <span class="title function_">writeWithSheets</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">        <span class="type">EasyExcelWriterFactory</span> <span class="variable">excelWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EasyExcelWriterFactory</span>(filePath);</span><br><span class="line">        <span class="keyword">return</span> excelWriter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 多个sheet页的数据链式写入（失败了会返回一个有部分数据的Excel）</span></span><br><span class="line"><span class="comment">     * ExcelUtil.writeWithSheets(response, exportFileName)</span></span><br><span class="line"><span class="comment">     * .writeModel(ExcelModel.class, excelModelList, &quot;sheetName1&quot;)</span></span><br><span class="line"><span class="comment">     * .write(headData, data,&quot;sheetName2&quot;)</span></span><br><span class="line"><span class="comment">     * .finish();</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exportFileName 导出的文件名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EasyExcelWriterFactory <span class="title function_">writeWithSheetsWeb</span><span class="params">(HttpServletResponse response, String exportFileName)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/vnd.ms-excel&quot;</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 这里URLEncoder.encode可以防止中文乱码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> URLEncoder.encode(exportFileName, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-disposition&quot;</span>, <span class="string">&quot;attachment;filename=&quot;</span> + fileName + <span class="string">&quot;.xlsx&quot;</span>);</span><br><span class="line">        <span class="type">EasyExcelWriterFactory</span> <span class="variable">excelWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EasyExcelWriterFactory</span>(response.getOutputStream());</span><br><span class="line">        <span class="keyword">return</span> excelWriter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="EasyExcelWriterFactory">EasyExcelWriterFactory</h2>
<p>文件导出和模板填充实现多Sheet写入（链式使用）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EasyExcelWriterFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">sheetNo</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ExcelWriter</span> <span class="variable">excelWriter</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EasyExcelWriterFactory</span><span class="params">(OutputStream outputStream)</span> &#123;</span><br><span class="line">        excelWriter = EasyExcel.write(outputStream).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EasyExcelWriterFactory</span><span class="params">(File file)</span> &#123;</span><br><span class="line">        excelWriter = EasyExcel.write(file).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EasyExcelWriterFactory</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">        excelWriter = EasyExcel.write(filePath).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链式模板表头写入</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headClazz 表头格式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data      数据 List&lt;ExcelModel&gt; 或者List&lt;List&lt;Object&gt;&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> EasyExcelWriterFactory <span class="title function_">writeModel</span><span class="params">(Class headClazz, List data)</span> &#123;</span><br><span class="line">        excelWriter.write(data, EasyExcel.writerSheet(<span class="built_in">this</span>.sheetNo++).head(headClazz).build());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链式模板表头写入</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headClazz 表头格式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data      数据 List&lt;ExcelModel&gt; 或者List&lt;List&lt;Object&gt;&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> EasyExcelWriterFactory <span class="title function_">writeModel</span><span class="params">(Class headClazz, List data, String sheetName)</span> &#123;</span><br><span class="line">        excelWriter.write(data, EasyExcel.writerSheet(<span class="built_in">this</span>.sheetNo++, sheetName).head(headClazz).build());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链式自定义表头写入</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data      数据 List&lt;ExcelModel&gt; 或者List&lt;List&lt;Object&gt;&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> EasyExcelWriterFactory <span class="title function_">write</span><span class="params">(List&lt;List&lt;String&gt;&gt; head, List data, String sheetName)</span> &#123;</span><br><span class="line">        excelWriter.write(data, EasyExcel.writerSheet(<span class="built_in">this</span>.sheetNo++, sheetName).head(head).build());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用此类结束后，一定要关闭流</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">finish</span><span class="params">()</span> &#123;</span><br><span class="line">        excelWriter.finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ExcelListener">ExcelListener</h2>
<p>文件读取大数据和多Sheet导入监听器（使用线程池和批量插入方法）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExcelListener</span> <span class="keyword">extends</span> <span class="title class_">AnalysisEventListener</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">BATCH_SIZE</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer sheetNo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Executor executor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; dataList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExcelListener</span><span class="params">(Integer sheetNo, Executor executor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sheetNo = sheetNo;</span><br><span class="line">        <span class="built_in">this</span>.executor = executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(T data, AnalysisContext analysisContext)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;解析到一条数据：&#123;&#125;&quot;</span>, JSON.toJSONString(data));</span><br><span class="line">        dataList.add(data);</span><br><span class="line">        <span class="keyword">if</span> (dataList.size() &gt;= BATCH_SIZE) &#123;</span><br><span class="line">            CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">                <span class="comment">// 业务操作</span></span><br><span class="line">                <span class="comment">// saveToDB(dataList);</span></span><br><span class="line">            &#125;, executor);</span><br><span class="line">            dataList.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfterAllAnalysed</span><span class="params">(AnalysisContext analysisContext)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;已解析完所有数据!&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!dataList.isEmpty()) &#123;</span><br><span class="line">            CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">                <span class="comment">// 业务操作</span></span><br><span class="line">                <span class="comment">// saveToDB(dataList);</span></span><br><span class="line">            &#125;, executor);</span><br><span class="line">            dataList.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onException</span><span class="params">(Exception exception, AnalysisContext context)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> ExcelDataConvertException) &#123;</span><br><span class="line">            <span class="type">ExcelDataConvertException</span> <span class="variable">convertException</span> <span class="operator">=</span> (ExcelDataConvertException) exception;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">row</span> <span class="operator">=</span> convertException.getRowIndex();</span><br><span class="line">            log.error(<span class="string">&quot;sheetNo：&#123;&#125;，第&#123;&#125;行数据转换失败，异常信息：&#123;&#125;&quot;</span>, sheetNo, row, exception.getMessage());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.error(<span class="string">&quot;导入其他异常信息：&#123;&#125;&quot;</span>, exception.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用案例">使用案例</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/download1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download1</span><span class="params">(HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/vnd.ms-excel&quot;</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 这里URLEncoder.encode可以防止中文乱码 当然和easyexcel没有关系</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> URLEncoder.encode(<span class="string">&quot;测试&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>).replaceAll(<span class="string">&quot;\\+&quot;</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-disposition&quot;</span>, <span class="string">&quot;attachment;filename=&quot;</span> + fileName + <span class="string">&quot;.xls&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setUserId(<span class="number">123</span>);</span><br><span class="line">        user.setName(<span class="string">&quot;as&quot;</span>);</span><br><span class="line">        user.setPhone(<span class="string">&quot;15213&quot;</span>);</span><br><span class="line">        user.setEmail(<span class="string">&quot;5456&quot;</span>);</span><br><span class="line">        user.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        EasyExcelUtils.write(response.getOutputStream(), User.class, Arrays.asList(user));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/download2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download2</span><span class="params">(HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/vnd.ms-excel&quot;</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 这里URLEncoder.encode可以防止中文乱码 当然和easyexcel没有关系</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> URLEncoder.encode(<span class="string">&quot;测试&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>).replaceAll(<span class="string">&quot;\\+&quot;</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-disposition&quot;</span>, <span class="string">&quot;attachment;filename=&quot;</span> + fileName + <span class="string">&quot;.xls&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setUserId(<span class="number">123</span>);</span><br><span class="line">        user.setName(<span class="string">&quot;as&quot;</span>);</span><br><span class="line">        user.setPhone(<span class="string">&quot;15213&quot;</span>);</span><br><span class="line">        user.setEmail(<span class="string">&quot;5456&quot;</span>);</span><br><span class="line">        user.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        EasyExcelUtils.write(response.getOutputStream(), User.class, Arrays.asList(user), <span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/download3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download3</span><span class="params">(HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/vnd.ms-excel&quot;</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 这里URLEncoder.encode可以防止中文乱码 当然和easyexcel没有关系</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> URLEncoder.encode(<span class="string">&quot;测试&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>).replaceAll(<span class="string">&quot;\\+&quot;</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-disposition&quot;</span>, <span class="string">&quot;attachment;filename=&quot;</span> + fileName + <span class="string">&quot;.xls&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setUserId(<span class="number">123</span>);</span><br><span class="line">        user.setName(<span class="string">&quot;as&quot;</span>);</span><br><span class="line">        user.setPhone(<span class="string">&quot;15213&quot;</span>);</span><br><span class="line">        user.setEmail(<span class="string">&quot;5456&quot;</span>);</span><br><span class="line">        user.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        EasyExcelUtils.writeWithSheets(response.getOutputStream())</span><br><span class="line">                .writeModel(User.class, Arrays.asList(user))</span><br><span class="line">                .writeModel(User.class, Arrays.asList(user))</span><br><span class="line">                .finish();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Excel</tag>
        <tag>EasyExcel</tag>
      </tags>
  </entry>
  <entry>
    <title>Easyexcel（9-类详解）</title>
    <url>/blog/2024/11/07/Java/excel/easyexcel/Easyexcel%EF%BC%889-%E7%B1%BB%E8%AF%A6%E8%A7%A3%EF%BC%89/</url>
    <content><![CDATA[<h2 id="常用类">常用类</h2>
<ol>
<li>EasyExcel：入口类，用于构建开始各种操作；</li>
<li>ExcelReaderBuilder：构建出一个ReadWorkbook对象，即一个工作簿对象，对应的是一个Excel文件；</li>
<li>ExcelWriterBuilder：构建出一个WriteWorkbook对象，即一个工作簿对象，对应的是一个Excel文件；</li>
<li>ExcelReaderSheetBuilder：构建出一个ReadSheet对象，即一个工作表的对象，对应的Excel中的每个sheet，一个工作簿可以有多个工作表；</li>
<li>ExcelWriterSheetBuilder：构建出一WriteSheet对象，即一个工作表的对象，对应的Excel中的每个sheet，一个工作簿可以有多个工作表；</li>
<li>ReadListener：在每一行读取完毕后都会调用ReadListener来处理数据，我们可以把调用service的代码可以写在其invoke方法内部；</li>
<li>WriteHandler：在每一个操作包括创建单元格、创建表格等都会调用WriteHandler来处理数据，对使用者透明不可见；</li>
</ol>
<p>所有配置都是继承的，Workbook的配置会被Sheet继承。所以在用EasyExcel设置参数的时候，在EasyExcel…sheet()方法之前作用域是整个sheet，之后针对单个sheet</p>
<h2 id="RowWriteHandler">RowWriteHandler</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RowWriteHandler</span> <span class="keyword">extends</span> <span class="title class_">WriteHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//行创建之前</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">beforeRowCreate</span><span class="params">(RowWriteHandlerContext context)</span> &#123;</span><br><span class="line">        beforeRowCreate(context.getWriteSheetHolder(), context.getWriteTableHolder(), context.getRowIndex(),</span><br><span class="line">            context.getRelativeRowIndex(), context.getHead());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//行创建之前</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">beforeRowCreate</span><span class="params">(WriteSheetHolder writeSheetHolder, WriteTableHolder writeTableHolder, Integer rowIndex,</span></span><br><span class="line"><span class="params">        Integer relativeRowIndex, Boolean isHead)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//在行创建之后</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">afterRowCreate</span><span class="params">(RowWriteHandlerContext context)</span> &#123;</span><br><span class="line">        afterRowCreate(context.getWriteSheetHolder(), context.getWriteTableHolder(), context.getRow(),</span><br><span class="line">            context.getRelativeRowIndex(), context.getHead());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//在行创建之后</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">afterRowCreate</span><span class="params">(WriteSheetHolder writeSheetHolder, WriteTableHolder writeTableHolder, Row row,</span></span><br><span class="line"><span class="params">        Integer relativeRowIndex, Boolean isHead)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//在行处置之后</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">afterRowDispose</span><span class="params">(RowWriteHandlerContext context)</span> &#123;</span><br><span class="line">        afterRowDispose(context.getWriteSheetHolder(), context.getWriteTableHolder(), context.getRow(),</span><br><span class="line">            context.getRelativeRowIndex(), context.getHead());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//在行处置之后</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">afterRowDispose</span><span class="params">(WriteSheetHolder writeSheetHolder, WriteTableHolder writeTableHolder, Row row,</span></span><br><span class="line"><span class="params">        Integer relativeRowIndex, Boolean isHead)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用案例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommentWriteHandler</span> <span class="keyword">extends</span> <span class="title class_">AbstractRowWriteHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, FailRecord&gt; failDataMap;</span><br><span class="line">	<span class="comment">// 构造参数传入错误的数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CommentWriteHandler</span><span class="params">(Map&lt;Integer, FailRecord&gt; failDataMap)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.failDataMap = failDataMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterRowDispose</span><span class="params">(WriteSheetHolder writeSheetHolder, WriteTableHolder writeTableHolder, Row row,Integer relativeRowIndex, Boolean isHead)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failDataMap.containsKey(row.getRowNum())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isHead) &#123;</span><br><span class="line">                <span class="type">Sheet</span> <span class="variable">sheet</span> <span class="operator">=</span> writeSheetHolder.getSheet();</span><br><span class="line">                <span class="type">Cell</span> <span class="variable">cell</span> <span class="operator">=</span> row.getCell(failDataMap.get(row.getRowNum()).getColumn());</span><br><span class="line">                <span class="type">Workbook</span> <span class="variable">workbook</span> <span class="operator">=</span> sheet.getWorkbook();</span><br><span class="line">                <span class="type">CellStyle</span> <span class="variable">cellStyle</span> <span class="operator">=</span> workbook.createCellStyle();</span><br><span class="line">                <span class="comment">//设置前景填充样式</span></span><br><span class="line">                cellStyle.setFillPattern(FillPatternType.SOLID_FOREGROUND);</span><br><span class="line">                <span class="comment">//设置前景色为红色</span></span><br><span class="line">                cellStyle.setFillForegroundColor(IndexedColors.RED.getIndex());</span><br><span class="line">                <span class="comment">//设置垂直居中</span></span><br><span class="line">                cellStyle.setVerticalAlignment(VerticalAlignment.CENTER);</span><br><span class="line">                <span class="type">Font</span> <span class="variable">font</span> <span class="operator">=</span> workbook.createFont();</span><br><span class="line">                <span class="comment">//设置字体为红色</span></span><br><span class="line">                font.setColor(Font.COLOR_RED);</span><br><span class="line">                cellStyle.setFont(font);</span><br><span class="line">				<span class="comment">//创建设置批注</span></span><br><span class="line">                Drawing&lt;?&gt; drawingPatriarch = sheet.createDrawingPatriarch();</span><br><span class="line">                <span class="type">Comment</span> <span class="variable">comment</span> <span class="operator">=</span> drawingPatriarch.createCellComment(<span class="keyword">new</span> <span class="title class_">HSSFClientAnchor</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                        (<span class="type">short</span>) row.getRowNum(), failDataMap.get(row.getRowNum()).getColumn(), (<span class="type">short</span>) (row.getRowNum() + <span class="number">1</span>), failDataMap.get(row.getRowNum()).getColumn() + <span class="number">1</span>));</span><br><span class="line">                comment.setString(<span class="keyword">new</span> <span class="title class_">HSSFRichTextString</span>(failDataMap.get(row.getRowNum()).getMsg()));</span><br><span class="line">                cell.setCellComment(comment);</span><br><span class="line">                cell.setCellStyle(cellStyle);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CellWriteHandler">CellWriteHandler</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CellWriteHandler</span> <span class="keyword">extends</span> <span class="title class_">WriteHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单元创建之前，可以使用该方法来设置单元格的样式、字体等信息。</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">beforeCellCreate</span><span class="params">(CellWriteHandlerContext context)</span> &#123;</span><br><span class="line">        beforeCellCreate(context.getWriteSheetHolder(), context.getWriteTableHolder(), context.getRow(),</span><br><span class="line">            context.getHeadData(), context.getColumnIndex(), context.getRelativeRowIndex(), context.getHead());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//单元创建之前，可以使用该方法来设置单元格的样式、字体等信息。</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">beforeCellCreate</span><span class="params">(WriteSheetHolder writeSheetHolder, WriteTableHolder writeTableHolder, Row row,</span></span><br><span class="line"><span class="params">        Head head, Integer columnIndex, Integer relativeRowIndex, Boolean isHead)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单元创建后，可以使用该方法来对单元格的内容进行一些处理，例如可以将单元格的内容转换为另一种格式</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">afterCellCreate</span><span class="params">(CellWriteHandlerContext context)</span> &#123;</span><br><span class="line">        afterCellCreate(context.getWriteSheetHolder(), context.getWriteTableHolder(), context.getCell(),</span><br><span class="line">            context.getHeadData(), context.getRelativeRowIndex(), context.getHead());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//单元创建后，可以使用该方法来对单元格的内容进行一些处理，例如可以将单元格的内容转换为另一种格式</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">afterCellCreate</span><span class="params">(WriteSheetHolder writeSheetHolder, WriteTableHolder writeTableHolder, Cell cell,</span></span><br><span class="line"><span class="params">        Head head, Integer relativeRowIndex, Boolean isHead)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//单元数据转换后，可以使用该方法来对单元格的数据进行一些处理，例如可以将单元格的数据转换为另一种类型</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">afterCellDataConverted</span><span class="params">(CellWriteHandlerContext context)</span> &#123;</span><br><span class="line">        WriteCellData&lt;?&gt; writeCellData = CollectionUtils.isNotEmpty(context.getCellDataList()) ? context</span><br><span class="line">            .getCellDataList().get(<span class="number">0</span>) : <span class="literal">null</span>;</span><br><span class="line">        afterCellDataConverted(context.getWriteSheetHolder(), context.getWriteTableHolder(), writeCellData,</span><br><span class="line">            context.getCell(), context.getHeadData(), context.getRelativeRowIndex(), context.getHead());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//单元数据转换后，可以使用该方法来对单元格的数据进行一些处理，例如可以将单元格的数据转换为另一种类型</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">afterCellDataConverted</span><span class="params">(WriteSheetHolder writeSheetHolder, WriteTableHolder writeTableHolder,</span></span><br><span class="line"><span class="params">        WriteCellData&lt;?&gt; cellData, Cell cell, Head head, Integer relativeRowIndex, Boolean isHead)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//单元格处理后（完成后），可以使用该方法来对单元格进行一些清理工作，例如可以释放单元格中使用的资源</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">afterCellDispose</span><span class="params">(CellWriteHandlerContext context)</span> &#123;</span><br><span class="line">        afterCellDispose(context.getWriteSheetHolder(), context.getWriteTableHolder(), context.getCellDataList(),</span><br><span class="line">            context.getCell(), context.getHeadData(), context.getRelativeRowIndex(), context.getHead());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//单元格处理后（完成后），可以使用该方法来对单元格进行一些清理工作，例如可以释放单元格中使用的资源</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">afterCellDispose</span><span class="params">(WriteSheetHolder writeSheetHolder, WriteTableHolder writeTableHolder,</span></span><br><span class="line"><span class="params">        List&lt;WriteCellData&lt;?&gt;&gt; cellDataList, Cell cell, Head head, Integer relativeRowIndex, Boolean isHead)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font style="color:rgb(49, 51, 63);">注意：</font></p>
<ol>
<li><font style="color:rgb(49, 51, 63);">这四个方法都是可选的，你可以根据自己的需要来实现它们。</font></li>
<li><font style="color:rgb(49, 51, 63);">这四个方法都是线程安全的，你可以放心地在多线程环境中使用它们。</font></li>
</ol>
<p><strong><font style="color:rgb(49, 51, 63);">区别</font></strong></p>
<ol>
<li><font style="color:rgb(49, 51, 63);">beforeCellCreate方法在单元格创建之前调用，而afterCellCreate方法在单元格创建之后调用。</font></li>
<li><font style="color:rgb(49, 51, 63);">afterCellDataConverted</font><font style="color:rgb(49, 51, 63);">方法在单元格数据转换之后调用，而</font><font style="color:rgb(49, 51, 63);">afterCellDispose</font><font style="color:rgb(49, 51, 63);">方法在单元格处理完成之后调用。</font></li>
<li><font style="color:rgb(49, 51, 63);">beforeCellCreate方法和afterCellCreate方法主要用于设置单元格的样式和内容，而afterCellDataConverted方法和afterCellDispose方法主要用于对单元格的数据进行处理。</font></li>
</ol>
<p><strong><font style="color:rgb(49, 51, 63);">使用案例</font></strong></p>
<p><font style="color:rgb(49, 51, 63);">如果你想在单元格头部添加背景色，你可以在</font><font style="color:rgb(49, 51, 63);">beforeCellCreate</font><font style="color:rgb(49, 51, 63);">方法中设置单元格的样式。如果你想将单元格中的数字转换为百分比，你可以在</font><font style="color:rgb(49, 51, 63);">afterCellDataConverted</font><font style="color:rgb(49, 51, 63);">方法中将单元格的数据转换为百分比。如果你想在单元格中添加超链接，你可以在</font><font style="color:rgb(49, 51, 63);">afterCellCreate</font><font style="color:rgb(49, 51, 63);">方法中添加超链接。</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCellCreate</span><span class="params">(WriteSheetHolder writeSheetHolder, WriteTableHolder writeTableHolder,</span></span><br><span class="line"><span class="params">                            Cell cell, Head head, Integer relativeRowIndex, Boolean isHead)</span> &#123;</span><br><span class="line">    <span class="type">Workbook</span> <span class="variable">workbook</span> <span class="operator">=</span> writeSheetHolder.getSheet().getWorkbook(); <span class="comment">// 获取 Workbook对象</span></span><br><span class="line">    <span class="type">CellStyle</span> <span class="variable">cellStyle</span> <span class="operator">=</span> workbook.createCellStyle(); <span class="comment">// 创建一个 CellStyle对象</span></span><br><span class="line">    <span class="keyword">if</span> (isHead) &#123; <span class="comment">// 如果是头，设置对应格式</span></span><br><span class="line">        <span class="type">WriteCellStyle</span> <span class="variable">headWriteCellStyle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WriteCellStyle</span>();</span><br><span class="line">        headWriteCellStyle.setFillPatternType(FillPatternType.SOLID_FOREGROUND);</span><br><span class="line">        headWriteCellStyle.setFillForegroundColor(IndexedColors.PALE_BLUE.getIndex());<span class="comment">// 背景设置</span></span><br><span class="line">        <span class="type">WriteFont</span> <span class="variable">headWriteFont</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WriteFont</span>();</span><br><span class="line">        headWriteFont.setFontHeightInPoints((<span class="type">short</span>) <span class="number">16</span>);</span><br><span class="line">        headWriteCellStyle.setWriteFont(headWriteFont);</span><br><span class="line"></span><br><span class="line">        cellStyle.setFillBackgroundColor(IndexedColors.PALE_BLUE.getIndex());</span><br><span class="line">        <span class="type">Font</span> <span class="variable">font</span> <span class="operator">=</span> workbook.createFont();</span><br><span class="line">        font.setFontName(<span class="string">&quot;宋体&quot;</span>);</span><br><span class="line">        font.setFontHeightInPoints((<span class="type">short</span>) <span class="number">16</span>);</span><br><span class="line">        font.setBold(<span class="literal">true</span>);</span><br><span class="line">        cellStyle.setFont(font);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 设置内容行列对应格式</span></span><br><span class="line">        <span class="keyword">if</span> (relativeRowIndex == <span class="number">0</span>) &#123; <span class="comment">// 如果是内容的第一行</span></span><br><span class="line">            cellStyle.setAlignment(HorizontalAlignment.LEFT);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 内容其它行</span></span><br><span class="line">            cellStyle.setAlignment(HorizontalAlignment.CENTER);</span><br><span class="line">        &#125;</span><br><span class="line">        cellStyle.setVerticalAlignment(VerticalAlignment.CENTER);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 边框</span></span><br><span class="line">        cellStyle.setBorderLeft(BorderStyle.THIN);<span class="comment">//细实线</span></span><br><span class="line">        cellStyle.setBorderTop(BorderStyle.THIN);</span><br><span class="line">        cellStyle.setBorderRight(BorderStyle.THIN);</span><br><span class="line">        cellStyle.setBorderBottom(BorderStyle.THIN);</span><br><span class="line">    &#125;</span><br><span class="line">    cell.setCellStyle(cellStyle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SheetWriteHandler">SheetWriteHandler</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SheetWriteHandler</span> <span class="keyword">extends</span> <span class="title class_">WriteHandler</span> &#123;</span><br><span class="line">    <span class="comment">//sheet创建之前</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">beforeSheetCreate</span><span class="params">(WriteWorkbookHolder var1, WriteSheetHolder var2)</span>;</span><br><span class="line">    <span class="comment">//sheet创建之后</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">afterSheetCreate</span><span class="params">(WriteWorkbookHolder var1, WriteSheetHolder var2)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用案例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySheetWriteHandler</span> <span class="keyword">implements</span> <span class="title class_">SheetWriteHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建sheet页前的操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> writeWorkbookHolder</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> writeSheetHolder</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeSheetCreate</span><span class="params">(WriteWorkbookHolder writeWorkbookHolder, WriteSheetHolder writeSheetHolder)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建sheet页后的操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> writeWorkbookHolder</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> writeSheetHolder</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterSheetCreate</span><span class="params">(WriteWorkbookHolder writeWorkbookHolder, WriteSheetHolder writeSheetHolder)</span> &#123;</span><br><span class="line">        <span class="comment">//定义选值范围</span></span><br><span class="line">        String[] sexStrings = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;男&quot;</span>, <span class="string">&quot;女&quot;</span>, <span class="string">&quot;未知&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//根据index，形成map，可插入多个  这个map可以由构造参数传入，毕竟不能写死</span></span><br><span class="line">        Map&lt;Integer, String[]&gt; mapDropDown = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        mapDropDown.put(<span class="number">2</span>, sexStrings);</span><br><span class="line">        <span class="comment">//获取sheet页</span></span><br><span class="line">        <span class="type">Sheet</span> <span class="variable">sheet</span> <span class="operator">=</span> writeSheetHolder.getSheet();</span><br><span class="line">        <span class="comment">///开始设置下拉框</span></span><br><span class="line">        <span class="type">DataValidationHelper</span> <span class="variable">helper</span> <span class="operator">=</span> sheet.getDataValidationHelper();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, String[]&gt; entry : mapDropDown.entrySet()) &#123;</span><br><span class="line">            <span class="comment">/***起始行、终止行、起始列、终止列**/</span></span><br><span class="line">            <span class="type">CellRangeAddressList</span> <span class="variable">addressList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CellRangeAddressList</span>(<span class="number">1</span>, <span class="number">9999</span>, entry.getKey(), entry.getKey());</span><br><span class="line">            <span class="comment">/***设置下拉框数据**/</span></span><br><span class="line">            <span class="type">DataValidationConstraint</span> <span class="variable">constraint</span> <span class="operator">=</span> helper.createExplicitListConstraint(entry.getValue());</span><br><span class="line">            <span class="type">DataValidation</span> <span class="variable">dataValidation</span> <span class="operator">=</span> helper.createValidation(constraint, addressList);</span><br><span class="line">            <span class="comment">/***处理Excel兼容性问题**/</span></span><br><span class="line">            <span class="keyword">if</span> (dataValidation <span class="keyword">instanceof</span> XSSFDataValidation) &#123;</span><br><span class="line">                dataValidation.setSuppressDropDownArrow(<span class="literal">true</span>);</span><br><span class="line">                dataValidation.setShowErrorBox(<span class="literal">true</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dataValidation.setSuppressDropDownArrow(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sheet.addValidationData(dataValidation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Excel</tag>
        <tag>EasyExcel</tag>
      </tags>
  </entry>
  <entry>
    <title>Quartz（1-Job）</title>
    <url>/blog/2024/11/12/Java/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/Quartz/Quartz%EF%BC%881-Job%EF%BC%89/</url>
    <content><![CDATA[<h2 id="基本使用">基本使用</h2>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.quartz-scheduler<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>quartz<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloJob</span> <span class="keyword">implements</span> <span class="title class_">Job</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(JobExecutionContext jobExecutionContext)</span> <span class="keyword">throws</span> JobExecutionException &#123;</span><br><span class="line">        <span class="comment">//实际触发时间。例如，计划时间可能是 10:00:00，但如果调度程序太忙，实际触发时间可能是 10:00:03。</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">fireTime</span> <span class="operator">=</span> jobExecutionContext.getFireTime();</span><br><span class="line">        System.out.println(<span class="string">&quot;fireTime:&quot;</span> + fireTime);</span><br><span class="line">        <span class="comment">//上次触发时间</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">previousFireTime</span> <span class="operator">=</span> jobExecutionContext.getPreviousFireTime();</span><br><span class="line">        System.out.println(<span class="string">&quot;previousFireTime:&quot;</span> + previousFireTime);</span><br><span class="line">        <span class="comment">//下次触发时间</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">nextFireTime</span> <span class="operator">=</span> jobExecutionContext.getNextFireTime();</span><br><span class="line">        System.out.println(<span class="string">&quot;nextFireTime:&quot;</span> + nextFireTime);</span><br><span class="line">        <span class="comment">//触发器触发的预定时间。</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">scheduledFireTime</span> <span class="operator">=</span> jobExecutionContext.getScheduledFireTime();</span><br><span class="line">        System.out.println(<span class="string">&quot;scheduledFireTime:&quot;</span> + scheduledFireTime);</span><br><span class="line"></span><br><span class="line">        <span class="type">JobDetail</span> <span class="variable">jobDetail</span> <span class="operator">=</span> jobExecutionContext.getJobDetail();</span><br><span class="line">        System.out.println(<span class="string">&quot;jobDataMap:&quot;</span> + JSON.toJSONString(jobDetail.getJobDataMap()));</span><br><span class="line">        System.out.println(<span class="string">&quot;jobKey:&quot;</span> + JSON.toJSONString(jobDetail.getKey()));</span><br><span class="line">        System.out.println(<span class="string">&quot;jobDescription:&quot;</span> + jobDetail.getDescription());</span><br><span class="line">        System.out.println(<span class="string">&quot;==================================&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SchedulerException &#123;</span><br><span class="line">        <span class="comment">//1.创建一个jobDetail的实例，将该实例与HelloJob Class绑定</span></span><br><span class="line">        <span class="type">JobDetail</span> <span class="variable">jobDetail</span> <span class="operator">=</span> JobBuilder</span><br><span class="line">                .newJob(HelloJob.class) <span class="comment">//定义Job类为HelloJob类，真正的执行逻辑所在</span></span><br><span class="line">                .withIdentity(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;group1&quot;</span>)</span><br><span class="line">                .withDescription(<span class="string">&quot;Quartz测试&quot;</span>)</span><br><span class="line">                .usingJobData(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;小米&quot;</span>)</span><br><span class="line">                .usingJobData(<span class="string">&quot;age&quot;</span>, <span class="number">15</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.创建一个Trigger触发器的实例，定义该job立即执行，并且每2秒执行一次，一直执行</span></span><br><span class="line">        <span class="type">SimpleTrigger</span> <span class="variable">trigger</span> <span class="operator">=</span> TriggerBuilder.newTrigger()</span><br><span class="line">                .withIdentity(<span class="string">&quot;myTrigger&quot;</span>, <span class="string">&quot;group1&quot;</span>)</span><br><span class="line">                .startNow() <span class="comment">//立即生效</span></span><br><span class="line">                .withSchedule(SimpleScheduleBuilder.simpleSchedule()</span><br><span class="line">                        .withIntervalInSeconds(<span class="number">2</span>) <span class="comment">//每2秒执行一次</span></span><br><span class="line">                        .repeatForever()) <span class="comment">//一直执行</span></span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">//3.创建schedule实例</span></span><br><span class="line">        <span class="type">StdSchedulerFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StdSchedulerFactory</span>();</span><br><span class="line">        <span class="type">Scheduler</span> <span class="variable">scheduler</span> <span class="operator">=</span> factory.getScheduler();</span><br><span class="line">        scheduler.start(); <span class="comment">//启动</span></span><br><span class="line">        scheduler.scheduleJob(jobDetail, trigger); <span class="comment">// jobDetail和trigger加入调度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="JobExecutionContext">JobExecutionContext</h2>
<p>当 Scheduler 调用一个 Job 就会将 JobExecutionContext 传递给 Job 的 execute()方法，Job 能通过 JobExecutionContext 对象访问到 Quartz 运行时候的环境和 Job 本身的明细数据</p>
<h2 id="JobDetail、JobBuilder">JobDetail、JobBuilder</h2>
<h3 id="方法">方法</h3>
<ol>
<li>storeDurably</li>
</ol>
<p>JobDetails 信息持久化到数据库的时候有一个属性 storeDurably，如果设置为 true 则无论与其关联的 Trigger 是否存在其都会一直存在，否则只要相关联的 trigger 删除掉了其会自动删除掉</p>
<ol start="2">
<li>requestRecovery</li>
</ol>
<p>请求恢复，也就是说当应用发生故障的时候，是否重新执行默认是 false。如果一个 job 是可恢复的，并且在其执行的时候，scheduler 发生硬关闭（hard shutdown)（比如运行的进程崩溃了，或者关机了），则当 scheduler 重新启动的时候，该 job 会被重新执行。此时，该 job 的 JobExecutionContext.isRecovering() 返回 true</p>
<ol start="3">
<li>usingJobData、setJobData</li>
</ol>
<p>添加 Job 数据，每个 JobDetail 内都有一个 JobDataMap，包含了关联到这个 Job 的数据，在 Job 类中，可以通过 context 取出该数据，进行业务流程处理。</p>
<ol start="4">
<li>withIdentity</li>
</ol>
<p>给 JobDetail 起一个 Id，方便后面检索</p>
<ol start="5">
<li>withDescription</li>
</ol>
<p>用来对 job 进行描述，并没有什么实际作用</p>
<h3 id="JobKey">JobKey</h3>
<p>JobKey 是表明 Job 身份的一个对象，里面封装了 Job 的 name 和 group，TriggerKey 同理。当不指定 group 时，Quartz 会用默认的组名 DEFAULT</p>
<h3 id="JobDataMap">JobDataMap</h3>
<p>JobDetail 是任务的定义，而 Job 是任务的执行逻辑，每一个 JobDetail 都会有一个 JobDataMap，JobDataMap 本质就是一个 Map 的扩展类，可以存储一些任务信息</p>
<h4 id="JobDataMap-获取任务信息">JobDataMap 获取任务信息</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloJob</span> <span class="keyword">implements</span> <span class="title class_">Job</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(JobExecutionContext jobExecutionContext)</span> <span class="keyword">throws</span> JobExecutionException &#123;</span><br><span class="line">        <span class="type">JobDetail</span> <span class="variable">jobDetail</span> <span class="operator">=</span> jobExecutionContext.getJobDetail();</span><br><span class="line">        <span class="type">JobDataMap</span> <span class="variable">jobDataMap</span> <span class="operator">=</span> jobDetail.getJobDataMap();</span><br><span class="line">        System.out.println(<span class="string">&quot;name:&quot;</span> + jobDataMap.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;age:&quot;</span> + jobDataMap.getInt(<span class="string">&quot;age&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;jobKey:&quot;</span> + JSON.toJSONString(jobDetail.getKey()));</span><br><span class="line">        System.out.println(<span class="string">&quot;jobDescription:&quot;</span> + jobDetail.getDescription());</span><br><span class="line">        System.out.println(<span class="string">&quot;==================================&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SchedulerException &#123;</span><br><span class="line">        <span class="comment">//1.创建一个jobDetail的实例，将该实例与HelloJob Class绑定</span></span><br><span class="line">        <span class="type">JobDetail</span> <span class="variable">jobDetail</span> <span class="operator">=</span> JobBuilder</span><br><span class="line">                .newJob(HelloJob.class) <span class="comment">//定义Job类为HelloJob类，真正的执行逻辑所在</span></span><br><span class="line">                .withIdentity(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;group1&quot;</span>)</span><br><span class="line">                .withDescription(<span class="string">&quot;Quartz测试&quot;</span>)</span><br><span class="line">                .usingJobData(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;小米&quot;</span>)</span><br><span class="line">                .usingJobData(<span class="string">&quot;age&quot;</span>, <span class="number">15</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.创建一个Trigger触发器的实例，定义该job立即执行，并且每2秒执行一次，一直执行</span></span><br><span class="line">        <span class="type">SimpleTrigger</span> <span class="variable">trigger</span> <span class="operator">=</span> TriggerBuilder.newTrigger()</span><br><span class="line">                .withIdentity(<span class="string">&quot;myTrigger&quot;</span>, <span class="string">&quot;group1&quot;</span>)</span><br><span class="line">                .startNow() <span class="comment">//立即生效</span></span><br><span class="line">                .withSchedule(SimpleScheduleBuilder.simpleSchedule()</span><br><span class="line">                        .withIntervalInSeconds(<span class="number">2</span>) <span class="comment">//每2秒执行一次</span></span><br><span class="line">                        .repeatForever()) <span class="comment">//一直执行</span></span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">//3.创建schedule实例</span></span><br><span class="line">        <span class="type">StdSchedulerFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StdSchedulerFactory</span>();</span><br><span class="line">        <span class="type">Scheduler</span> <span class="variable">scheduler</span> <span class="operator">=</span> factory.getScheduler();</span><br><span class="line">        scheduler.start(); <span class="comment">//启动</span></span><br><span class="line">        scheduler.scheduleJob(jobDetail, trigger); <span class="comment">// jobDetail和trigger加入调度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实体类获取任务信息">实体类获取任务信息</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloJob3</span> <span class="keyword">implements</span> <span class="title class_">Job</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span> Float floatJobValue;</span><br><span class="line">    <span class="keyword">private</span> Double doubleTriggerValue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Float <span class="title function_">getFloatJobValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> floatJobValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFloatJobValue</span><span class="params">(Float floatJobValue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.floatJobValue = floatJobValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Double <span class="title function_">getDoubleTriggerValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> doubleTriggerValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDoubleTriggerValue</span><span class="params">(Double doubleTriggerValue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.doubleTriggerValue = doubleTriggerValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(JobExecutionContext jobExecutionContext)</span> <span class="keyword">throws</span> JobExecutionException &#123;</span><br><span class="line">        <span class="comment">//打印当前的执行时间 例如 2017-11-22 00:00:00</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;现在的时间是：&quot;</span> + sf.format(date));</span><br><span class="line">        <span class="comment">//打印jobDataMap定义的message的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;jobDataMap定义的message的值 : &quot;</span> + message);</span><br><span class="line">        <span class="comment">//jobDataMap定义的floatJobValue的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;jobDataMap定义的floatJobValue的值 : &quot;</span> + floatJobValue);   </span><br><span class="line">		System.out.println(<span class="string">&quot;==================================&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SchedulerException &#123;</span><br><span class="line">        <span class="comment">//1.创建一个jobDetail的实例，将该实例与HelloJob Class绑定</span></span><br><span class="line">        <span class="type">JobDetail</span> <span class="variable">jobDetail</span> <span class="operator">=</span> JobBuilder</span><br><span class="line">                .newJob(HelloJob3.class) <span class="comment">//定义Job类为HelloJob类，真正的执行逻辑所在</span></span><br><span class="line">                .withIdentity(<span class="string">&quot;myJob&quot;</span>, <span class="string">&quot;group1&quot;</span>) <span class="comment">//定义name 和 group</span></span><br><span class="line">                .usingJobData(<span class="string">&quot;message&quot;</span>,<span class="string">&quot;hello myJob1&quot;</span>) <span class="comment">//加入属性到jobDataMap</span></span><br><span class="line">                .usingJobData(<span class="string">&quot;FloatJobValue&quot;</span>,<span class="number">8.88f</span>) <span class="comment">//加入属性到jobDataMap</span></span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.创建一个Trigger触发器的实例，定义该job立即执行，并且每2秒执行一次，一直执行</span></span><br><span class="line">        <span class="type">SimpleTrigger</span> <span class="variable">trigger</span> <span class="operator">=</span> TriggerBuilder.newTrigger()</span><br><span class="line">                .withIdentity(<span class="string">&quot;myTrigger&quot;</span>, <span class="string">&quot;group1&quot;</span>)</span><br><span class="line">                .startNow() <span class="comment">//立即生效</span></span><br><span class="line">                .withSchedule(SimpleScheduleBuilder.simpleSchedule()</span><br><span class="line">                        .withIntervalInSeconds(<span class="number">2</span>) <span class="comment">//每2秒执行一次</span></span><br><span class="line">                        .repeatForever()) <span class="comment">//一直执行</span></span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">//3.创建schedule实例</span></span><br><span class="line">        <span class="type">StdSchedulerFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StdSchedulerFactory</span>();</span><br><span class="line">        <span class="type">Scheduler</span> <span class="variable">scheduler</span> <span class="operator">=</span> factory.getScheduler();</span><br><span class="line">        scheduler.start(); <span class="comment">//启动</span></span><br><span class="line">        scheduler.scheduleJob(jobDetail,trigger); <span class="comment">// jobDetail和trigger加入调度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注解使用">注解使用</h2>
<h3 id="PersistJobDataAfterExecution">@PersistJobDataAfterExecution</h3>
<p>有状态的 Job 可以理解为多次 Job 调用期间可以持有一些状态信息，这些状态信息存储在 JobDataMap 中，而默认的无状态 Job 每次调用时都会创建一个新的 JobDataMap</p>
<p>注意：没有添加@PersistJobDataAfterExecution 注解，每次调用时都会创建一个新的 JobDataMap，不会累加；添加该注解后，多次调用期间可以持有一些状态信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PersistJobDataAfterExecution</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloJob4</span> <span class="keyword">implements</span> <span class="title class_">Job</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCount</span><span class="params">(Integer count)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(JobExecutionContext jobExecutionContext)</span> <span class="keyword">throws</span> JobExecutionException &#123;</span><br><span class="line">        System.out.println(++count);</span><br><span class="line">        jobExecutionContext.getJobDetail().getJobDataMap().put(<span class="string">&quot;count&quot;</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SchedulerException &#123;</span><br><span class="line">        <span class="comment">//1.创建一个jobDetail的实例，将该实例与HelloJob Class绑定</span></span><br><span class="line">        <span class="type">JobDetail</span> <span class="variable">jobDetail</span> <span class="operator">=</span> JobBuilder</span><br><span class="line">                .newJob(HelloJob4.class) <span class="comment">//定义Job类为HelloJob类，真正的执行逻辑所在</span></span><br><span class="line">                .withIdentity(<span class="string">&quot;myJob&quot;</span>, <span class="string">&quot;group1&quot;</span>) <span class="comment">//定义name 和 group</span></span><br><span class="line">                .usingJobData(<span class="string">&quot;count&quot;</span>,<span class="number">0</span>) <span class="comment">//加入属性到jobDataMap</span></span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.创建一个Trigger触发器的实例，定义该job立即执行，并且每2秒执行一次，一直执行</span></span><br><span class="line">        <span class="type">SimpleTrigger</span> <span class="variable">trigger</span> <span class="operator">=</span> TriggerBuilder.newTrigger()</span><br><span class="line">                .withIdentity(<span class="string">&quot;myTrigger&quot;</span>, <span class="string">&quot;group1&quot;</span>)</span><br><span class="line">                .startNow() <span class="comment">//立即生效</span></span><br><span class="line">                .withSchedule(SimpleScheduleBuilder.simpleSchedule()</span><br><span class="line">                        .withIntervalInSeconds(<span class="number">2</span>) <span class="comment">//每2秒执行一次</span></span><br><span class="line">                        .repeatForever()) <span class="comment">//一直执行</span></span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">//3.创建schedule实例</span></span><br><span class="line">        <span class="type">StdSchedulerFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StdSchedulerFactory</span>();</span><br><span class="line">        <span class="type">Scheduler</span> <span class="variable">scheduler</span> <span class="operator">=</span> factory.getScheduler();</span><br><span class="line">        scheduler.start(); <span class="comment">//启动</span></span><br><span class="line">        scheduler.scheduleJob(jobDetail,trigger); <span class="comment">// jobDetail和trigger加入调度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DisallowConcurrentExecution">@DisallowConcurrentExecution</h3>
<p>禁止并发执行多个相同定义的 JobDetail，这个注解是加在 Job 类上的，但意思并不是不能同时执行多个 Job，而是不能并发执行同一个 Job</p>
<p>例如：同一个 Job 实现类 DemoJob 的两个 JobDetail 实例 A 和 B，设置 A 的定时执行频率为每 1 分钟执行一次，A 的实际运行耗时为 3 分钟，B 的定时执行频率也是每 1 分钟执行一次，B 的实际运行耗时为 30 秒。假如在 07:00 分 00 秒时 A 和 B 同时第一次运行，则到 07:00 分 30 秒时 B 运行结束，此时 A 还在运行中，到 07:01 分 00 秒时 A 和 B 又该执行了，但是由于注解@DisallowConcurrentExecution 的缘故，此时 A 不会再次运行，A 只能在其上一次运行结束后才能再次被调用执行。但是 B 会正常运行（B 不受 A 的影响，注解@DisallowConcurrentExecution 是作用于 JobDetail 实例而不是 Job 实现类）</p>
<p>注意：如果你使用了@PersistJobDataAfterExecution 注解，则强烈建议你同时使用@DisallowConcurrentExecution 注解，因为当同一个 job（JobDetail）的两个实例被并发执行时，由于竞争，JobDataMap 中存储的数据很可能是不确定的。</p>
<p><strong>使用同一个Job对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DisallowConcurrentExecution</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloJob5</span> <span class="keyword">implements</span> <span class="title class_">Job</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(JobExecutionContext jobExecutionContext)</span> <span class="keyword">throws</span> JobExecutionException &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;现在的时间是：&quot;</span> + sf.format(date));</span><br><span class="line">        <span class="type">JobKey</span> <span class="variable">key</span> <span class="operator">=</span> jobExecutionContext.getJobDetail().getKey();</span><br><span class="line">        <span class="comment">//打印jobDetail 的name</span></span><br><span class="line">        System.out.println(<span class="string">&quot;jobDetail 的name ： &quot;</span> + key.getName());</span><br><span class="line">        <span class="comment">//打印jobDetail 的group</span></span><br><span class="line">        System.out.println(<span class="string">&quot;jobDetail 的group ： &quot;</span> + key.getGroup());</span><br><span class="line">        System.out.println(<span class="string">&quot;==============================&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SchedulerException &#123;</span><br><span class="line">        <span class="comment">//1.创建一个jobDetail的实例，将该实例与HelloJob Class绑定</span></span><br><span class="line">        <span class="type">JobDetail</span> <span class="variable">jobDetail1</span> <span class="operator">=</span> JobBuilder</span><br><span class="line">                .newJob(HelloJob5.class) <span class="comment">//定义Job类为HelloJob类，真正的执行逻辑所在</span></span><br><span class="line">                .withIdentity(<span class="string">&quot;group1&quot;</span>, <span class="string">&quot;group1&quot;</span>) <span class="comment">//定义name 和 group</span></span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.创建一个Trigger触发器的实例，定义该job立即执行，并且每2秒执行一次，一直执行</span></span><br><span class="line">        <span class="type">SimpleTrigger</span> <span class="variable">trigger1</span> <span class="operator">=</span> TriggerBuilder.newTrigger()</span><br><span class="line">                .withIdentity(<span class="string">&quot;myTrigger1&quot;</span>, <span class="string">&quot;group1&quot;</span>)</span><br><span class="line">                .startNow() <span class="comment">//立即生效</span></span><br><span class="line">                .withSchedule(SimpleScheduleBuilder.simpleSchedule()</span><br><span class="line">                        .withIntervalInSeconds(<span class="number">2</span>) <span class="comment">//每2秒执行一次</span></span><br><span class="line">                        .repeatForever()) <span class="comment">//一直执行</span></span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">//3.创建schedule实例</span></span><br><span class="line">        <span class="type">StdSchedulerFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StdSchedulerFactory</span>();</span><br><span class="line">        <span class="type">Scheduler</span> <span class="variable">scheduler</span> <span class="operator">=</span> factory.getScheduler();</span><br><span class="line">        scheduler.start(); <span class="comment">//启动</span></span><br><span class="line">        scheduler.scheduleJob(jobDetail1, trigger1); <span class="comment">// jobDetail和trigger加入调度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>使用@DisallowConcurrentExecution前</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line">现在的时间是：<span class="number">2024</span>-<span class="number">11</span>-<span class="number">12</span> <span class="number">00</span>:<span class="number">59</span>:<span class="number">49</span></span><br><span class="line">jobDetail 的name ： group1</span><br><span class="line">jobDetail 的group ： group1</span><br><span class="line">==============================</span><br><span class="line">现在的时间是：<span class="number">2024</span>-<span class="number">11</span>-<span class="number">12</span> <span class="number">00</span>:<span class="number">59</span>:<span class="number">52</span></span><br><span class="line">jobDetail 的name ： group1</span><br><span class="line">jobDetail 的group ： group1</span><br><span class="line">==============================</span><br><span class="line">现在的时间是：<span class="number">2024</span>-<span class="number">11</span>-<span class="number">12</span> <span class="number">00</span>:<span class="number">59</span>:<span class="number">55</span></span><br><span class="line">jobDetail 的name ： group1</span><br><span class="line">jobDetail 的group ： group1</span><br><span class="line">==============================</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>使用@DisallowConcurrentExecution后</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line">现在的时间是：<span class="number">2024</span>-<span class="number">11</span>-<span class="number">12</span> <span class="number">01</span>:<span class="number">00</span>:<span class="number">48</span></span><br><span class="line">jobDetail 的name ： group1</span><br><span class="line">jobDetail 的group ： group1</span><br><span class="line">==============================</span><br><span class="line">现在的时间是：<span class="number">2024</span>-<span class="number">11</span>-<span class="number">12</span> <span class="number">01</span>:<span class="number">00</span>:<span class="number">50</span></span><br><span class="line">jobDetail 的name ： group1</span><br><span class="line">jobDetail 的group ： group1</span><br><span class="line">==============================</span><br><span class="line">现在的时间是：<span class="number">2024</span>-<span class="number">11</span>-<span class="number">12</span> <span class="number">01</span>:<span class="number">00</span>:<span class="number">52</span></span><br><span class="line">jobDetail 的name ： group1</span><br><span class="line">jobDetail 的group ： group1</span><br><span class="line">==============================</span><br></pre></td></tr></table></figure>
<p><strong>创建两个 Job 对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DisallowConcurrentExecution</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloJob5</span> <span class="keyword">implements</span> <span class="title class_">Job</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(JobExecutionContext jobExecutionContext)</span> <span class="keyword">throws</span> JobExecutionException &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;现在的时间是：&quot;</span> + sf.format(date));</span><br><span class="line">        <span class="type">JobKey</span> <span class="variable">key</span> <span class="operator">=</span> jobExecutionContext.getJobDetail().getKey();</span><br><span class="line">        <span class="comment">//打印jobDetail 的name</span></span><br><span class="line">        System.out.println(<span class="string">&quot;jobDetail 的name ： &quot;</span> + key.getName());  </span><br><span class="line">        <span class="comment">//打印jobDetail 的group</span></span><br><span class="line">        System.out.println(<span class="string">&quot;jobDetail 的group ： &quot;</span> + key.getGroup());    </span><br><span class="line">        System.out.println(<span class="string">&quot;==============================&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SchedulerException &#123;</span><br><span class="line">        <span class="comment">//1.创建一个jobDetail的实例，将该实例与HelloJob Class绑定</span></span><br><span class="line">        <span class="type">JobDetail</span> <span class="variable">jobDetail1</span> <span class="operator">=</span> JobBuilder</span><br><span class="line">                .newJob(HelloJob5.class) <span class="comment">//定义Job类为HelloJob类，真正的执行逻辑所在</span></span><br><span class="line">                .withIdentity(<span class="string">&quot;group1&quot;</span>, <span class="string">&quot;group1&quot;</span>) <span class="comment">//定义name 和 group</span></span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.创建一个Trigger触发器的实例，定义该job立即执行，并且每2秒执行一次，一直执行</span></span><br><span class="line">        <span class="type">SimpleTrigger</span> <span class="variable">trigger1</span> <span class="operator">=</span> TriggerBuilder.newTrigger()</span><br><span class="line">                .withIdentity(<span class="string">&quot;myTrigger1&quot;</span>, <span class="string">&quot;group1&quot;</span>)</span><br><span class="line">                .startNow() <span class="comment">//立即生效</span></span><br><span class="line">                .withSchedule(SimpleScheduleBuilder.simpleSchedule()</span><br><span class="line">                        .withIntervalInSeconds(<span class="number">2</span>) <span class="comment">//每2秒执行一次</span></span><br><span class="line">                        .repeatForever()) <span class="comment">//一直执行</span></span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">//3.创建schedule实例</span></span><br><span class="line">        <span class="type">StdSchedulerFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StdSchedulerFactory</span>();</span><br><span class="line">        <span class="type">Scheduler</span> <span class="variable">scheduler</span> <span class="operator">=</span> factory.getScheduler();</span><br><span class="line">        scheduler.start(); <span class="comment">//启动</span></span><br><span class="line">        scheduler.scheduleJob(jobDetail1, trigger1); <span class="comment">// jobDetail和trigger加入调度</span></span><br><span class="line"></span><br><span class="line">        <span class="type">JobDetail</span> <span class="variable">jobDetail2</span> <span class="operator">=</span> JobBuilder</span><br><span class="line">                .newJob(HelloJob5.class) <span class="comment">//定义Job类为HelloJob类，真正的执行逻辑所在</span></span><br><span class="line">                .withIdentity(<span class="string">&quot;group2&quot;</span>, <span class="string">&quot;group2&quot;</span>) <span class="comment">//定义name 和 group</span></span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.创建一个Trigger触发器的实例，定义该job立即执行，并且每2秒执行一次，一直执行</span></span><br><span class="line">        <span class="type">SimpleTrigger</span> <span class="variable">trigger2</span> <span class="operator">=</span> TriggerBuilder.newTrigger()</span><br><span class="line">                .withIdentity(<span class="string">&quot;myTrigger2&quot;</span>, <span class="string">&quot;group2&quot;</span>)</span><br><span class="line">                .startNow() <span class="comment">//立即生效</span></span><br><span class="line">                .withSchedule(SimpleScheduleBuilder.simpleSchedule()</span><br><span class="line">                        .withIntervalInSeconds(<span class="number">3</span>) <span class="comment">//每3秒执行一次</span></span><br><span class="line">                        .repeatForever()) <span class="comment">//一直执行</span></span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">//3.创建schedule实例</span></span><br><span class="line">        <span class="type">Scheduler</span> <span class="variable">scheduler2</span> <span class="operator">=</span> factory.getScheduler();</span><br><span class="line">        scheduler2.start(); <span class="comment">//启动</span></span><br><span class="line">        scheduler2.scheduleJob(jobDetail2, trigger2); <span class="comment">// jobDetail和trigger加入调度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">现在的时间是：<span class="number">2024</span>-<span class="number">11</span>-<span class="number">12</span> <span class="number">01</span>:08:<span class="number">37</span></span><br><span class="line">现在的时间是：<span class="number">2024</span>-<span class="number">11</span>-<span class="number">12</span> <span class="number">01</span>:08:<span class="number">37</span></span><br><span class="line">jobDetail 的name ： group2</span><br><span class="line">jobDetail 的name ： group1</span><br><span class="line">jobDetail 的group ： group1</span><br><span class="line">jobDetail 的group ： group2</span><br><span class="line">==============================</span><br><span class="line">==============================</span><br><span class="line">现在的时间是：<span class="number">2024</span>-<span class="number">11</span>-<span class="number">12</span> <span class="number">01</span>:08:<span class="number">40</span></span><br><span class="line">jobDetail 的name ： group2</span><br><span class="line">jobDetail 的group ： group2</span><br><span class="line">==============================</span><br><span class="line">现在的时间是：<span class="number">2024</span>-<span class="number">11</span>-<span class="number">12</span> <span class="number">01</span>:08:<span class="number">40</span></span><br><span class="line">jobDetail 的name ： group1</span><br><span class="line">jobDetail 的group ： group1</span><br><span class="line">==============================</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>定时任务</tag>
        <tag>Quartz</tag>
      </tags>
  </entry>
  <entry>
    <title>Quartz（2-Trigger）</title>
    <url>/blog/2024/11/13/Java/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/Quartz/Quartz%EF%BC%882-Trigger%EF%BC%89/</url>
    <content><![CDATA[<h2 id="Trigger">Trigger</h2>
<h3 id="方法">方法</h3>
<ol>
<li>优先级（priority）</li>
</ol>
<p>如果你的 trigger 很多（或者 Quartz 线程池的工作线程太少），Quartz 可能没有足够的资源同时触发所有的 trigger；这种情况下，你可能希望控制哪些 trigger 优先使用 Quartz 的工作线程，要达到该目的，可以在 trigger 上设置 priority 属性。</p>
<p>比如，你有 N 个 trigger 需要同时触发，但只有 Z 个工作线程，优先级最高的 Z 个 trigger 会被首先触发</p>
<ol start="2">
<li>错过触发（misfire instructions）</li>
</ol>
<p>如果 scheduler 关闭了，或者 Quartz 线程池中没有可用的线程来执行 job，此时持久性的 trigger 就会错过(miss)其触发时间，即错过触发(misfire)。当下次调度器启动或者有可以线程时，会检查处于 misfire 状态的 Trigger。而 misfire 的状态值决定了调度器如何处理这个 Trigger。</p>
<p>不同类型的 trigger，有不同的 misfire 机制。它们默认都使用“智能机制（smart policy）”，即根据 trigger 的类型和配置动态调整行为</p>
<h3 id="分类">分类</h3>
<p><img src="1.png" alt=""></p>
<h2 id="SimpleTrigger">SimpleTrigger</h2>
<p>为需要在特定的日期/时间启动，且以一个可能的间隔时间重复执行 n 次的 job 所设计的</p>
<ol>
<li>startNow()：Scheduler 开始执行时，触发器也即执行</li>
<li>startAt()：在指定的时间开始执行</li>
<li>endAt()：结束时间</li>
</ol>
<p>执行间隔：</p>
<ol>
<li>withInterval(TimeSpan timeSpan)：通用的间隔执行方法</li>
<li>withIntervalInHours(int hours)：以小时为间隔单位进行执行</li>
<li>withIntervalInMinutes(int minutes)：以分钟为间隔单位进行执行</li>
<li>withIntervalInSeconds(int seconds)：以秒为间隔单位进行执行</li>
</ol>
<p>执行时间：</p>
<ol>
<li>withRepeatCount(int repeatCount)：执行多少次以后结束</li>
<li>repeatForever()：永远执行</li>
<li>repeatMinutelyForever()：一分钟执行一次(永远执行)</li>
<li>repeatMinutelyForever(int minutes)：每隔几分钟执行一次(永远执行)</li>
<li>repeatMinutelyForTotalCount(int count, int minutes)：每隔几分钟执行一次(执行次数为 count)类似的还有秒、小时。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Trigger1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SchedulerException &#123;</span><br><span class="line">        <span class="comment">//创建一个 JobDetail 的实例，将该实例与 HelloJob 绑定</span></span><br><span class="line">        <span class="type">JobDetail</span> <span class="variable">jobDetail</span> <span class="operator">=</span> JobBuilder.newJob(HelloJob.class)</span><br><span class="line">                .withIdentity(<span class="string">&quot;testJob&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">//开始时间 3 秒钟之后 （具体时间按实际业务编写）</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">sData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        sData.setTime(sData.getTime() + <span class="number">3000</span>);</span><br><span class="line">        <span class="comment">//结束时间 20 秒钟之后 （具体时间按实际业务编写）</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">eData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        eData.setTime(eData.getTime() + <span class="number">20000</span>);</span><br><span class="line">        <span class="comment">//创建一个 Trigger 实例，定义该 job3 秒之后执行，在 6 秒之后结束</span></span><br><span class="line">        <span class="type">SimpleTrigger</span> <span class="variable">zhlTrigger</span> <span class="operator">=</span> TriggerBuilder.newTrigger()</span><br><span class="line">                    .withIdentity(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">                    .startAt(sData) <span class="comment">//设定开始时间</span></span><br><span class="line">                    .endAt(eData)   <span class="comment">//设定结束时间</span></span><br><span class="line">                    .withSchedule(SimpleScheduleBuilder.simpleSchedule()</span><br><span class="line">                            .withIntervalInSeconds(<span class="number">2</span>) <span class="comment">//每两秒打印一次</span></span><br><span class="line">                            .withRepeatCount(<span class="number">2</span>)) <span class="comment">// 重复 2 次</span></span><br><span class="line">                    .build();</span><br><span class="line">        <span class="comment">//创建 Scheduler 实例</span></span><br><span class="line">        <span class="type">StdSchedulerFactory</span> <span class="variable">stdSchedulerFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StdSchedulerFactory</span>();</span><br><span class="line">        <span class="type">Scheduler</span> <span class="variable">scheduler</span> <span class="operator">=</span> stdSchedulerFactory.getScheduler();</span><br><span class="line">        scheduler.start();</span><br><span class="line">        scheduler.scheduleJob(jobDetail, zhlTrigger);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloJob</span> <span class="keyword">implements</span> <span class="title class_">Job</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(JobExecutionContext jobExecutionContext)</span> <span class="keyword">throws</span> JobExecutionException &#123;</span><br><span class="line">        <span class="comment">//打印当前的执行时间 例如 2017-11-22 00:00:00</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;现在的时间是：&quot;</span>+ sf.format(date));</span><br><span class="line">        <span class="comment">//具体的业务逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;具体执行的业务...&quot;</span>);</span><br><span class="line">        <span class="type">JobKey</span> <span class="variable">key</span> <span class="operator">=</span> jobExecutionContext.getJobDetail().getKey();</span><br><span class="line">        <span class="type">Trigger</span> <span class="variable">trigger</span> <span class="operator">=</span> jobExecutionContext.getTrigger();</span><br><span class="line">        System.out.println(<span class="string">&quot;开始的时间：&quot;</span>+sf.format(trigger.getStartTime()));</span><br><span class="line">        System.out.println(<span class="string">&quot;结束的事件：&quot;</span>+sf.format(trigger.getEndTime()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CronTrigger">CronTrigger</h2>
<p>指定对应的 cron 表达式执行任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Trigger2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SchedulerException &#123;</span><br><span class="line">        <span class="comment">//创建一个 JobDetail 的实例，将该实例与 HelloJob 绑定</span></span><br><span class="line">        <span class="type">JobDetail</span> <span class="variable">jobDetail</span> <span class="operator">=</span> JobBuilder.newJob(HelloJob.class)</span><br><span class="line">                .withIdentity(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">//开始时间 3 秒钟之后 （具体时间按实际业务编写）</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">sData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        sData.setTime(sData.getTime() + <span class="number">3000</span>);</span><br><span class="line">        <span class="comment">//结束时间 20 秒钟之后 （具体时间按实际业务编写）</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">eData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        eData.setTime(eData.getTime() + <span class="number">20000</span>);</span><br><span class="line">        <span class="comment">//创建一个 Trigger 实例，定义该 job3 秒之后执行，在 6 秒之后结束</span></span><br><span class="line">        <span class="type">CronTrigger</span> <span class="variable">trigger</span> <span class="operator">=</span> TriggerBuilder.newTrigger()</span><br><span class="line">                .withIdentity(<span class="string">&quot;testTrigger&quot;</span>)</span><br><span class="line">                .startAt(sData) <span class="comment">//设定开始时间</span></span><br><span class="line">                .endAt(eData)   <span class="comment">//设定结束时间</span></span><br><span class="line">                .withSchedule(CronScheduleBuilder.cronSchedule(<span class="string">&quot;0/3 * * * * ?&quot;</span>))</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">//创建 Scheduler 实例</span></span><br><span class="line">        <span class="type">StdSchedulerFactory</span> <span class="variable">stdSchedulerFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StdSchedulerFactory</span>();</span><br><span class="line">        <span class="type">Scheduler</span> <span class="variable">scheduler</span> <span class="operator">=</span> stdSchedulerFactory.getScheduler();</span><br><span class="line">        scheduler.start();</span><br><span class="line">        scheduler.scheduleJob(jobDetail, trigger);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CalendarIntervalTrigger">CalendarIntervalTrigger</h2>
<p>用来触发基于定时重复的 JobDetail，Trigger 将会每隔 N 个 Calendar 在 Trigger 中定义的时间单元触发一次，这个 Trigger 不适合使用 SimpleTrigger 完成（例如由于每一个月的时间不是固定的描述），也不适用于 CronTrigger（例如每 5 个月）</p>
<p>相较于 SimpleTrigger 有两个优势：</p>
<ol>
<li>更方便，比如：每隔 1 小时执行，你不用自己去计算 1 小时等于多少毫秒。</li>
<li>支持不是固定长度的间隔，比如：间隔为月和年。但劣势是精度只能到秒。</li>
</ol>
<p>参数：</p>
<ol>
<li>interval：执行间隔</li>
<li>intervalUnit：执行间隔的单位（秒、分钟、小时、天、月、年、星期）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Trigger4</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SchedulerException &#123;</span><br><span class="line">        <span class="comment">//创建一个 JobDetail 的实例，将该实例与 HelloJob 绑定</span></span><br><span class="line">        <span class="type">JobDetail</span> <span class="variable">jobDetail</span> <span class="operator">=</span> JobBuilder.newJob(HelloJob.class)</span><br><span class="line">                .withIdentity(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">//开始时间 3 秒钟之后 （具体时间按实际业务编写）</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">sData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        sData.setTime(sData.getTime() + <span class="number">3000</span>);</span><br><span class="line">        <span class="comment">//结束时间 20 秒钟之后 （具体时间按实际业务编写）</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">eData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        eData.setTime(eData.getTime() + <span class="number">20000</span>);</span><br><span class="line">        <span class="comment">//创建一个 Trigger 实例，定义该 job3 秒之后执行，在 20 秒之后结束</span></span><br><span class="line">        <span class="type">CalendarIntervalTrigger</span> <span class="variable">intervalTrigger</span> <span class="operator">=</span> TriggerBuilder.newTrigger()</span><br><span class="line">                .withIdentity(<span class="string">&quot;testTrigger&quot;</span>)</span><br><span class="line">                .startAt(sData) <span class="comment">//设定开始时间</span></span><br><span class="line">                .endAt(eData)   <span class="comment">//设定结束时间</span></span><br><span class="line">                .withSchedule(CalendarIntervalScheduleBuilder.calendarIntervalSchedule()</span><br><span class="line">                        .withIntervalInSeconds(<span class="number">5</span>))	<span class="comment">// 每隔 5 秒执行一次</span></span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">//创建 Scheduler 实例</span></span><br><span class="line">        <span class="type">StdSchedulerFactory</span> <span class="variable">stdSchedulerFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StdSchedulerFactory</span>();</span><br><span class="line">        <span class="type">Scheduler</span> <span class="variable">scheduler</span> <span class="operator">=</span> stdSchedulerFactory.getScheduler();</span><br><span class="line">        scheduler.start();</span><br><span class="line">        scheduler.scheduleJob(jobDetail, intervalTrigger);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="DailyTimeIntervalTrigger">DailyTimeIntervalTrigger</h2>
<p>指定每天的某个时间段内，以一定的时间间隔执行任务，并且可以支持星期的设置</p>
<p>适合的任务类似于：指定每天 9：00 至 18：00，每隔 10 秒执行一次，并且只要周一至周五执行</p>
<p>参数：</p>
<ol>
<li>onEveryDay：每天</li>
<li>onMondayThroughFriday：周一至周五，即工作日</li>
<li>onSaturdayAndSunday：周六至周天，即休息日 e</li>
<li>onDaysOfTheWeek：用数组的形式单独来指定一周中的哪几天</li>
<li>startingDailyAt：表示开始于几点 （区别于前面的 StartAt）</li>
<li>endingDailyAt：表示结束于几点 （区别于前面的 EndAt）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Trigger3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SchedulerException &#123;</span><br><span class="line">        <span class="comment">//创建一个 JobDetail 的实例，将该实例与 HelloJob 绑定</span></span><br><span class="line">        <span class="type">JobDetail</span> <span class="variable">jobDetail</span> <span class="operator">=</span> JobBuilder.newJob(HelloJob.class)</span><br><span class="line">                .withIdentity(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">//开始时间 3 秒钟之后 （具体时间按实际业务编写）</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">sData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        sData.setTime(sData.getTime() + <span class="number">3000</span>);</span><br><span class="line">        <span class="comment">//结束时间 20 秒钟之后 （具体时间按实际业务编写）</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">eData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        eData.setTime(eData.getTime() + <span class="number">20000</span>);</span><br><span class="line">        <span class="comment">//创建一个 Trigger 实例，定义该 job3 秒之后执行，在 20 秒之后结束</span></span><br><span class="line">        <span class="type">DailyTimeIntervalTrigger</span> <span class="variable">trigger</span> <span class="operator">=</span> TriggerBuilder.newTrigger()</span><br><span class="line">                .withIdentity(<span class="string">&quot;testTrigger&quot;</span>)</span><br><span class="line">                .startAt(sData) <span class="comment">//设定开始时间</span></span><br><span class="line">                .endAt(eData)   <span class="comment">//设定结束时间</span></span><br><span class="line">                .withSchedule(DailyTimeIntervalScheduleBuilder.dailyTimeIntervalSchedule()</span><br><span class="line">                        .withIntervalInSeconds(<span class="number">3</span>)</span><br><span class="line">                        .onEveryDay()) <span class="comment">//每天每隔 3 秒执行一次</span></span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">//创建 Scheduler 实例</span></span><br><span class="line">        <span class="type">StdSchedulerFactory</span> <span class="variable">stdSchedulerFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StdSchedulerFactory</span>();</span><br><span class="line">        <span class="type">Scheduler</span> <span class="variable">scheduler</span> <span class="operator">=</span> stdSchedulerFactory.getScheduler();</span><br><span class="line">        scheduler.start();</span><br><span class="line">        scheduler.scheduleJob(jobDetail, trigger);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="MutableTrigger">MutableTrigger</h2>
<p>Trigger 只是定义了相关属性的 Get 方法，并没有 Set 方法，而 MutableTrigger 接口则定义了相关属性的 set 方法，如：setKey 方法。</p>
<h2 id="OperableTrigger">OperableTrigger</h2>
<p>OperableTrigger 接口从字面上来说时可操作的 Trigger，也就是 Trigger 被 QuartzSchedulerThread 获取到之后，在不同情况下需要进行操作的接口。</p>
<ol>
<li>computeFirstFireTime：计算第一次触发时间。</li>
<li>triggered：trigger 被触发时调用的方法。</li>
<li>updateAfterMisfire：对应触发器失火后调用的方法。</li>
<li>executionComplete：触发器本次触发完成时被调用的方法。</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>定时任务</tag>
        <tag>Quartz</tag>
      </tags>
  </entry>
  <entry>
    <title>Quartz（3-Scheduler）</title>
    <url>/blog/2024/11/14/Java/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/Quartz/Quartz%EF%BC%883-Scheduler%EF%BC%89/</url>
    <content><![CDATA[<h2 id="BaseCalendar">BaseCalendar</h2>
<p>专门用于屏蔽一个时间区间，使 Trigger 在这个区间中不被触发</p>
<p><img src="1.png" alt=""></p>
<h3 id="AnnualCalendar">AnnualCalendar</h3>
<p>排除每一年中指定的一天或多少天，精度是天</p>
<h3 id="CronCalendar">CronCalendar</h3>
<p>使用表达式排除某些时间段不执行，精度取决于 Cron 表达式，最大精度到秒</p>
<h3 id="DailyCalendar">DailyCalendar</h3>
<p>指定的时间范围内的每一天不执行，指定每天的时间段，格式是 HH: MM [: SS[mmm]]，即最大精度可以到毫秒</p>
<h3 id="HolidayCalendar">HolidayCalendar</h3>
<p>排除节假日，精度到天</p>
<h3 id="MonthlyCalendar">MonthlyCalendar</h3>
<p>排除月份中的数天，可选值为 1-31，精度是天</p>
<h3 id="WeeklyCalendar">WeeklyCalendar</h3>
<p>排除星期中的一天或多天，可选值比如为：java.util.Calendar.SUNDAY，精度是天</p>
<h3 id="基本使用">基本使用</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalendarSchedule</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SchedulerException &#123;</span><br><span class="line">        <span class="comment">//创建一个 JobDetail 的实例，将该实例与 HelloJob 绑定</span></span><br><span class="line">        <span class="type">JobDetail</span> <span class="variable">jobDetail</span> <span class="operator">=</span> JobBuilder.newJob(HelloJob.class)</span><br><span class="line">                                .withIdentity(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">                                .build();</span><br><span class="line">        <span class="type">AnnualCalendar</span> <span class="variable">holidays</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnualCalendar</span>();</span><br><span class="line">        <span class="comment">// 排除今天的时间 2017 年 11 月 27 日（月份是从 0～11 的）</span></span><br><span class="line">        <span class="type">GregorianCalendar</span> <span class="variable">nationalDay</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GregorianCalendar</span>(<span class="number">2017</span>, <span class="number">10</span>, <span class="number">27</span>);  </span><br><span class="line">        <span class="comment">// 排除的日期，如果为 false 则为包含</span></span><br><span class="line">        holidays.setDayExcluded(nationalDay,<span class="literal">true</span>); </span><br><span class="line"></span><br><span class="line">        <span class="type">Trigger</span> <span class="variable">simpleTrigger</span> <span class="operator">=</span> TriggerBuilder.newTrigger()</span><br><span class="line">                .withIdentity(<span class="string">&quot;testTrigger&quot;</span>)</span><br><span class="line">                .withSchedule(SimpleScheduleBuilder.simpleSchedule()</span><br><span class="line">                              .withIntervalInSeconds(<span class="number">1</span>)</span><br><span class="line">                              .repeatForever()) <span class="comment">//每一秒执行一次 job</span></span><br><span class="line">                .modifiedByCalendar(<span class="string">&quot;holidays&quot;</span>)   <span class="comment">//将我们设置好的 Calander 与 trigger 绑定</span></span><br><span class="line">                .build();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建 Scheduler 实例</span></span><br><span class="line">        <span class="type">StdSchedulerFactory</span> <span class="variable">stdSchedulerFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StdSchedulerFactory</span>();</span><br><span class="line">        <span class="type">Scheduler</span> <span class="variable">scheduler</span> <span class="operator">=</span> stdSchedulerFactory.getScheduler();</span><br><span class="line">        <span class="comment">//向 Scheduler 注册日历</span></span><br><span class="line">        scheduler.addCalendar(<span class="string">&quot;holidays&quot;</span>,holidays,<span class="literal">false</span>,<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//让 trigger 应用指定的日历规则</span></span><br><span class="line">        scheduler.scheduleJob(jobDetail,simpleTrigger);</span><br><span class="line">        scheduler.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="定时任务增删改查">定时任务增删改查</h2>
<p><strong>参考 Scheduler 源码中的方法</strong></p>
<p>通过配置文件定义每个任务的属性，项目启动后将每个任务加载到内存中，将其中一个任务用来监听配置文件的修改，当其修改后动态刷新任务</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定时任务</span></span><br><span class="line"><span class="attr">quartz:</span></span><br><span class="line">  <span class="attr">jobs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myName</span> <span class="comment">#（随便取任务名）</span></span><br><span class="line">      <span class="attr">group:</span> <span class="string">collect</span></span><br><span class="line">      <span class="attr">cron:</span> <span class="number">0</span> <span class="number">0</span><span class="string">/5</span> <span class="string">*</span> <span class="string">*</span> <span class="string">*</span> <span class="string">?</span> <span class="string">*</span></span><br><span class="line">      <span class="attr">jobClass:</span> <span class="string">com.gamer.me.quartz.jobs.MyJob</span> <span class="comment">#（自己的定时任务的执行类，也就是你写业务代码的类）</span></span><br><span class="line">      <span class="attr">desc:</span> <span class="string">我的任务</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SchedulerJob</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String group;</span><br><span class="line">    <span class="keyword">private</span> String cron;</span><br><span class="line">    <span class="keyword">private</span> String jobClass;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;quartz&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SchedulerJobs</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;SchedulerJob&gt; jobs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SchedulerManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Scheduler scheduler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 激活任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> schedulerJob</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">activeJob</span><span class="params">(SchedulerJob schedulerJob)</span>&#123;</span><br><span class="line">        <span class="type">JobKey</span> <span class="variable">jobKey</span> <span class="operator">=</span> JobKey.jobKey(schedulerJob.getName(), schedulerJob.getGroup());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (scheduler.checkExists(jobKey) &amp;&amp; !MonitorCronJob.JOB_NAME.equals(schedulerJob.getName())) &#123;</span><br><span class="line">                updateJob(schedulerJob);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                createJob(schedulerJob);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SchedulerException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;activeJob &#123;&#125;&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建任务并加入调度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> schedulerJob</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createJob</span><span class="params">(SchedulerJob schedulerJob)</span>&#123;</span><br><span class="line">        <span class="type">JobKey</span> <span class="variable">jobKey</span> <span class="operator">=</span> JobKey.jobKey(schedulerJob.getName(), schedulerJob.getGroup());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (scheduler.checkExists(jobKey)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(schedulerJob.getJobClass());</span><br><span class="line">            <span class="type">JobDetail</span> <span class="variable">jobDetail</span> <span class="operator">=</span> getJobDetail(schedulerJob, (Class&lt;Job&gt;) clazz);</span><br><span class="line">            <span class="type">Trigger</span> <span class="variable">cronTrigger</span> <span class="operator">=</span> getCronTrigger(schedulerJob);</span><br><span class="line">            <span class="comment">//加入调度器</span></span><br><span class="line">            scheduler.scheduleJob(jobDetail, cronTrigger);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException | SchedulerException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;createJob &#123;&#125;&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新任务触发器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> schedulerJob</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateJob</span><span class="params">(SchedulerJob schedulerJob)</span>&#123;</span><br><span class="line">        <span class="type">TriggerKey</span> <span class="variable">triggerKey</span> <span class="operator">=</span> TriggerKey.triggerKey(schedulerJob.getName(), schedulerJob.getGroup());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Trigger</span> <span class="variable">trigger</span> <span class="operator">=</span> scheduler.getTrigger(triggerKey);</span><br><span class="line">            <span class="keyword">if</span> (trigger == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">JobKey</span> <span class="variable">jobKey</span> <span class="operator">=</span> trigger.getJobKey();</span><br><span class="line">            <span class="comment">//查询 cron</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">oldCron</span> <span class="operator">=</span> ((CronTrigger)trigger).getCronExpression();</span><br><span class="line">            <span class="comment">//没有变化则返回</span></span><br><span class="line">            <span class="keyword">if</span> (oldCron.equals(schedulerJob.getCron()))&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Trigger</span> <span class="variable">cronTrigger</span> <span class="operator">=</span> getCronTrigger(schedulerJob);</span><br><span class="line">            <span class="comment">//加入调度器</span></span><br><span class="line">            scheduler.rescheduleJob(triggerKey, cronTrigger);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SchedulerException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;updateJob &#123;&#125;&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteJobs</span><span class="params">(List&lt;JobKey&gt; jobKeys)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            scheduler.deleteJobs(jobKeys);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SchedulerException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;deleteJobs &#123;&#125;&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> schedulerJob</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> JobDetail <span class="title function_">getJobDetail</span><span class="params">(SchedulerJob schedulerJob, Class&lt;Job&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> JobBuilder.newJob()</span><br><span class="line">                .ofType(clazz)</span><br><span class="line">                .withIdentity(schedulerJob.getName(), schedulerJob.getGroup())</span><br><span class="line">                .withDescription(schedulerJob.getDesc())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建触发器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> schedulerJob</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Trigger <span class="title function_">getCronTrigger</span><span class="params">(SchedulerJob schedulerJob)</span> &#123;</span><br><span class="line">        <span class="type">CronScheduleBuilder</span> <span class="variable">cronScheduleBuilder</span> <span class="operator">=</span> CronScheduleBuilder.cronSchedule(schedulerJob.getCron());</span><br><span class="line">        <span class="keyword">if</span> (!MonitorCronJob.JOB_NAME.equals(schedulerJob.getName()))&#123;</span><br><span class="line">            <span class="comment">//任务错过执行策略，以错过的第一个频率时间立刻开始执行，重做错过的所有频率周期后，当下一次触发频率发生时间大于当前时间后，再按照正常的 Cron 频率依次执行</span></span><br><span class="line">            cronScheduleBuilder.withMisfireHandlingInstructionIgnoreMisfires();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> TriggerBuilder.newTrigger()</span><br><span class="line">                .withIdentity(schedulerJob.getName(), schedulerJob.getGroup())</span><br><span class="line">                .withDescription(schedulerJob.getDesc())</span><br><span class="line">                .withSchedule(cronScheduleBuilder)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>监控其他定时任务的总任务 MonitorCronJob（用于监控 cron 的更新）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MonitorCronJob</span> <span class="keyword">implements</span> <span class="title class_">Job</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">JOB_NAME</span> <span class="operator">=</span> <span class="string">&quot;monitor_cron&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">GROUP_NAME</span> <span class="operator">=</span> <span class="string">&quot;monitor&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CRON</span> <span class="operator">=</span> <span class="string">&quot;0 0/10 * * * ?&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DESC</span> <span class="operator">=</span> <span class="string">&quot;监控cron更新&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SchedulerManager schedulerManager;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SchedulerJobs schedulerJobs;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ContextRefresher contextRefresher;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(JobExecutionContext jobExecutionContext)</span> <span class="keyword">throws</span> JobExecutionException &#123;</span><br><span class="line">        <span class="comment">//重新加载配置</span></span><br><span class="line">        contextRefresher.refresh();</span><br><span class="line">        Set&lt;JobKey&gt; oldJobKeys = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oldJobKeys = jobExecutionContext.getScheduler().getJobKeys(GroupMatcher.anyJobGroup());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SchedulerException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;MonitorCronJob &#123;&#125;&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; newJobKeys = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (SchedulerJob job : schedulerJobs.getJobs()) &#123;</span><br><span class="line">            <span class="comment">//过滤掉 monitor_cron 任务</span></span><br><span class="line">            <span class="keyword">if</span> (job.getName().equals(JOB_NAME)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            newJobKeys.add(job.getName());</span><br><span class="line">            logger.info(<span class="string">&quot;job【&#123;&#125;】,cron【&#123;&#125;】&quot;</span>, job.getName(), job.getCron());</span><br><span class="line">            schedulerManager.activeJob(job);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (oldJobKeys == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除没有配置的任务</span></span><br><span class="line">        List&lt;JobKey&gt; shouldDeleteJobKeys = oldJobKeys.stream()</span><br><span class="line">                .filter(jobKey -&gt; !JOB_NAME.equals(jobKey.getName()) &amp;&amp; !newJobKeys.contains(jobKey.getName()))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        logger.info(<span class="string">&quot;delete jobs &#123;&#125;&quot;</span>, shouldDeleteJobKeys);</span><br><span class="line">        schedulerManager.deleteJobs(shouldDeleteJobKeys);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Initialization</span> <span class="keyword">implements</span> <span class="title class_">ApplicationRunner</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SchedulerManager schedulerManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SchedulerJob</span> <span class="variable">schedulerJob</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SchedulerJob</span>();</span><br><span class="line">        schedulerJob.setName(MonitorCronJob.JOB_NAME);</span><br><span class="line">        schedulerJob.setGroup(MonitorCronJob.GROUP_NAME);</span><br><span class="line">        schedulerJob.setCron(MonitorCronJob.CRON);</span><br><span class="line">        schedulerJob.setDesc(MonitorCronJob.DESC);</span><br><span class="line">        schedulerJob.setJobClass(MonitorCronJob.class.getName());</span><br><span class="line">        schedulerManager.activeJob(schedulerJob);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SchedulerRepository-详解">SchedulerRepository 详解</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 保持对调度器实例的引用-确保唯一性，以及防止垃圾收集，并允许“全球”查找-所有在一个类加载器空间。</span></span><br><span class="line"><span class="comment"> * 调度程序库，采用单例模式存储任务调度 Schedule</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SchedulerRepository</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Scheduler&gt; schedulers;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SchedulerRepository inst;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SchedulerRepository</span><span class="params">()</span> &#123;</span><br><span class="line">        schedulers = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Scheduler&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SchedulerRepository <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (inst == <span class="literal">null</span>) &#123;</span><br><span class="line">            inst = <span class="keyword">new</span> <span class="title class_">SchedulerRepository</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> inst;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定新的任务调度器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Scheduler sched)</span> <span class="keyword">throws</span> SchedulerException &#123;</span><br><span class="line">        <span class="keyword">if</span> ((Scheduler) schedulers.get(sched.getSchedulerName()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SchedulerException</span>(<span class="string">&quot;Scheduler with name &#x27;&quot;</span></span><br><span class="line">                    + sched.getSchedulerName() + <span class="string">&quot;&#x27; already exists.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        schedulers.put(sched.getSchedulerName(), sched);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除新的任务调度器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(String schedName)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (schedulers.remove(schedName) != <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询新的任务调度器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Scheduler <span class="title function_">lookup</span><span class="params">(String schedName)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> schedulers.get(schedName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有任务调度器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Collection&lt;Scheduler&gt; <span class="title function_">lookupAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> java.util.Collections.unmodifiableCollection(schedulers.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="StdSchedulerFactory-详解">StdSchedulerFactory 详解</h2>
<p>SchedulerFacotory 是一个接口，它有两个实现：</p>
<ol>
<li>StdSchedulerFacotory 通过配置文件来设置 Scheduler 的各项参数</li>
<li>DirectSchedulerFactory 主要通过硬编码来设置 Scheduler 的各项参数</li>
</ol>
<h3 id="构造方法">构造方法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">StdSchedulerFactory</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">StdSchedulerFactory</span><span class="params">(Properties props)</span> <span class="keyword">throws</span> SchedulerException &#123;</span><br><span class="line">    initialize(props);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">StdSchedulerFactory</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> SchedulerException &#123;</span><br><span class="line">    initialize(fileName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="getScheduler">getScheduler()</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加载 quartz.properties，初始化 StdScheduler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Scheduler <span class="title function_">getScheduler</span><span class="params">()</span> <span class="keyword">throws</span> SchedulerException &#123;</span><br><span class="line">	<span class="comment">// 加载 quartz.properties</span></span><br><span class="line">    <span class="keyword">if</span> (cfg == <span class="literal">null</span>) &#123;</span><br><span class="line">        initialize();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单例的 SchedulerRepository 实例</span></span><br><span class="line">    <span class="type">SchedulerRepository</span> <span class="variable">schedRep</span> <span class="operator">=</span> SchedulerRepository.getInstance();</span><br><span class="line">    <span class="comment">// 从缓存中查询获取 Schedule 任务，任务名称从配置中获取，若无指定，则默认指定 QuartzScheduler</span></span><br><span class="line">    <span class="type">Scheduler</span> <span class="variable">sched</span> <span class="operator">=</span> schedRep.lookup(getSchedulerName());</span><br><span class="line">	<span class="comment">// 判断若存在且已停止运行，则从缓存中移除</span></span><br><span class="line">    <span class="keyword">if</span> (sched != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sched.isShutdown()) &#123;</span><br><span class="line">            schedRep.remove(getSchedulerName());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sched;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化 StdScheduler</span></span><br><span class="line">    sched = instantiate();</span><br><span class="line">    <span class="keyword">return</span> sched;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getScheduler()会推迟实例化，当调用其方法时才会去初始化 Quartz 的配置</p>
<h3 id="initialize">initialize()</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据配置文件初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">()</span> <span class="keyword">throws</span> SchedulerException &#123;</span><br><span class="line">    <span class="comment">// 如果已经存在，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (cfg != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (initException != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> initException;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从环境变量 PROPERTIES_FILE = org.quartz.properties 是否存在指定读取的配置文件</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">requestedFile</span> <span class="operator">=</span> System.getProperty(PROPERTIES_FILE);</span><br><span class="line">    <span class="comment">// 不主动设置，默认设置为 quartz.properties</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">propFileName</span> <span class="operator">=</span> requestedFile != <span class="literal">null</span> ? requestedFile: <span class="string">&quot;quartz.properties&quot;</span>;</span><br><span class="line">    <span class="type">File</span> <span class="variable">propFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(propFileName);</span><br><span class="line"></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 读取配置文件内容，如果都不存在依次读取 quartz.properties、/quartz.properties、org/quartz/quartz.properties</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (propFile.exists()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (requestedFile != <span class="literal">null</span>) &#123;</span><br><span class="line">                    propSrc = <span class="string">&quot;specified file: &#x27;&quot;</span> + requestedFile + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    propSrc = <span class="string">&quot;default file in current working dir: &#x27;quartz.properties&#x27;&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                in = <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(propFileName));</span><br><span class="line">                props.load(in);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                initException = <span class="keyword">new</span> <span class="title class_">SchedulerException</span>(<span class="string">&quot;Properties file: &#x27;&quot;</span></span><br><span class="line">                        + propFileName + <span class="string">&quot;&#x27; could not be read.&quot;</span>, ioe);</span><br><span class="line">                <span class="keyword">throw</span> initException;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (requestedFile != <span class="literal">null</span>) &#123;</span><br><span class="line">            in = Thread.currentThread().getContextClassLoader().getResourceAsStream(requestedFile);</span><br><span class="line">            <span class="keyword">if</span>(in == <span class="literal">null</span>) &#123;</span><br><span class="line">                initException = <span class="keyword">new</span> <span class="title class_">SchedulerException</span>(<span class="string">&quot;Properties file: &#x27;&quot;</span></span><br><span class="line">                    + requestedFile + <span class="string">&quot;&#x27; could not be found.&quot;</span>);</span><br><span class="line">                <span class="keyword">throw</span> initException;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            propSrc = <span class="string">&quot;specified file: &#x27;&quot;</span> + requestedFile + <span class="string">&quot;&#x27; in the class resource path.&quot;</span>;</span><br><span class="line">            in = <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(in);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                props.load(in);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                initException = <span class="keyword">new</span> <span class="title class_">SchedulerException</span>(<span class="string">&quot;Properties file: &#x27;&quot;</span></span><br><span class="line">                        + requestedFile + <span class="string">&quot;&#x27; could not be read.&quot;</span>, ioe);</span><br><span class="line">                <span class="keyword">throw</span> initException;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            propSrc = <span class="string">&quot;default resource file in Quartz package: &#x27;quartz.properties&#x27;&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> getClass().getClassLoader();</span><br><span class="line">            <span class="keyword">if</span>(cl == <span class="literal">null</span>)</span><br><span class="line">                cl = findClassloader();</span><br><span class="line">            <span class="keyword">if</span>(cl == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SchedulerConfigException</span>(<span class="string">&quot;Unable to find a class loader on the current thread or class.&quot;</span>);</span><br><span class="line"></span><br><span class="line">            in = cl.getResourceAsStream(<span class="string">&quot;quartz.properties&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (in == <span class="literal">null</span>) &#123;</span><br><span class="line">                in = cl.getResourceAsStream(<span class="string">&quot;/quartz.properties&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (in == <span class="literal">null</span>) &#123;</span><br><span class="line">                in = cl.getResourceAsStream(<span class="string">&quot;org/quartz/quartz.properties&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (in == <span class="literal">null</span>) &#123;</span><br><span class="line">                initException = <span class="keyword">new</span> <span class="title class_">SchedulerException</span>(</span><br><span class="line">                        <span class="string">&quot;Default quartz.properties not found in class path&quot;</span>);</span><br><span class="line">                <span class="keyword">throw</span> initException;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                props.load(in);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                initException = <span class="keyword">new</span> <span class="title class_">SchedulerException</span>(</span><br><span class="line">                        <span class="string">&quot;Resource properties file: &#x27;org/quartz/quartz.properties&#x27; &quot;</span></span><br><span class="line">                                + <span class="string">&quot;could not be read from the classpath.&quot;</span>, ioe);</span><br><span class="line">                <span class="keyword">throw</span> initException;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(in != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123; in.close(); &#125; <span class="keyword">catch</span>(IOException ignore) &#123; <span class="comment">/* ignore */</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//赋值</span></span><br><span class="line">    initialize(overrideWithSysProps(props));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加系统配置，如果跟之前的配置相同则覆盖，以系统配置为主</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Properties <span class="title function_">overrideWithSysProps</span><span class="params">(Properties props)</span> &#123;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">sysProps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        sysProps = System.getProperties();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (AccessControlException e) &#123;</span><br><span class="line">        getLog().warn(</span><br><span class="line">            <span class="string">&quot;Skipping overriding quartz properties with System properties &quot;</span> +</span><br><span class="line">            <span class="string">&quot;during initialization because of an AccessControlException.  &quot;</span> +</span><br><span class="line">            <span class="string">&quot;This is likely due to not having read/write access for &quot;</span> +</span><br><span class="line">            <span class="string">&quot;java.util.PropertyPermission as required by java.lang.System.getProperties().  &quot;</span> +</span><br><span class="line">            <span class="string">&quot;To resolve this warning, either add this permission to your policy file or &quot;</span> +</span><br><span class="line">            <span class="string">&quot;use a non-default version of initialize().&quot;</span>,</span><br><span class="line">            e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sysProps != <span class="literal">null</span>) &#123;</span><br><span class="line">        props.putAll(sysProps);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> props;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(Properties props)</span> <span class="keyword">throws</span> SchedulerException &#123;</span><br><span class="line">    <span class="keyword">if</span> (propSrc == <span class="literal">null</span>) &#123;</span><br><span class="line">        propSrc = <span class="string">&quot;an externally provided properties instance.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.cfg = <span class="keyword">new</span> <span class="title class_">PropertiesParser</span>(props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过查看源码可知，quartz 的配置文件加载流程如下：</p>
<ol>
<li>查看是否有系统变量指定了配置文件路径</li>
<li>在当前项目下面查找名为 quartz.properties 的文件</li>
<li>通过类加载器加载当前 classpath 路径下的 quartz.properties、/quartz.properties、org/quartz/quartz.properties 的资源文件</li>
</ol>
<p>这里需要注意的是，一旦自己指定了 quartz.properties 文件，那么 quartz 默认提供的配置将不会被加载，因此也就不会生效</p>
<p><strong>Quartz 默认配置文件</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#实例名称</span></span><br><span class="line"><span class="attr">org.quartz.scheduler.instanceName</span>: <span class="string">DefaultQuartzScheduler</span></span><br><span class="line"><span class="comment">#远程方法调用</span></span><br><span class="line"><span class="attr">org.quartz.scheduler.rmi.export</span>: <span class="string">false</span></span><br><span class="line"><span class="attr">org.quartz.scheduler.rmi.proxy</span>: <span class="string">false</span></span><br><span class="line"><span class="comment">#是否将任务放在事务中执行</span></span><br><span class="line"><span class="attr">org.quartz.scheduler.wrapJobExecutionInUserTransaction</span>: <span class="string">false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#线程池</span></span><br><span class="line"><span class="attr">org.quartz.threadPool.class</span>: <span class="string">org.quartz.simpl.SimpleThreadPool</span></span><br><span class="line"><span class="comment">#线程个数</span></span><br><span class="line"><span class="attr">org.quartz.threadPool.threadCount</span>: <span class="string">10</span></span><br><span class="line"><span class="comment">#线程优先级</span></span><br><span class="line"><span class="attr">org.quartz.threadPool.threadPriority</span>: <span class="string">5</span></span><br><span class="line"><span class="attr">org.quartz.threadPool.threadsInheritContextClassLoaderOfInitializingThread</span>: <span class="string">true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#失火的阈值</span></span><br><span class="line"><span class="attr">org.quartz.jobStore.misfireThreshold</span>: <span class="string">60000</span></span><br><span class="line"><span class="comment">#使用内存方式存储</span></span><br><span class="line"><span class="attr">org.quartz.jobStore.class</span>: <span class="string">org.quartz.simpl.RAMJobStore</span></span><br></pre></td></tr></table></figure>
<h3 id="instantiate">instantiate()</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StdSchedulerFactory</span> <span class="keyword">implements</span> <span class="title class_">SchedulerFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROPERTIES_FILE</span> <span class="operator">=</span> <span class="string">&quot;org.quartz.properties&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_SCHED_INSTANCE_NAME</span> <span class="operator">=</span> <span class="string">&quot;org.quartz.scheduler.instanceName&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_SCHED_INSTANCE_ID</span> <span class="operator">=</span> <span class="string">&quot;org.quartz.scheduler.instanceId&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_SCHED_INSTANCE_ID_GENERATOR_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;org.quartz.scheduler.instanceIdGenerator&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_SCHED_INSTANCE_ID_GENERATOR_CLASS</span> <span class="operator">=</span></span><br><span class="line">        PROP_SCHED_INSTANCE_ID_GENERATOR_PREFIX + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_SCHED_THREAD_NAME</span> <span class="operator">=</span> <span class="string">&quot;org.quartz.scheduler.threadName&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_SCHED_BATCH_TIME_WINDOW</span> <span class="operator">=</span> <span class="string">&quot;org.quartz.scheduler.batchTriggerAcquisitionFireAheadTimeWindow&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_SCHED_MAX_BATCH_SIZE</span> <span class="operator">=</span> <span class="string">&quot;org.quartz.scheduler.batchTriggerAcquisitionMaxCount&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_SCHED_JMX_EXPORT</span> <span class="operator">=</span> <span class="string">&quot;org.quartz.scheduler.jmx.export&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_SCHED_JMX_OBJECT_NAME</span> <span class="operator">=</span> <span class="string">&quot;org.quartz.scheduler.jmx.objectName&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_SCHED_JMX_PROXY</span> <span class="operator">=</span> <span class="string">&quot;org.quartz.scheduler.jmx.proxy&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_SCHED_JMX_PROXY_CLASS</span> <span class="operator">=</span> <span class="string">&quot;org.quartz.scheduler.jmx.proxy.class&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_SCHED_RMI_EXPORT</span> <span class="operator">=</span> <span class="string">&quot;org.quartz.scheduler.rmi.export&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_SCHED_RMI_PROXY</span> <span class="operator">=</span> <span class="string">&quot;org.quartz.scheduler.rmi.proxy&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_SCHED_RMI_HOST</span> <span class="operator">=</span> <span class="string">&quot;org.quartz.scheduler.rmi.registryHost&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_SCHED_RMI_PORT</span> <span class="operator">=</span> <span class="string">&quot;org.quartz.scheduler.rmi.registryPort&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_SCHED_RMI_SERVER_PORT</span> <span class="operator">=</span> <span class="string">&quot;org.quartz.scheduler.rmi.serverPort&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_SCHED_RMI_CREATE_REGISTRY</span> <span class="operator">=</span> <span class="string">&quot;org.quartz.scheduler.rmi.createRegistry&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_SCHED_RMI_BIND_NAME</span> <span class="operator">=</span> <span class="string">&quot;org.quartz.scheduler.rmi.bindName&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_SCHED_WRAP_JOB_IN_USER_TX</span> <span class="operator">=</span> <span class="string">&quot;org.quartz.scheduler.wrapJobExecutionInUserTransaction&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_SCHED_USER_TX_URL</span> <span class="operator">=</span> <span class="string">&quot;org.quartz.scheduler.userTransactionURL&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_SCHED_IDLE_WAIT_TIME</span> <span class="operator">=</span> <span class="string">&quot;org.quartz.scheduler.idleWaitTime&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_SCHED_DB_FAILURE_RETRY_INTERVAL</span> <span class="operator">=</span> <span class="string">&quot;org.quartz.scheduler.dbFailureRetryInterval&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_SCHED_MAKE_SCHEDULER_THREAD_DAEMON</span> <span class="operator">=</span> <span class="string">&quot;org.quartz.scheduler.makeSchedulerThreadDaemon&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_SCHED_SCHEDULER_THREADS_INHERIT_CONTEXT_CLASS_LOADER_OF_INITIALIZING_THREAD</span> <span class="operator">=</span> <span class="string">&quot;org.quartz.scheduler.threadsInheritContextClassLoaderOfInitializer&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_SCHED_CLASS_LOAD_HELPER_CLASS</span> <span class="operator">=</span> <span class="string">&quot;org.quartz.scheduler.classLoadHelper.class&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_SCHED_JOB_FACTORY_CLASS</span> <span class="operator">=</span> <span class="string">&quot;org.quartz.scheduler.jobFactory.class&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_SCHED_JOB_FACTORY_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;org.quartz.scheduler.jobFactory&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_SCHED_INTERRUPT_JOBS_ON_SHUTDOWN</span> <span class="operator">=</span> <span class="string">&quot;org.quartz.scheduler.interruptJobsOnShutdown&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_SCHED_INTERRUPT_JOBS_ON_SHUTDOWN_WITH_WAIT</span> <span class="operator">=</span> <span class="string">&quot;org.quartz.scheduler.interruptJobsOnShutdownWithWait&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_SCHED_CONTEXT_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;org.quartz.context.key&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_THREAD_POOL_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;org.quartz.threadPool&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_THREAD_POOL_CLASS</span> <span class="operator">=</span> <span class="string">&quot;org.quartz.threadPool.class&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_JOB_STORE_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;org.quartz.jobStore&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_JOB_STORE_LOCK_HANDLER_PREFIX</span> <span class="operator">=</span> PROP_JOB_STORE_PREFIX + <span class="string">&quot;.lockHandler&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_JOB_STORE_LOCK_HANDLER_CLASS</span> <span class="operator">=</span> PROP_JOB_STORE_LOCK_HANDLER_PREFIX + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_TABLE_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;tablePrefix&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_SCHED_NAME</span> <span class="operator">=</span> <span class="string">&quot;schedName&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_JOB_STORE_CLASS</span> <span class="operator">=</span> <span class="string">&quot;org.quartz.jobStore.class&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_JOB_STORE_USE_PROP</span> <span class="operator">=</span> <span class="string">&quot;org.quartz.jobStore.useProperties&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_DATASOURCE_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;org.quartz.dataSource&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_CONNECTION_PROVIDER_CLASS</span> <span class="operator">=</span> <span class="string">&quot;connectionProvider.class&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@deprecated</span> Replaced with &#123;<span class="doctag">@link</span> PoolingConnectionProvider#DB_DRIVER&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_DATASOURCE_DRIVER</span> <span class="operator">=</span> <span class="string">&quot;driver&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@deprecated</span> Replaced with &#123;<span class="doctag">@link</span> PoolingConnectionProvider#DB_URL&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_DATASOURCE_URL</span> <span class="operator">=</span> <span class="string">&quot;URL&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@deprecated</span> Replaced with &#123;<span class="doctag">@link</span> PoolingConnectionProvider#DB_USER&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_DATASOURCE_USER</span> <span class="operator">=</span> <span class="string">&quot;user&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@deprecated</span> Replaced with &#123;<span class="doctag">@link</span> PoolingConnectionProvider#DB_PASSWORD&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_DATASOURCE_PASSWORD</span> <span class="operator">=</span> <span class="string">&quot;password&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@deprecated</span> Replaced with &#123;<span class="doctag">@link</span> PoolingConnectionProvider#DB_MAX_CONNECTIONS&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_DATASOURCE_MAX_CONNECTIONS</span> <span class="operator">=</span> <span class="string">&quot;maxConnections&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@deprecated</span> Replaced with &#123;<span class="doctag">@link</span> PoolingConnectionProvider#DB_VALIDATION_QUERY&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_DATASOURCE_VALIDATION_QUERY</span> <span class="operator">=</span> <span class="string">&quot;validationQuery&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_DATASOURCE_JNDI_URL</span> <span class="operator">=</span> <span class="string">&quot;jndiURL&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_DATASOURCE_JNDI_ALWAYS_LOOKUP</span> <span class="operator">=</span> <span class="string">&quot;jndiAlwaysLookup&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_DATASOURCE_JNDI_INITIAL</span> <span class="operator">=</span> <span class="string">&quot;java.naming.factory.initial&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_DATASOURCE_JNDI_PROVDER</span> <span class="operator">=</span> <span class="string">&quot;java.naming.provider.url&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_DATASOURCE_JNDI_PRINCIPAL</span> <span class="operator">=</span> <span class="string">&quot;java.naming.security.principal&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_DATASOURCE_JNDI_CREDENTIALS</span> <span class="operator">=</span> <span class="string">&quot;java.naming.security.credentials&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_PLUGIN_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;org.quartz.plugin&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_PLUGIN_CLASS</span> <span class="operator">=</span> <span class="string">&quot;class&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_JOB_LISTENER_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;org.quartz.jobListener&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_TRIGGER_LISTENER_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;org.quartz.triggerListener&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_LISTENER_CLASS</span> <span class="operator">=</span> <span class="string">&quot;class&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_INSTANCE_ID</span> <span class="operator">=</span> <span class="string">&quot;NON_CLUSTERED&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">AUTO_GENERATE_INSTANCE_ID</span> <span class="operator">=</span> <span class="string">&quot;AUTO&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_THREAD_EXECUTOR</span> <span class="operator">=</span> <span class="string">&quot;org.quartz.threadExecutor&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROP_THREAD_EXECUTOR_CLASS</span> <span class="operator">=</span> <span class="string">&quot;org.quartz.threadExecutor.class&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SYSTEM_PROPERTY_AS_INSTANCE_ID</span> <span class="operator">=</span> <span class="string">&quot;SYS_PROP&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MANAGEMENT_REST_SERVICE_ENABLED</span> <span class="operator">=</span> <span class="string">&quot;org.quartz.managementRESTService.enabled&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MANAGEMENT_REST_SERVICE_HOST_PORT</span> <span class="operator">=</span> <span class="string">&quot;org.quartz.managementRESTService.bind&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>instantiate()方法主要就是根据之前加载好的配置文件来创建出 scheduler 需要用到的一些对象。</p>
<p>主要对象：</p>
<ol>
<li>Job：业务逻辑类需要时间的接口</li>
<li>JobStore：主要用于存储 Job 和 Trigger</li>
<li>JobFactory：job 实例化工厂</li>
<li>ThreadPool：主要用于分配任务给具体的线程进行执行</li>
<li>QuartzSchedulerThread：管理者线程</li>
<li>WorkThread：工作者线程</li>
<li>DBConnectionManager：数据库连接管理器</li>
<li>ThreadExecutor：线程执行器</li>
<li>SchedulerPlugin：调度器插件</li>
<li>JobListener：任务监听器</li>
<li>Trigger：触发器</li>
<li>Schedule：时间表</li>
<li>TriggerListerne：触发器监听器</li>
<li>JobRunShellFactory：jobRunShell 的工厂</li>
<li>JobRunShell：实现了 Runnale 接口，会调用对应实例化的 job 的 execute 方法</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>定时任务</tag>
        <tag>Quartz</tag>
      </tags>
  </entry>
  <entry>
    <title>Quartz（5-JobStore）</title>
    <url>/blog/2024/12/13/Java/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/Quartz/Quartz%EF%BC%885-JobStore%EF%BC%89/</url>
    <content><![CDATA[<h2 id="JobStore">JobStore</h2>
<p>JobStore 是存放 Job 和 Trigger 的地方。当我们调用 Scheduler 对象的 scheduleJob 时就会将其存入 JobStore 中，然后供 quartzSchedulerThread 使用。</p>
<p><strong>为什么需要 JobStore？</strong></p>
<p>因为我们需要被 Scheduler 调用的任务大多数并不是一次性的任务，而是需要被定时触发，或者某个时间点才能被触发的，因此我们需要一个容器来存储 Job 和 Trigger 的相关内容。</p>
<p>其次，quartz 框架还有考虑到持久化存储的场景，比如说将对应的数据存放到数据库，这时候存放或者读取数据库里面的数据都需要有一个与之对应的容器。</p>
<h3 id="方法">方法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">JobStore</span> &#123;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//存储job和tigger</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">storeJobAndTrigger</span><span class="params">(JobDetail newJob, OperableTrigger newTrigger)</span> </span><br><span class="line">        <span class="keyword">throws</span> ObjectAlreadyExistsException, JobPersistenceException;</span><br><span class="line">		</span><br><span class="line">   <span class="comment">//获取下一次需要进行触发的触发器</span></span><br><span class="line">   List&lt;OperableTrigger&gt; <span class="title function_">acquireNextTriggers</span><span class="params">(<span class="type">long</span> noLaterThan, <span class="type">int</span> maxCount, <span class="type">long</span> timeWindow)</span></span><br><span class="line">        <span class="keyword">throws</span> JobPersistenceException;</span><br><span class="line">	</span><br><span class="line">   <span class="comment">//释放获取到的触发器</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">releaseAcquiredTrigger</span><span class="params">(OperableTrigger trigger)</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//触发器被触发</span></span><br><span class="line">   List&lt;TriggerFiredResult&gt; <span class="title function_">triggersFired</span><span class="params">(List&lt;OperableTrigger&gt; triggers)</span> <span class="keyword">throws</span> JobPersistenceException;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//触发器触发完成</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">triggeredJobComplete</span><span class="params">(OperableTrigger trigger, JobDetail jobDetail, CompletedExecutionInstruction triggerInstCode)</span>;</span><br><span class="line">    </span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分类">分类</h3>
<p><img src="1.png" alt=""></p>
<h3 id="基本配置">基本配置</h3>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Scheduler 实例名</span></span><br><span class="line"><span class="attr">org.quartz.scheduler.instanceName</span> = <span class="string">MyScheduler</span></span><br><span class="line"><span class="attr">org.quartz.scheduler.instanceId</span> = <span class="string">AUTO</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 集群配置</span></span><br><span class="line"><span class="attr">org.quartz.jobStore.isClustered</span> = <span class="string">true</span></span><br><span class="line"><span class="attr">org.quartz.jobStore.clusterCheckinInterval</span> = <span class="string">20000</span></span><br><span class="line"><span class="comment"># 使用的 JobStore 类型</span></span><br><span class="line"><span class="attr">org.quartz.jobStore.class</span> = <span class="string">org.quartz.impl.jdbcjobstore.JobStoreTX</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 数据源配置</span></span><br><span class="line"><span class="attr">org.quartz.jobStore.dataSource</span> = <span class="string">quartzDataSource</span></span><br><span class="line"><span class="attr">org.quartz.jobStore.tablePrefix</span> = <span class="string">QRTZ_</span></span><br><span class="line"><span class="comment"># 数据源详细信息</span></span><br><span class="line"><span class="attr">org.quartz.dataSource.quartzDataSource.driver</span> = <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">org.quartz.dataSource.quartzDataSource.URL</span> = <span class="string">jdbc:mysql://localhost:3306/quartz</span></span><br><span class="line"><span class="attr">org.quartz.dataSource.quartzDataSource.user</span> = <span class="string">root</span></span><br><span class="line"><span class="attr">org.quartz.dataSource.quartzDataSource.password</span> = <span class="string">password</span></span><br><span class="line"><span class="attr">org.quartz.dataSource.quartzDataSource.maxConnections</span> = <span class="string">10</span></span><br></pre></td></tr></table></figure>
<h2 id="RAMJobStore">RAMJobStore</h2>
<p>在 quartz 的默认配置中使用的就是 RAMJobStore。顾名思义，RAMJobStore 是基于内存来存储的 Job 相关数据，也就是在程序重启之后，对应的数据就会消失，并且它不支持集群，也就是说它不可以把需要调度的任务分配到多台机器上面进行执行。</p>
<h3 id="优缺点">优缺点</h3>
<ol>
<li>
<p>优点：使用内存存储调度数据，速度快，配置简单，适合轻量级或短生命周期的应用场景。</p>
</li>
<li>
<p>缺点：数据仅存储在内存中，系统重启后数据会丢失，不支持多节点集群。</p>
</li>
</ol>
<h3 id="属性">属性</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RAMJobStore</span> <span class="keyword">implements</span> <span class="title class_">JobStore</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> HashMap&lt;JobKey, JobWrapper&gt; jobsByKey = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;JobKey, JobWrapper&gt;(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> HashMap&lt;TriggerKey, TriggerWrapper&gt; triggersByKey = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;TriggerKey, TriggerWrapper&gt;(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> HashMap&lt;String, HashMap&lt;JobKey, JobWrapper&gt;&gt; jobsByGroup = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, HashMap&lt;JobKey, JobWrapper&gt;&gt;(<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> HashMap&lt;String, HashMap&lt;TriggerKey, TriggerWrapper&gt;&gt; triggersByGroup = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, HashMap&lt;TriggerKey, TriggerWrapper&gt;&gt;(<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> TreeSet&lt;TriggerWrapper&gt; timeTriggers = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;TriggerWrapper&gt;(<span class="keyword">new</span> <span class="title class_">TriggerWrapperComparator</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> HashMap&lt;String, Calendar&gt; calendarsByName = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Calendar&gt;(<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Map&lt;JobKey, List&lt;TriggerWrapper&gt;&gt; triggersByJob = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;JobKey, List&lt;TriggerWrapper&gt;&gt;(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> HashSet&lt;String&gt; pausedTriggerGroups = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> HashSet&lt;String&gt; pausedJobGroups = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> HashSet&lt;JobKey&gt; blockedJobs = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;JobKey&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="type">long</span> <span class="variable">misfireThreshold</span> <span class="operator">=</span> <span class="number">5000l</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> SchedulerSignaler signaler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>jobsByKey：按 jobKey 进行分组的 HashMap 集合</li>
<li>triggersByKey：按 jobKey 进行分组的 HashMap 集合</li>
<li>jobsByGroup：按 job 的分组名进行分组的 HashMap 集合</li>
<li>triggersByGroup：按 trigger 的分组名进行分组的 HashMap 集合</li>
<li>timeTriggers：具有下次触发时间的 trigger 集合</li>
<li>triggers：trigger 集合</li>
<li>lock：操作 RAMJobStore 时需要获取的锁</li>
<li>pausedTriggerGroups：被暂停的 trigger 分组名的 HashSet 集合</li>
<li>pausedJobGroups：被暂停的 job 分组名的 HashSet 集合</li>
<li>blockedJobs：被锁住的任务 key 的 HashSet 集合</li>
<li>misfireThreshold：失火阈值</li>
<li>signaler：SchedulerSignaler 信号器</li>
</ol>
<h2 id="TerracottaJobStore">TerracottaJobStore</h2>
<p>TerracottaJobStore 提供了一种无需数据库就可以进行缩放和健壮性的方法。这意味着您的数据库可以避免来自 Quartz 的负载，并且可以将所有的资源保存到您的应用程序的其他部分。</p>
<p>TerracottaJobStore 可以是集群的或非集群的，在这两种情况下，都为您的工作数据提供了一个存储介质，在应用程序重新启动之间是持久的，因为数据存储在 Terracotta 服务器中。它的性能比通过 JDBCJobStore(大约一个数量级更好) 使用数据库要好得多，但是比 RAMJobStore 慢得多。</p>
<p>要使用 TerracottaJobStore(假设您使用的是 StdSchedulerFactory)，只需指定类名称 org.quartz.jobStore.class = org.terracotta.quartz.TerracottaJobStore。作为您用来配置 quartz 的 JobStore 类属性，并添加一个额外的配置行来指定 Terracotta 服务器的位置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">org.quartz.jobStore.class</span> = <span class="string">org.terracotta.quartz.TerracottaJobStore</span></span><br><span class="line"><span class="attr">org.quartz.jobStore.tcConfigUrl</span> = <span class="string">localhost:9510</span></span><br></pre></td></tr></table></figure>
<h2 id="JobStoreSupport">JobStoreSupport</h2>
<p>JobStoreSupport 是 Quartz 框架中 JDBCJobStore 的核心支持类，它提供了基于 JDBC 的任务存储的基础实现。通过扩展 JobStoreSupport，Quartz 实现了两种 JDBCJobStore：JobStoreTX 和 JobStoreCMT。</p>
<h3 id="作用">作用</h3>
<ol>
<li>它定义了与数据库交互的通用逻辑，比如插入、更新、删除调度数据。</li>
<li>提供了事务管理的基础功能，允许子类（如 JobStoreTX 和 JobStoreCMT）选择具体的事务管理方式。</li>
</ol>
<h3 id="JobStoreTX">JobStoreTX</h3>
<h4 id="特点">特点</h4>
<ol>
<li>使用独立的事务管理。</li>
<li>每次数据库操作开启和提交一个新的事务。</li>
<li>适合独立运行的 Quartz 应用。</li>
</ol>
<h4 id="事务逻辑">事务逻辑</h4>
<ol>
<li>每个调度操作通过 JDBC 手动开启、提交或回滚事务。</li>
<li>不依赖外部容器的事务管理器。</li>
</ol>
<h3 id="JobStoreCMT">JobStoreCMT</h3>
<h4 id="特点-2">特点</h4>
<ol>
<li>使用容器管理的事务（CMT, Container-Managed Transaction）。</li>
<li>适合运行在 J2EE 应用服务器中的 Quartz 应用。</li>
</ol>
<h4 id="事务逻辑-2">事务逻辑</h4>
<ol>
<li>依赖应用服务器（如 WebLogic、JBoss）提供的事务管理器。</li>
<li>Quartz 不直接管理事务，而是将事务逻辑交由容器处理。</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>定时任务</tag>
        <tag>Quartz</tag>
      </tags>
  </entry>
  <entry>
    <title>Quartz（4-Listener）</title>
    <url>/blog/2024/11/16/Java/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/Quartz/Quartz%EF%BC%884-Listener%EF%BC%89/</url>
    <content><![CDATA[<h2 id="ListenerManager">ListenerManager</h2>
<p>可以通过ListenerManager向scheduler中添加我们的监听器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ListenerManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addJobListener</span><span class="params">(JobListener jobListener)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addJobListener</span><span class="params">(JobListener jobListener, Matcher&lt;JobKey&gt; matcher)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addJobListener</span><span class="params">(JobListener jobListener, Matcher&lt;JobKey&gt; ... matchers)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addJobListener</span><span class="params">(JobListener jobListener, List&lt;Matcher&lt;JobKey&gt;&gt; matchers)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addJobListenerMatcher</span><span class="params">(String listenerName, Matcher&lt;JobKey&gt; matcher)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeJobListenerMatcher</span><span class="params">(String listenerName, Matcher&lt;JobKey&gt; matcher)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">setJobListenerMatchers</span><span class="params">(String listenerName, List&lt;Matcher&lt;JobKey&gt;&gt; matchers)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Matcher&lt;JobKey&gt;&gt; <span class="title function_">getJobListenerMatchers</span><span class="params">(String listenerName)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeJobListener</span><span class="params">(String name)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;JobListener&gt; <span class="title function_">getJobListeners</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> JobListener <span class="title function_">getJobListener</span><span class="params">(String name)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addTriggerListener</span><span class="params">(TriggerListener triggerListener)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addTriggerListener</span><span class="params">(TriggerListener triggerListener, Matcher&lt;TriggerKey&gt; matcher)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addTriggerListener</span><span class="params">(TriggerListener triggerListener, Matcher&lt;TriggerKey&gt; ... matchers)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addTriggerListener</span><span class="params">(TriggerListener triggerListener, List&lt;Matcher&lt;TriggerKey&gt;&gt; matchers)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addTriggerListenerMatcher</span><span class="params">(String listenerName, Matcher&lt;TriggerKey&gt; matcher)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeTriggerListenerMatcher</span><span class="params">(String listenerName, Matcher&lt;TriggerKey&gt; matcher)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">setTriggerListenerMatchers</span><span class="params">(String listenerName, List&lt;Matcher&lt;TriggerKey&gt;&gt; matchers)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Matcher&lt;TriggerKey&gt;&gt; <span class="title function_">getTriggerListenerMatchers</span><span class="params">( String listenerName)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeTriggerListener</span><span class="params">(String name)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;TriggerListener&gt; <span class="title function_">getTriggerListeners</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TriggerListener <span class="title function_">getTriggerListener</span><span class="params">(String name)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSchedulerListener</span><span class="params">(SchedulerListener schedulerListener)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeSchedulerListener</span><span class="params">(SchedulerListener schedulerListener)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;SchedulerListener&gt; <span class="title function_">getSchedulerListeners</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Matcher">Matcher</h2>
<h3 id="KeyMatcher">KeyMatcher</h3>
<p>根据JobKey进行匹配，每个JobDetail都有一个对应的JobKey，里面存储了JobName和JobGroup来定位唯一的JobDetail</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造匹配pickNewsJob中的JobKey的keyMatcher。</span></span><br><span class="line">KeyMatcher&lt;JobKey&gt; keyMatcher = KeyMatcher.keyEquals(pickNewsJob.getKey());</span><br><span class="line"><span class="comment">//通过这句完成我们监听器对pickNewsJob的唯一监听</span></span><br><span class="line">scheduler.getListenerManager().addJobListener(myJobListener, keyMatcher);</span><br></pre></td></tr></table></figure>
<h3 id="GroupMatcher">GroupMatcher</h3>
<p>根据组名信息匹配</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GroupMatcher&lt;JobKey&gt; groupMatcher1 = GroupMatcher.jobGroupContains(<span class="string">&quot;group1&quot;</span>);<span class="comment">//包含特定字符串</span></span><br><span class="line">GroupMatcher&lt;JobKey&gt; groupMatcher2 = GroupMatcher.groupEndsWith(<span class="string">&quot;oup1&quot;</span>);<span class="comment">//以特定字符串结尾</span></span><br><span class="line">GroupMatcher&lt;JobKey&gt; groupMatcher3 = GroupMatcher.groupEquals(<span class="string">&quot;jgroup1&quot;</span>);<span class="comment">//以特定字符串完全匹配</span></span><br><span class="line">GroupMatcher&lt;JobKey&gt; groupMatcher4 = GroupMatcher.groupStartsWith(<span class="string">&quot;jgou&quot;</span>);<span class="comment">//以特定字符串开头</span></span><br></pre></td></tr></table></figure>
<h3 id="AndMatcher">AndMatcher</h3>
<p>对两个匹配器取交集</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">KeyMatcher&lt;JobKey&gt; keyMatcher = KeyMatcher.keyEquals(pickNewsJob.getKey());</span><br><span class="line">GroupMatcher&lt;JobKey&gt; groupMatcher = GroupMatcher.jobGroupContains(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">AndMatcher&lt;JobKey&gt; andMatcher = AndMatcher.and(keyMatcher, groupMatcher);<span class="comment">//同时满足两个入参匹配</span></span><br></pre></td></tr></table></figure>
<h3 id="OrMatcher">OrMatcher</h3>
<p>对两个匹配器取并集</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OrMatcher&lt;JobKey&gt; orMatcher = OrMatcher.or(keyMatcher, groupMatcher);<span class="comment">//满足任意一个即可</span></span><br></pre></td></tr></table></figure>
<h3 id="EverythingMatcher">EverythingMatcher</h3>
<p>局部全局匹配</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EverythingMatcher.allJobs();<span class="comment">//对全部JobListener匹配</span></span><br><span class="line">EverythingMatcher.allTriggers();<span class="comment">//对全部TriggerListener匹配</span></span><br></pre></td></tr></table></figure>
<h2 id="JobListener">JobListener</h2>
<h3 id="方法">方法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">JobListener</span> &#123;</span><br><span class="line">    <span class="comment">//用于获取该JobListener的名称</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Scheduler在JobDetail将要被执行时调用这个方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jobToBeExecuted</span><span class="params">(JobExecutionContext context)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Scheduler在JobDetail即将被执行，但又被TriggerListener否决时会调用该方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jobExecutionVetoed</span><span class="params">(JobExecutionContext context)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Scheduler在JobDetail被执行之后调用这个方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jobWasExecuted</span><span class="params">(JobExecutionContext context, JobExecutionException jobException)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="基本使用">基本使用</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Job1</span> <span class="keyword">implements</span> <span class="title class_">Job</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException &#123;</span><br><span class="line">        <span class="comment">// 输出当前时间</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">dateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">dateString</span> <span class="operator">=</span> dateFormat.format(date);</span><br><span class="line">        <span class="comment">// 工作内容</span></span><br><span class="line">        System.out.println(<span class="string">&quot;正在进行数据库的备份工作，备份数据库的时间是：&quot;</span> +dateString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JobListener1</span> <span class="keyword">implements</span> <span class="title class_">JobListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;================================&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getSimpleName();</span><br><span class="line">        System.out.println(<span class="string">&quot;监听器的名称是：&quot;</span> +name);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jobToBeExecuted</span><span class="params">(JobExecutionContext context)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> context.getJobDetail().getKey().getName();</span><br><span class="line">        System.out.println(<span class="string">&quot;Job的名称是：&quot;</span> +name + <span class="string">&quot;，Scheduler在JobDetail被执行之前调用这个方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jobExecutionVetoed</span><span class="params">(JobExecutionContext context)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> context.getJobDetail().getKey().getName();</span><br><span class="line">        System.out.println(<span class="string">&quot;Job的名称是：&quot;</span> +name + <span class="string">&quot;，Scheduler在JobDetail即将被执行，但又被TriggerListener否决时会调用该方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jobWasExecuted</span><span class="params">(JobExecutionContext context, JobExecutionException jobException)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> context.getJobDetail().getKey().getName();</span><br><span class="line">        System.out.println(<span class="string">&quot;Job的名称是：&quot;</span> +name + <span class="string">&quot;，Scheduler在JobDetail被执行之后调用这个方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、调度器（Scheduler），从工厂中获取调度的实例（默认：实例化new StdSchedulerFactory();）</span></span><br><span class="line">        <span class="type">Scheduler</span> <span class="variable">scheduler</span> <span class="operator">=</span> StdSchedulerFactory.getDefaultScheduler();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、任务实例（JobDetail）定义一个任务调度实例，将该实例与HelloJobSimpleTrigger绑定，任务类需要实现Job接口</span></span><br><span class="line">        <span class="type">JobDetail</span> <span class="variable">jobDetail</span> <span class="operator">=</span> JobBuilder.newJob(Job1.class) <span class="comment">// 加载任务类，与HelloJob完成绑定，要求HelloJob实现Job接口</span></span><br><span class="line">                .withIdentity(<span class="string">&quot;job1&quot;</span>, <span class="string">&quot;group1&quot;</span>) <span class="comment">// 参数1：任务的名称（唯一实例）；参数2：任务组的名称</span></span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、触发器（Trigger）定义触发器，马上执行，然后每5秒重复执行一次</span></span><br><span class="line">        <span class="type">Trigger</span> <span class="variable">trigger</span> <span class="operator">=</span> TriggerBuilder.newTrigger()</span><br><span class="line">                .withIdentity(<span class="string">&quot;trigger1&quot;</span>, <span class="string">&quot;group1&quot;</span>) <span class="comment">// 参数1：触发器的名称（唯一实例）；参数2：触发器组的名称</span></span><br><span class="line">                .startNow()</span><br><span class="line">                .withSchedule(SimpleScheduleBuilder.repeatSecondlyForever(<span class="number">5</span>)</span><br><span class="line">                        .withRepeatCount(<span class="number">2</span>))  <span class="comment">// 每5秒执行一次，连续执行3次后停止，默认是0</span></span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">// 4、让调度器关联任务和触发器，保证按照触发器定义的调整执行任务</span></span><br><span class="line">        scheduler.scheduleJob(jobDetail, trigger);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建并注册一个局部的Job Listener，表示指定的任务Job</span></span><br><span class="line">        scheduler.getListenerManager().addJobListener(<span class="keyword">new</span> <span class="title class_">JobListener1</span>(), KeyMatcher.keyEquals(JobKey.jobKey(<span class="string">&quot;job1&quot;</span>, <span class="string">&quot;group1&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5、启动</span></span><br><span class="line">        scheduler.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line">================================</span><br><span class="line">监听器的名称是：Listener1</span><br><span class="line">================================</span><br><span class="line">监听器的名称是：Listener1</span><br><span class="line">================================</span><br><span class="line">监听器的名称是：Listener1</span><br><span class="line">================================</span><br><span class="line">监听器的名称是：Listener1</span><br><span class="line">================================</span><br><span class="line">监听器的名称是：Listener1</span><br><span class="line">Job的名称是：job1，Scheduler在JobDetail被执行之前调用这个方法</span><br><span class="line">正在进行数据库的备份工作，备份数据库的时间是：<span class="number">2024</span>-<span class="number">11</span>-<span class="number">16</span> <span class="number">13</span>:<span class="number">20</span>:<span class="number">11</span></span><br><span class="line">================================</span><br><span class="line">监听器的名称是：Listener1</span><br><span class="line">Job的名称是：job1，Scheduler在JobDetail被执行之后调用这个方法</span><br><span class="line">================================</span><br><span class="line">监听器的名称是：Listener1</span><br><span class="line">Job的名称是：job1，Scheduler在JobDetail被执行之前调用这个方法</span><br><span class="line">正在进行数据库的备份工作，备份数据库的时间是：<span class="number">2024</span>-<span class="number">11</span>-<span class="number">16</span> <span class="number">13</span>:<span class="number">20</span>:<span class="number">16</span></span><br><span class="line">================================</span><br><span class="line">监听器的名称是：Listener1</span><br><span class="line">Job的名称是：job1，Scheduler在JobDetail被执行之后调用这个方法</span><br><span class="line">================================</span><br><span class="line">监听器的名称是：Listener1</span><br><span class="line">Job的名称是：job1，Scheduler在JobDetail被执行之前调用这个方法</span><br><span class="line">正在进行数据库的备份工作，备份数据库的时间是：<span class="number">2024</span>-<span class="number">11</span>-<span class="number">16</span> <span class="number">13</span>:<span class="number">20</span>:<span class="number">21</span></span><br><span class="line">================================</span><br><span class="line">监听器的名称是：Listener1</span><br><span class="line">Job的名称是：job1，Scheduler在JobDetail被执行之后调用这个方法</span><br></pre></td></tr></table></figure>
<h2 id="TriggerListener">TriggerListener</h2>
<h3 id="方法-2">方法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TriggerListener</span> &#123;</span><br><span class="line">    <span class="comment">//用于获取触发器的名称</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当与监听器关联的Trigger被触发，Job上的Execute()方法将被执行时，Scheduler就调用该方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">triggerFired</span><span class="params">(Trigger trigger, JobExecutionContext context)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在Trigger触发后，Job将要执行时由Scheduler调用这个方法。TriggerListener给了一个选择去否决Job的执行。</span></span><br><span class="line">    <span class="comment">//假如这个方法返回true，这个Job将不会为此次Trigger触发而得到执行。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">vetoJobExecution</span><span class="params">(Trigger trigger, JobExecutionContext context)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Scheduler调用这个方法是在Trigger错过触发时。你应该关注此方法中持续时间长的逻辑：</span></span><br><span class="line">    <span class="comment">//在出现许多错过触发的Trigger时，长逻辑会导致骨牌效应。你应当保持这个方法尽量的小。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">triggerMisfired</span><span class="params">(Trigger trigger)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Trigger被触发并且完成了Job的执行时，Scheduler调用这个方法。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">triggerComplete</span><span class="params">(Trigger trigger, JobExecutionContext context, CompletedExecutionInstruction triggerInstructionCode)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="基本使用-2">基本使用</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TriggerListener1</span> <span class="keyword">implements</span> <span class="title class_">TriggerListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=========================&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getSimpleName();</span><br><span class="line">        System.out.println(<span class="string">&quot;触发器的名称是：&quot;</span> +name);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">triggerFired</span><span class="params">(Trigger trigger, JobExecutionContext context)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getSimpleName();</span><br><span class="line">        System.out.println(name +<span class="string">&quot;被触发&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">vetoJobExecution</span><span class="params">(Trigger trigger, JobExecutionContext context)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getSimpleName();</span><br><span class="line">        <span class="comment">// TriggerListener给了一个选择去否决Job的执行。假如这个方法返回true，这个Job将不会为此次Trigger触发而得到执行。</span></span><br><span class="line">        System.out.println(name +<span class="string">&quot;否决没有被触发&quot;</span>);</span><br><span class="line">        <span class="comment">// true:表示不会执行Job的方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">triggerMisfired</span><span class="params">(Trigger trigger)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getSimpleName();</span><br><span class="line">        <span class="comment">// Scheduler调用这个方法是在Trigger错过触发时</span></span><br><span class="line">        System.out.println(name +<span class="string">&quot;错过触发&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">triggerComplete</span><span class="params">(Trigger trigger, JobExecutionContext context,</span></span><br><span class="line"><span class="params">                                Trigger.CompletedExecutionInstruction triggerInstructionCode)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getSimpleName();</span><br><span class="line">        <span class="comment">// Trigger被触发并且完成了Job的执行时，Scheduler调用这个方法。</span></span><br><span class="line">        System.out.println(name +<span class="string">&quot;完成之后触发&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、调度器（Scheduler），从工厂中获取调度的实例（默认：实例化new StdSchedulerFactory();）</span></span><br><span class="line">        <span class="type">Scheduler</span> <span class="variable">scheduler</span> <span class="operator">=</span> StdSchedulerFactory.getDefaultScheduler();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、任务实例（JobDetail）定义一个任务调度实例，将该实例与HelloJobSimpleTrigger绑定，任务类需要实现Job接口</span></span><br><span class="line">        <span class="type">JobDetail</span> <span class="variable">jobDetail</span> <span class="operator">=</span> JobBuilder.newJob(Job1.class) <span class="comment">// 加载任务类，与HelloJob完成绑定，要求HelloJob实现Job接口</span></span><br><span class="line">                .withIdentity(<span class="string">&quot;job1&quot;</span>, <span class="string">&quot;group1&quot;</span>) <span class="comment">// 参数1：任务的名称（唯一实例）；参数2：任务组的名称</span></span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、触发器（Trigger）定义触发器，马上执行，然后每5秒重复执行一次</span></span><br><span class="line">        <span class="type">Trigger</span> <span class="variable">trigger</span> <span class="operator">=</span> TriggerBuilder.newTrigger()</span><br><span class="line">                .withIdentity(<span class="string">&quot;trigger1&quot;</span>, <span class="string">&quot;group1&quot;</span>) <span class="comment">// 参数1：触发器的名称（唯一实例）；参数2：触发器组的名称</span></span><br><span class="line">                .startNow()</span><br><span class="line">                .withSchedule(SimpleScheduleBuilder.repeatSecondlyForever(<span class="number">5</span>)</span><br><span class="line">                        .withRepeatCount(<span class="number">2</span>))  <span class="comment">// 每5秒执行一次，连续执行3次后停止，默认是0</span></span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">// 4、让调度器关联任务和触发器，保证按照触发器定义的调整执行任务</span></span><br><span class="line">        scheduler.scheduleJob(jobDetail, trigger);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建并注册一个局部的Job Listener，表示指定的任务Job</span></span><br><span class="line"><span class="comment">//        scheduler.getListenerManager().addJobListener(new JobListener1(), KeyMatcher.keyEquals(JobKey.jobKey(&quot;job1&quot;, &quot;group1&quot;)));</span></span><br><span class="line">        scheduler.getListenerManager().addTriggerListener(<span class="keyword">new</span> <span class="title class_">TriggerListener1</span>(), KeyMatcher.keyEquals(TriggerKey.triggerKey(<span class="string">&quot;trigger1&quot;</span>, <span class="string">&quot;group1&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5、启动</span></span><br><span class="line">        scheduler.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line">=========================</span><br><span class="line">触发器的名称是：TriggerListener1</span><br><span class="line">=========================</span><br><span class="line">触发器的名称是：TriggerListener1</span><br><span class="line">=========================</span><br><span class="line">触发器的名称是：TriggerListener1</span><br><span class="line">=========================</span><br><span class="line">触发器的名称是：TriggerListener1</span><br><span class="line">=========================</span><br><span class="line">触发器的名称是：TriggerListener1</span><br><span class="line">TriggerListener1被触发</span><br><span class="line">TriggerListener1否决没有被触发</span><br><span class="line">正在进行数据库的备份工作，备份数据库的时间是：<span class="number">2024</span>-<span class="number">11</span>-<span class="number">16</span> <span class="number">13</span>:<span class="number">34</span>:<span class="number">59</span></span><br><span class="line">=========================</span><br><span class="line">触发器的名称是：TriggerListener1</span><br><span class="line">TriggerListener1完成之后触发</span><br><span class="line">=========================</span><br><span class="line">触发器的名称是：TriggerListener1</span><br><span class="line">TriggerListener1被触发</span><br><span class="line">TriggerListener1否决没有被触发</span><br><span class="line">正在进行数据库的备份工作，备份数据库的时间是：<span class="number">2024</span>-<span class="number">11</span>-<span class="number">16</span> <span class="number">13</span>:<span class="number">35</span>:<span class="number">04</span></span><br><span class="line">=========================</span><br><span class="line">触发器的名称是：TriggerListener1</span><br><span class="line">TriggerListener1完成之后触发</span><br><span class="line">=========================</span><br><span class="line">触发器的名称是：TriggerListener1</span><br><span class="line">TriggerListener1被触发</span><br><span class="line">TriggerListener1否决没有被触发</span><br><span class="line">正在进行数据库的备份工作，备份数据库的时间是：<span class="number">2024</span>-<span class="number">11</span>-<span class="number">16</span> <span class="number">13</span>:<span class="number">35</span>:09</span><br><span class="line">=========================</span><br><span class="line">触发器的名称是：TriggerListener1</span><br><span class="line">TriggerListener1完成之后触发</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<p>Job和Trigger监听器的调用顺序：</p>
<ol>
<li>成功时：triggerFired=&gt;vetoJobExecution=&gt;jobToBeExecuted=&gt;jobWasExecuted=&gt;triggerComplete</li>
<li>失败时：triggerFired=&gt;vetoJobExecution=&gt;jobExecutionVetoed</li>
</ol>
<h2 id="SchedulerListener">SchedulerListener</h2>
<h3 id="方法-3">方法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SchedulerListener</span> &#123;</span><br><span class="line">    <span class="comment">//用于部署JobDetail时调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jobScheduled</span><span class="params">(Trigger trigger)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用于卸载JobDetail时调用。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jobUnscheduled</span><span class="params">(TriggerKey triggerKey)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当一个Trigger来到了再也不会触发的状态时调用这个方法。除非这个Job已设置成了持久性，否则它就会从Scheduler中移除</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">triggerFinalized</span><span class="params">(Trigger trigger)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Scheduler调用这个方法是发生在一个Trigger或Trigger组被暂停时。假如是Trigger组的话，triggerName参数将为null</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">triggersPaused</span><span class="params">(String triggerGroup)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Scheduler调用这个方法是发生在一个Trigger或Trigger组从暂停中恢复时。假如是Trigger组的话，triggerName参数将为null</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">triggersResumed</span><span class="params">(String triggerGroup)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当一个或一组JobDetail暂停时调用这个方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jobsPaused</span><span class="params">(String jobGroup)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当一个或一组Job从暂停上恢复时调用这个方法。假如是一个Job组，jobName将为null</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jobsResumed</span><span class="params">(String jobGroup)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在Scheduler的正常运行期间产生一个严重错误时调用这个方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">schedulerError</span><span class="params">(String msg, SchedulerException cause)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当Scheduler开启时，调用该方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">schedulerStarted</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当Scheduler处于StandBy模式时，调用该方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">schedulerInStandbyMode</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当Scheduler停止时，调用该方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">schedulerShutdown</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当Scheduler中的数据被清除时，调用该方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">schedulingDataCleared</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="基本使用-3">基本使用</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SchedulerListener1</span> <span class="keyword">implements</span> <span class="title class_">SchedulerListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jobScheduled</span><span class="params">(Trigger trigger)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> trigger.getKey().getName();</span><br><span class="line">        <span class="comment">// 用于部署JobDetail时调用</span></span><br><span class="line">        System.out.println(name +<span class="string">&quot; 完成部署&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jobUnscheduled</span><span class="params">(TriggerKey triggerKey)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> triggerKey.getName();</span><br><span class="line">        <span class="comment">// 用于卸载JobDetail时调用</span></span><br><span class="line">        System.out.println(name +<span class="string">&quot; 完成卸载&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">triggerFinalized</span><span class="params">(Trigger trigger)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> trigger.getKey().getName();</span><br><span class="line">        <span class="comment">// 当一个Trigger来到了再也不会触发的状态时调用这个方法。除非这个Job已设置成了持久性，否则它就会从Scheduler中移除。</span></span><br><span class="line">        System.out.println(name +<span class="string">&quot; 触发器被移除&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">triggerPaused</span><span class="params">(TriggerKey triggerKey)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> triggerKey.getName();</span><br><span class="line">        <span class="comment">// Scheduler调用这个方法是发生在一个Trigger或Trigger组被暂停时。假如是Trigger组的话，triggerName参数将为null。</span></span><br><span class="line">        System.out.println(name +<span class="string">&quot; 正在被暂停&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">triggersPaused</span><span class="params">(String triggerGroup)</span> &#123;</span><br><span class="line">        <span class="comment">// Scheduler调用这个方法是发生在一个Trigger或Trigger组被暂停时。假如是Trigger组的话，triggerName参数将为null。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;触发器组&quot;</span> +triggerGroup +<span class="string">&quot; 正在被暂停&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">triggerResumed</span><span class="params">(TriggerKey triggerKey)</span> &#123;</span><br><span class="line">        <span class="comment">// Scheduler调用这个方法是发生在一个Trigger或Trigger组从暂停中恢复时。假如是Trigger组的话，triggerName参数将为null。参数将为null。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> triggerKey.getName();</span><br><span class="line">        System.out.println(name +<span class="string">&quot; 正在从暂停中恢复&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">triggersResumed</span><span class="params">(String triggerGroup)</span> &#123;</span><br><span class="line">        <span class="comment">// Scheduler调用这个方法是发生在一个Trigger或Trigger组从暂停中恢复时。假如是Trigger组的话，triggerName参数将为null。参数将为null。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;触发器组&quot;</span> +triggerGroup +<span class="string">&quot; 正在从暂停中恢复&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jobAdded</span><span class="params">(JobDetail jobDetail)</span> &#123;</span><br><span class="line">        System.out.println(jobDetail.getKey() +<span class="string">&quot; 添加工作任务&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jobDeleted</span><span class="params">(JobKey jobKey)</span> &#123;</span><br><span class="line">        System.out.println(jobKey +<span class="string">&quot; 删除工作任务&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jobPaused</span><span class="params">(JobKey jobKey)</span> &#123;</span><br><span class="line">        System.out.println(jobKey +<span class="string">&quot; 工作任务正在被暂停&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jobsPaused</span><span class="params">(String jobGroup)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;工作组&quot;</span> +jobGroup +<span class="string">&quot; 正在被暂停&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jobResumed</span><span class="params">(JobKey jobKey)</span> &#123;</span><br><span class="line">        System.out.println(jobKey +<span class="string">&quot; 正在从暂停中恢复&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jobsResumed</span><span class="params">(String jobGroup)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;工作组&quot;</span> +jobGroup +<span class="string">&quot; 正在从暂停中恢复&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">schedulerError</span><span class="params">(String msg, SchedulerException cause)</span> &#123;</span><br><span class="line">        <span class="comment">// 在Scheduler的正常运行期间产生一个严重错误时调用这个方法。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;产生严重错误的时候调用&quot;</span> +msg +<span class="string">&quot;    &quot;</span> +cause.getUnderlyingException());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">schedulerInStandbyMode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 当Scheduler处于StandBy模式时，调用该方法。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;调度器被挂起模式的时候调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">schedulerStarted</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调度器开启的时候调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">schedulerStarting</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调度器正在开启的时候调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">schedulerShutdown</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调度器关闭的时候调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">schedulerShuttingdown</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调度器正在关闭的时候调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">schedulingDataCleared</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调度器数据被清除的时候调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、调度器（Scheduler），从工厂中获取调度的实例（默认：实例化new StdSchedulerFactory();）</span></span><br><span class="line">        <span class="type">Scheduler</span> <span class="variable">scheduler</span> <span class="operator">=</span> StdSchedulerFactory.getDefaultScheduler();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、任务实例（JobDetail）定义一个任务调度实例，将该实例与HelloJobSimpleTrigger绑定，任务类需要实现Job接口</span></span><br><span class="line">        <span class="type">JobDetail</span> <span class="variable">jobDetail</span> <span class="operator">=</span> JobBuilder.newJob(Job1.class) <span class="comment">// 加载任务类，与HelloJob完成绑定，要求HelloJob实现Job接口</span></span><br><span class="line">                .withIdentity(<span class="string">&quot;job1&quot;</span>, <span class="string">&quot;group1&quot;</span>) <span class="comment">// 参数1：任务的名称（唯一实例）；参数2：任务组的名称</span></span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、触发器（Trigger）定义触发器，马上执行，然后每5秒重复执行一次</span></span><br><span class="line">        <span class="type">Trigger</span> <span class="variable">trigger</span> <span class="operator">=</span> TriggerBuilder.newTrigger()</span><br><span class="line">                .withIdentity(<span class="string">&quot;trigger1&quot;</span>, <span class="string">&quot;group1&quot;</span>) <span class="comment">// 参数1：触发器的名称（唯一实例）；参数2：触发器组的名称</span></span><br><span class="line">                .startNow()</span><br><span class="line">                .withSchedule(SimpleScheduleBuilder.repeatSecondlyForever(<span class="number">5</span>)</span><br><span class="line">                        .withRepeatCount(<span class="number">2</span>))  <span class="comment">// 每5秒执行一次，连续执行3次后停止，默认是0</span></span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">// 4、让调度器关联任务和触发器，保证按照触发器定义的调整执行任务</span></span><br><span class="line">        scheduler.scheduleJob(jobDetail, trigger);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建并注册一个局部的Job Listener，表示指定的任务Job</span></span><br><span class="line">        <span class="comment">//scheduler.getListenerManager().addJobListener(new JobListener1(), KeyMatcher.keyEquals(JobKey.jobKey(&quot;job1&quot;, &quot;group1&quot;)));</span></span><br><span class="line">        <span class="comment">//scheduler.getListenerManager().addTriggerListener(new TriggerListener1(), KeyMatcher.keyEquals(TriggerKey.triggerKey(&quot;trigger1&quot;, &quot;group1&quot;)));</span></span><br><span class="line">        scheduler.getListenerManager().addSchedulerListener(<span class="keyword">new</span> <span class="title class_">SchedulerListener1</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5、启动</span></span><br><span class="line">        scheduler.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>定时任务</tag>
        <tag>Quartz</tag>
      </tags>
  </entry>
  <entry>
    <title>Quartz（6-SpringBoot整合）</title>
    <url>/blog/2024/12/14/Java/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/Quartz/Quartz%EF%BC%886-SpringBoot%E6%95%B4%E5%90%88%EF%BC%89/</url>
    <content><![CDATA[<h2 id="Quartz-自动装配机制">Quartz 自动装配机制</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(&quot;spring.quartz&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuartzProperties</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">JobStoreType</span> <span class="variable">jobStoreType</span> <span class="operator">=</span> JobStoreType.MEMORY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String schedulerName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">autoStartup</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Duration</span> <span class="variable">startupDelay</span> <span class="operator">=</span> Duration.ofSeconds(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">waitForJobsToCompleteOnShutdown</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">overwriteExistingJobs</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; properties = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Jdbc</span> <span class="variable">jdbc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jdbc</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Jdbc</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_SCHEMA_LOCATION</span> <span class="operator">=</span> <span class="string">&quot;classpath:org/quartz/impl/&quot;</span></span><br><span class="line">                + <span class="string">&quot;jdbcjobstore/tables_@@platform@@.sql&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">String</span> <span class="variable">schema</span> <span class="operator">=</span> DEFAULT_SCHEMA_LOCATION;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">DataSourceInitializationMode</span> <span class="variable">initializeSchema</span> <span class="operator">=</span> DataSourceInitializationMode.EMBEDDED;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> List&lt;String&gt; commentPrefix = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;#&quot;</span>, <span class="string">&quot;--&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; Scheduler.class, SchedulerFactoryBean.class, PlatformTransactionManager.class &#125;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(QuartzProperties.class)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(&#123; DataSourceAutoConfiguration.class, HibernateJpaAutoConfiguration.class,</span></span><br><span class="line"><span class="meta">		LiquibaseAutoConfiguration.class, FlywayAutoConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuartzAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="keyword">public</span> SchedulerFactoryBean <span class="title function_">quartzScheduler</span><span class="params">(QuartzProperties properties,</span></span><br><span class="line"><span class="params">            ObjectProvider&lt;SchedulerFactoryBeanCustomizer&gt; customizers, ObjectProvider&lt;JobDetail&gt; jobDetails,</span></span><br><span class="line"><span class="params">            Map&lt;String, Calendar&gt; calendars, ObjectProvider&lt;Trigger&gt; triggers, ApplicationContext applicationContext)</span> &#123;</span><br><span class="line">        <span class="type">SchedulerFactoryBean</span> <span class="variable">schedulerFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SchedulerFactoryBean</span>();</span><br><span class="line">        <span class="type">SpringBeanJobFactory</span> <span class="variable">jobFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringBeanJobFactory</span>();</span><br><span class="line">        jobFactory.setApplicationContext(applicationContext);</span><br><span class="line">        schedulerFactoryBean.setJobFactory(jobFactory);</span><br><span class="line">        <span class="keyword">if</span> (properties.getSchedulerName() != <span class="literal">null</span>) &#123;</span><br><span class="line">            schedulerFactoryBean.setSchedulerName(properties.getSchedulerName());</span><br><span class="line">        &#125;</span><br><span class="line">        schedulerFactoryBean.setAutoStartup(properties.isAutoStartup());</span><br><span class="line">        schedulerFactoryBean.setStartupDelay((<span class="type">int</span>) properties.getStartupDelay().getSeconds());</span><br><span class="line">        schedulerFactoryBean.setWaitForJobsToCompleteOnShutdown(properties.isWaitForJobsToCompleteOnShutdown());</span><br><span class="line">        schedulerFactoryBean.setOverwriteExistingJobs(properties.isOverwriteExistingJobs());</span><br><span class="line">        <span class="keyword">if</span> (!properties.getProperties().isEmpty()) &#123;</span><br><span class="line">            schedulerFactoryBean.setQuartzProperties(asProperties(properties.getProperties()));</span><br><span class="line">        &#125;</span><br><span class="line">        schedulerFactoryBean.setJobDetails(jobDetails.orderedStream().toArray(JobDetail[]::<span class="keyword">new</span>));</span><br><span class="line">        schedulerFactoryBean.setCalendars(calendars);</span><br><span class="line">        schedulerFactoryBean.setTriggers(triggers.orderedStream().toArray(Trigger[]::<span class="keyword">new</span>));</span><br><span class="line">        customizers.orderedStream().forEach((customizer) -&gt; customizer.customize(schedulerFactoryBean));</span><br><span class="line">        <span class="keyword">return</span> schedulerFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Properties <span class="title function_">asProperties</span><span class="params">(Map&lt;String, String&gt; source)</span> &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.putAll(source);</span><br><span class="line">        <span class="keyword">return</span> properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">    <span class="meta">@ConditionalOnSingleCandidate(DataSource.class)</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;spring.quartz&quot;, name = &quot;job-store-type&quot;, havingValue = &quot;jdbc&quot;)</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">JdbcStoreTypeConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="meta">@Order(0)</span></span><br><span class="line">        <span class="keyword">public</span> SchedulerFactoryBeanCustomizer <span class="title function_">dataSourceCustomizer</span><span class="params">(QuartzProperties properties, DataSource dataSource,</span></span><br><span class="line"><span class="params">                <span class="meta">@QuartzDataSource</span> ObjectProvider&lt;DataSource&gt; quartzDataSource,</span></span><br><span class="line"><span class="params">                ObjectProvider&lt;PlatformTransactionManager&gt; transactionManager)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (schedulerFactoryBean) -&gt; &#123;</span><br><span class="line">                <span class="type">DataSource</span> <span class="variable">dataSourceToUse</span> <span class="operator">=</span> getDataSource(dataSource, quartzDataSource);</span><br><span class="line">                schedulerFactoryBean.setDataSource(dataSourceToUse);</span><br><span class="line">                <span class="type">PlatformTransactionManager</span> <span class="variable">txManager</span> <span class="operator">=</span> transactionManager.getIfUnique();</span><br><span class="line">                <span class="keyword">if</span> (txManager != <span class="literal">null</span>) &#123;</span><br><span class="line">                    schedulerFactoryBean.setTransactionManager(txManager);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> DataSource <span class="title function_">getDataSource</span><span class="params">(DataSource dataSource, ObjectProvider&lt;DataSource&gt; quartzDataSource)</span> &#123;</span><br><span class="line">            <span class="type">DataSource</span> <span class="variable">dataSourceIfAvailable</span> <span class="operator">=</span> quartzDataSource.getIfAvailable();</span><br><span class="line">            <span class="keyword">return</span> (dataSourceIfAvailable != <span class="literal">null</span>) ? dataSourceIfAvailable : dataSource;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">        <span class="keyword">public</span> QuartzDataSourceInitializer <span class="title function_">quartzDataSourceInitializer</span><span class="params">(DataSource dataSource,</span></span><br><span class="line"><span class="params">                <span class="meta">@QuartzDataSource</span> ObjectProvider&lt;DataSource&gt; quartzDataSource, ResourceLoader resourceLoader,</span></span><br><span class="line"><span class="params">                QuartzProperties properties)</span> &#123;</span><br><span class="line">            <span class="type">DataSource</span> <span class="variable">dataSourceToUse</span> <span class="operator">=</span> getDataSource(dataSource, quartzDataSource);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">QuartzDataSourceInitializer</span>(dataSourceToUse, resourceLoader, properties);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Additional configuration to ensure that &#123;<span class="doctag">@link</span> SchedulerFactoryBean&#125; and</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@link</span> Scheduler&#125; beans depend on any beans that perform data source</span></span><br><span class="line"><span class="comment">         * initialization.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">QuartzSchedulerDependencyConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Bean</span></span><br><span class="line">            <span class="keyword">static</span> SchedulerDependsOnBeanFactoryPostProcessor <span class="title function_">quartzSchedulerDataSourceInitializerDependsOnBeanFactoryPostProcessor</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SchedulerDependsOnBeanFactoryPostProcessor</span>(QuartzDataSourceInitializer.class);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Bean</span></span><br><span class="line">            <span class="meta">@ConditionalOnBean(FlywayMigrationInitializer.class)</span></span><br><span class="line">            <span class="keyword">static</span> SchedulerDependsOnBeanFactoryPostProcessor <span class="title function_">quartzSchedulerFlywayDependsOnBeanFactoryPostProcessor</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SchedulerDependsOnBeanFactoryPostProcessor</span>(FlywayMigrationInitializer.class);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">            <span class="meta">@ConditionalOnClass(SpringLiquibase.class)</span></span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LiquibaseQuartzSchedulerDependencyConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Bean</span></span><br><span class="line">                <span class="meta">@ConditionalOnBean(SpringLiquibase.class)</span></span><br><span class="line">                <span class="keyword">static</span> SchedulerDependsOnBeanFactoryPostProcessor <span class="title function_">quartzSchedulerLiquibaseDependsOnBeanFactoryPostProcessor</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SchedulerDependsOnBeanFactoryPostProcessor</span>(SpringLiquibase.class);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> AbstractDependsOnBeanFactoryPostProcessor&#125; for Quartz &#123;<span class="doctag">@link</span> Scheduler&#125; and</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> SchedulerFactoryBean&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SchedulerDependsOnBeanFactoryPostProcessor</span> <span class="keyword">extends</span> <span class="title class_">AbstractDependsOnBeanFactoryPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">        SchedulerDependsOnBeanFactoryPostProcessor(Class&lt;?&gt;... dependencyTypes) &#123;</span><br><span class="line">            <span class="built_in">super</span>(Scheduler.class, SchedulerFactoryBean.class, dependencyTypes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SpringBoot 整合 Quartz 后，通过 spring.quartz 前缀可以设置其对应的属性值，实例化 SchedulerFactoryBean 后，调用其 afterPropertiesSet()方法去初始化 Quartz 配置信息（详细查看 SchedulerFactoryBean 的 initialize()方法及 <strong>Quartz（3-Scheduler）文章</strong>）</p>
<p><img src="2.png" alt=""></p>
<p><img src="3.png" alt=""></p>
<p><img src="4.png" alt=""></p>
<h2 id="单机版配置">单机版配置</h2>
<h3 id="依赖">依赖</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-quartz<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="任务创建">任务创建</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJob</span> <span class="keyword">extends</span> <span class="title class_">QuartzJobBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Log</span> <span class="variable">logger</span> <span class="operator">=</span> LogFactory.getLog(TestJob.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">executeInternal</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;测试======&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>可以实现 Job 接口，也可以继承 QuartzJobBean</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义任务描述和具体的执行时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuartzConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> JobDetail <span class="title function_">jobDetail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//指定任务描述具体的实现类</span></span><br><span class="line">        <span class="keyword">return</span> JobBuilder.newJob(TestJob.class)</span><br><span class="line">                <span class="comment">// 指定任务的名称</span></span><br><span class="line">                .withIdentity(<span class="string">&quot;testJob&quot;</span>)</span><br><span class="line">                <span class="comment">// 任务描述</span></span><br><span class="line">                .withDescription(<span class="string">&quot;testJob&quot;</span>)</span><br><span class="line">                <span class="comment">// 每次任务执行后进行存储</span></span><br><span class="line">                .storeDurably()</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Trigger <span class="title function_">trigger</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//创建触发器</span></span><br><span class="line">        <span class="keyword">return</span> TriggerBuilder.newTrigger()</span><br><span class="line">                <span class="comment">// 绑定工作任务</span></span><br><span class="line">                .forJob(jobDetail())</span><br><span class="line">                <span class="comment">// 每隔 5 秒执行一次 job</span></span><br><span class="line">                .withSchedule(SimpleScheduleBuilder.repeatSecondlyForever(<span class="number">5</span>))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>项目初始化手动创建任务</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JobInit</span> <span class="keyword">implements</span> <span class="title class_">ApplicationRunner</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ID</span> <span class="operator">=</span> <span class="string">&quot;SUMMERDAY&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Scheduler scheduler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">JobDetail</span> <span class="variable">jobDetail</span> <span class="operator">=</span> JobBuilder.newJob(TestJob.class)</span><br><span class="line">                .withIdentity(ID + <span class="string">&quot; 01&quot;</span>)</span><br><span class="line">                .storeDurably()</span><br><span class="line">                .build();</span><br><span class="line">        <span class="type">CronScheduleBuilder</span> <span class="variable">scheduleBuilder</span> <span class="operator">=</span></span><br><span class="line">                CronScheduleBuilder.cronSchedule(<span class="string">&quot;0/5 * * * * ? *&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建任务触发器</span></span><br><span class="line">        <span class="type">Trigger</span> <span class="variable">trigger</span> <span class="operator">=</span> TriggerBuilder.newTrigger()</span><br><span class="line">                .forJob(jobDetail)</span><br><span class="line">                .withIdentity(ID + <span class="string">&quot; 01Trigger&quot;</span>)</span><br><span class="line">                .withSchedule(scheduleBuilder)</span><br><span class="line">                .startNow() <span class="comment">//立即執行一次任務</span></span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">// 手动将触发器与任务绑定到调度器内</span></span><br><span class="line">        scheduler.scheduleJob(jobDetail, trigger);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="yaml-配置">yaml 配置</h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># Quartz 的配置，对应 QuartzProperties 配置类</span></span><br><span class="line">  <span class="attr">quartz:</span></span><br><span class="line">    <span class="attr">job-store-type:</span> <span class="string">memory</span> <span class="comment"># Job 存储器类型。默认为 memory 表示内存，可选 jdbc 使用数据库。</span></span><br><span class="line">    <span class="attr">auto-startup:</span> <span class="literal">true</span> <span class="comment"># Quartz 是否自动启动</span></span><br><span class="line">    <span class="attr">startup-delay:</span> <span class="number">0</span> <span class="comment"># 延迟 N 秒启动</span></span><br><span class="line">    <span class="attr">wait-for-jobs-to-complete-on-shutdown:</span> <span class="literal">true</span> <span class="comment"># 应用关闭时，是否等待定时任务执行完成。默认为 false ，建议设置为 true</span></span><br><span class="line">    <span class="attr">overwrite-existing-jobs:</span> <span class="literal">false</span> <span class="comment"># 是否覆盖已有 Job 的配置</span></span><br><span class="line">    <span class="attr">properties:</span> <span class="comment"># 添加 Quartz Scheduler 附加属性</span></span><br><span class="line">      <span class="attr">org:</span></span><br><span class="line">        <span class="attr">quartz:</span></span><br><span class="line">          <span class="attr">threadPool:</span></span><br><span class="line">            <span class="attr">threadCount:</span> <span class="number">25</span> <span class="comment"># 线程池大小。默认为 10 。</span></span><br><span class="line">            <span class="attr">threadPriority:</span> <span class="number">5</span> <span class="comment"># 线程优先级</span></span><br><span class="line">            <span class="attr">class:</span> <span class="string">org.quartz.simpl.SimpleThreadPool</span> <span class="comment"># 线程池类型</span></span><br></pre></td></tr></table></figure>
<h2 id="持久化配置">持久化配置</h2>
<h3 id="集群部署">集群部署</h3>
<p><img src="1.png" alt=""></p>
<p>一个 Quartz 集群中的每个节点是一个独立的 Quartz 应用，它又管理着其他的节点。这就意味着你必须对每个节点分别启动或停止。Quartz 集群中，独立的 Quartz 节点并不与另一其的节点或是管理节点通信，而是通过同一个数据库表来感知到另一 Quartz 应用的。因为 Quartz 集群依赖于数据库，所以必须首先创建 Quartz 数据库表，Quartz 发布包中包括了所有被支持的数据库平台的 SQL 脚本。</p>
<h3 id="创建数据库表">创建数据库表</h3>
<p>针对不同的数据库，org.quartz.impl.jdbcjobstore 包下提供了不同建表脚本，数据库脚本放在 org\quartz-scheduler\quartz\2.3.2\quartz-2.3.2.jar! 包中的\org\quartz\impl\jdbcjobstore 路径下</p>
<table>
<thead>
<tr>
<th>表名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>qrtz_fired_triggers</td>
<td>存储已触发的 trigger 相关信息</td>
</tr>
<tr>
<td>qrtz_paused_trigger_grps</td>
<td>存储已暂停的 trigger 组信息</td>
</tr>
<tr>
<td>qrtz_scheduler_state</td>
<td>存储 Scheduler 状态信息</td>
</tr>
<tr>
<td>qrtz_locks</td>
<td>存储悲观锁的信息</td>
</tr>
<tr>
<td>qrtz_simple_triggers</td>
<td>存储 Simple trigger 信息</td>
</tr>
<tr>
<td>qrtz_simprop_triggers</td>
<td>存储其他几种 trigger 信息</td>
</tr>
<tr>
<td>qrtz_cron_triggers</td>
<td>存储 cron trigger 信息</td>
</tr>
<tr>
<td>qrtz_blob_triggers</td>
<td>blog 类型存储 triggers</td>
</tr>
<tr>
<td>qrtz_triggers</td>
<td>存储已配置的 trigger 信息</td>
</tr>
<tr>
<td>qrtz_job_details</td>
<td>存储每一个已配置的 job details</td>
</tr>
<tr>
<td>qrtz_calendars</td>
<td>以 blog 类型存储 Calendar 信息</td>
</tr>
</tbody>
</table>
<p>所有的表中都含有一个 SCHED_NAME 字段，对应我们配置的 scheduler-name，相同 Scheduler-name 的节点，形成一个 Quartz 集群</p>
<h3 id="存储类型">存储类型</h3>
<p>Quartz 提供两种基本作业存储类型：RAMJobStore 和 JDBC 作业存储。在默认情况下 Quartz 将任务调度的运行信息保存在内存中，这种方法提供了最佳的性能，因为内存中数据访问最快。不足之处是缺乏数据的持久性，当程序路途停止或系统崩溃时，所有运行的信息都会丢失。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>RAMJobStore</td>
<td>不要外部数据库，配置容易，运行速度快</td>
<td>因为调度程序信息是存储在被分配给 JVM 的内存里面，所以，当应用程序停止运行时，所有调度信息将被丢失。另外因为存储到 JVM 内存里面，所以可以存储多少个 Job 和 Trigger 将会受到限制</td>
</tr>
<tr>
<td>JDBC 作业存储</td>
<td>支持集群，因为所有的任务信息都会保存到数据库中，可以控制事物，还有就是如果应用服务器关闭或者重启，任务信息都不会丢失，并且可以恢复因服务器关闭或者重启而导致执行失败的任务</td>
<td>运行速度的快慢取决与连接数据库的快慢</td>
</tr>
</tbody>
</table>
<h3 id="事务管理类型">事务管理类型</h3>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>JobStoreTX</td>
<td>如果不需要将调度命令（例如添加和删除 triggers）绑定到其他事务，那么可以通过使用 JobStoreTX 管理事务（这是最常见的选择）</td>
</tr>
<tr>
<td>JobStoreCMT</td>
<td>如果需要 Quartz 与其他事务（即 J2EE 应用程序服务器）一起工作，那么应该使用 JobStoreCMT，这种情况下，Quartz 将让应用程序服务器容器管理事务</td>
</tr>
</tbody>
</table>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#需要使用哪一种事务类型，配置文件中就指定谁</span></span><br><span class="line"><span class="comment">#org.quartz.jobStore.class=org.quartz.impl.jdbcjobstore.JobStoreTX</span></span><br><span class="line"><span class="attr">org.quartz.jobStore.class</span>=<span class="string">org.quartz.impl.jdbcjobstore.JobStoreCMT</span></span><br></pre></td></tr></table></figure>
<h3 id="数据库驱动代理">数据库驱动代理</h3>
<p>针对不同的数据库制作了不同的数据库的代理，其中使用最多的是 StdJDBCDelegate ，它是一个使用 JDBC 代码（和 SQL 语句）来执行其工作的委托。其他驱动代理可以在 “org.quartz.impl.jdbcjobstore” 包或其子包中找到。如 DB2v6Delegate（用于 DB2 版本 6 及更早版本），HSQLDBDelegate（HSQLDB），MSSQLDelegate（SQLServer），PostgreSQLDelegate（PostgreSQL），WeblogicDelegate（用于使用 Weblogic 创建的 JDBC 驱动程序）</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">org.quartz.jobStore.driverDelegateClass</span> = <span class="string">org.quartz.impl.jdbcjobstore.StdJDBCDelegate</span></span><br></pre></td></tr></table></figure>
<p><img src="5.png" alt=""></p>
<h3 id="配置信息">配置信息</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 实现对 Quartz 的自动化配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-quartz<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.19<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>yaml 配置（使用其自动装配机制）</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/quartz?serverTimezone=GMT%2B8</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">  <span class="attr">quartz:</span></span><br><span class="line">    <span class="comment"># 使用数据库存储</span></span><br><span class="line">    <span class="attr">job-store-type:</span> <span class="string">jdbc</span></span><br><span class="line">    <span class="comment"># 相同 Scheduler 名字的节点，形成一个 Quartz 集群</span></span><br><span class="line">    <span class="attr">scheduler-name:</span> <span class="string">hyhScheduler</span></span><br><span class="line">    <span class="comment"># 应用关闭时，是否等待定时任务执行完成。默认为 false ，建议设置为 true</span></span><br><span class="line">    <span class="attr">wait-for-jobs-to-complete-on-shutdown:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">jdbc:</span></span><br><span class="line">      <span class="comment"># 是否自动使用 SQL 初始化 Quartz 表结构。这里设置成 never ，我们手动创建表结构。</span></span><br><span class="line">      <span class="attr">initialize-schema:</span> <span class="string">never</span></span><br><span class="line">      <span class="comment"># 用于初始化数据库架构的SQL文件的路径</span></span><br><span class="line">      <span class="comment">#schema: classpath:org/quartz/impl/jdbcjobstore/tables_@@platform@@.sql</span></span><br><span class="line">    <span class="attr">properties:</span></span><br><span class="line">      <span class="attr">org:</span></span><br><span class="line">        <span class="attr">quartz:</span></span><br><span class="line">          <span class="comment">#延时启动，要有足够长的时间让你的应用先启动完成后再让Scheduler启动（单位秒）</span></span><br><span class="line">          <span class="attr">startup-delay:</span> <span class="number">60</span></span><br><span class="line">          <span class="comment">#是否每次系统运行都会清空数据库中的Job信息，重新进行初始化</span></span><br><span class="line">          <span class="attr">overwrite-existing-jobs:</span> <span class="literal">false</span></span><br><span class="line">          <span class="attr">scheduler:</span></span><br><span class="line">            <span class="comment"># 默认主机名和时间戳生成实例ID,可以是任何字符串，但对于所有调度程序来说，必须是唯一的 对应qrtz_scheduler_state INSTANCE_NAME字段</span></span><br><span class="line">            <span class="attr">instanceId:</span> <span class="string">AUTO</span></span><br><span class="line">            <span class="attr">instanceName:</span> <span class="string">hyhScheduler</span></span><br><span class="line">          <span class="comment"># JobStore 相关配置</span></span><br><span class="line">          <span class="attr">jobStore:</span></span><br><span class="line">            <span class="comment"># 持久化配置</span></span><br><span class="line">            <span class="comment"># 此存储机制用于Quartz独立于应用容器的事务管理，如果是Tomcat容器管理的数据源，那我们定义的事务也不会传播给Quartz框架内部。</span></span><br><span class="line">            <span class="comment"># 通俗的讲就是不管我们的Service服务本身业务代码是否执行成功，只要代码中调用了Quartz API的数据库操作，那任务状态就永久持久化了，</span></span><br><span class="line">            <span class="comment"># 就算业务代码抛出运行时异常任务状态也不会回滚到之前的状态。与之相反的是JobStoreCMT。</span></span><br><span class="line">            <span class="attr">class:</span> <span class="string">org.quartz.impl.jdbcjobstore.JobStoreTX</span></span><br><span class="line">            <span class="comment"># JDBC代理类，仅为数据库制作了特定于数据库的代理</span></span><br><span class="line">            <span class="attr">driverDelegateClass:</span> <span class="string">org.quartz.impl.jdbcjobstore.StdJDBCDelegate</span></span><br><span class="line">            <span class="comment"># Quartz 表前缀</span></span><br><span class="line">            <span class="attr">tablePrefix:</span> <span class="string">QRTZ_</span></span><br><span class="line">            <span class="comment"># 是集群模式</span></span><br><span class="line">            <span class="attr">isClustered:</span> <span class="literal">true</span></span><br><span class="line">            <span class="comment"># 设置此实例&quot;检入&quot;与群集的其他实例的频率（以毫秒为单位）。影响检测失败实例的速度。</span></span><br><span class="line">            <span class="attr">clusterCheckinInterval:</span> <span class="number">1000</span></span><br><span class="line">            <span class="comment">#让JDBCJobStore将JobDataMaps中的所有值都作为字符串，因此可以作为键值对存储而不是在BLOB列中以其序列化形式存储，从而避免序列化的版本问题</span></span><br><span class="line">            <span class="attr">useProperties:</span> <span class="literal">false</span></span><br><span class="line">            <span class="comment">#超过这个时间还未触发的trigger，就被认为发生了misfire，默认60s。job成功触发叫fire，misfire就是未成功触发。</span></span><br><span class="line">            <span class="attr">misfireThreshold:</span> <span class="number">60000</span></span><br><span class="line">          <span class="comment"># 线程池相关配置</span></span><br><span class="line">          <span class="attr">threadPool:</span></span><br><span class="line">            <span class="comment"># 线程池大小。默认为 10</span></span><br><span class="line">            <span class="attr">threadCount:</span> <span class="number">25</span></span><br><span class="line">            <span class="comment"># 线程优先级</span></span><br><span class="line">            <span class="attr">threadPriority:</span> <span class="number">5</span></span><br><span class="line">            <span class="comment"># 线程池类型</span></span><br><span class="line">            <span class="attr">class:</span> <span class="string">org.quartz.simpl.SimpleThreadPool</span></span><br></pre></td></tr></table></figure>
<p>注意：同一集群下，instanceName 必须相同，instanceId 可自动生成，isClustered 为 true，持久化存储，指定数据库类型对应的驱动类和数据源连接。</p>
<ol start="2">
<li>自定义 properties 和配置类（使用 Quartz 的 initialize()方法去查找对应的 quartz.properties 文件）</li>
</ol>
<p><strong>quartz.properties</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#调度标识名 集群中每一个实例都必须使用相同的名称</span></span><br><span class="line"><span class="attr">org.quartz.scheduler.instanceName</span> = <span class="string">hyhScheduler</span></span><br><span class="line"><span class="comment">#ID设置为自动获取 每一个必须不同</span></span><br><span class="line"><span class="attr">org.quartz.scheduler.instanceId</span> = <span class="string">AUTO</span></span><br><span class="line"><span class="comment">#数据保存方式为持久化</span></span><br><span class="line"><span class="comment">#springboot版本2.6.x请使用：org.springframework.scheduling.quartz.LocalDataSourceJobStore</span></span><br><span class="line"><span class="comment">#org.quartz.jobStore.class=org.quartz.impl.jdbcjobstore.JobStoreTX</span></span><br><span class="line"><span class="attr">org.quartz.jobStore.class</span>=<span class="string">org.springframework.scheduling.quartz.JobStoreTX</span></span><br><span class="line"><span class="comment">#表的前缀</span></span><br><span class="line"><span class="attr">org.quartz.jobStore.tablePrefix</span> = <span class="string">QRTZ_</span></span><br><span class="line"><span class="comment">#设置为TRUE不会出现序列化非字符串类到 BLOB 时产生的类版本问题</span></span><br><span class="line"><span class="attr">org.quartz.jobStore.useProperties</span> = <span class="string">true</span></span><br><span class="line"><span class="comment">#加入集群</span></span><br><span class="line"><span class="attr">org.quartz.jobStore.isClustered</span> = <span class="string">true</span></span><br><span class="line"><span class="comment">#ThreadPool 实现的类名</span></span><br><span class="line"><span class="attr">org.quartz.threadPool.class</span> = <span class="string">org.quartz.simpl.SimpleThreadPool</span></span><br><span class="line"><span class="comment">#调度实例失效的检查时间间隔</span></span><br><span class="line"><span class="attr">org.quartz.jobStore.clusterCheckinInterval</span> = <span class="string">20000</span></span><br><span class="line"><span class="comment">#容许的最大作业延长时间</span></span><br><span class="line"><span class="attr">org.quartz.jobStore.misfireThreshold</span> = <span class="string">60000</span></span><br><span class="line"><span class="comment">#线程数量</span></span><br><span class="line"><span class="attr">org.quartz.threadPool.threadCount</span> = <span class="string">10</span></span><br><span class="line"><span class="comment">#线程优先级</span></span><br><span class="line"><span class="attr">org.quartz.threadPool.threadPriority</span> = <span class="string">5</span></span><br><span class="line"><span class="comment">#自创建父线程</span></span><br><span class="line"><span class="attr">org.quartz.threadPool.threadsInheritContextClassLoaderOfInitializingThread</span> = <span class="string">true</span></span><br><span class="line"><span class="comment">#org.quartz.threadPool.threadNamePrefix=liftsail</span></span><br></pre></td></tr></table></figure>
<p><strong>配置类（参考 QuartzAutoConfiguration）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JobFactory</span> <span class="keyword">extends</span> <span class="title class_">AdaptableJobFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> AutowireCapableBeanFactory capableBeanFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Job 对象的实例化过程是在 Quartz 中进行的，注入的实体类是在 Spring 容器当中的 所以在 job 中无法注入 Spring 容器的实体类。</span></span><br><span class="line">    <span class="comment">// 将 Job Bean 也纳入到 Spring 容器的管理之中，Spring 容器自然能够为 Job Bean 自动装配好所需的依赖。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">createJobInstance</span><span class="params">(TriggerFiredBundle bundle)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 调用父类的方法，来实现对 Job 的实例化。</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">jobInstance</span> <span class="operator">=</span> <span class="built_in">super</span>.createJobInstance(bundle);</span><br><span class="line">        <span class="comment">// 进行注入，调用自身方法为创建好的 Job 实例进行属性自动装配并将其纳入到 Spring 容器的管理之中</span></span><br><span class="line">        capableBeanFactory.autowireBean(jobInstance);</span><br><span class="line">        <span class="keyword">return</span> jobInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JobConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> JobFactory jobFactory;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SchedulerFactoryBean <span class="title function_">schedulerFactoryBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SchedulerFactoryBean</span> <span class="variable">schedulerFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SchedulerFactoryBean</span>();</span><br><span class="line">        schedulerFactoryBean.setJobFactory(jobFactory);</span><br><span class="line">        <span class="comment">// 配置数据源</span></span><br><span class="line">        schedulerFactoryBean.setDataSource(dataSource);</span><br><span class="line">        <span class="comment">// 用于 quartz 集群，QuartzScheduler 启动时更新己存在的 Job</span></span><br><span class="line">        schedulerFactoryBean.setOverwriteExistingJobs(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 延时启动，应用启动 1 秒后</span></span><br><span class="line">        schedulerFactoryBean.setStartupDelay(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 设置加载的配置文件</span></span><br><span class="line">        schedulerFactoryBean.setConfigLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;quartz.properties&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> schedulerFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Scheduler <span class="title function_">scheduler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> schedulerFactoryBean().getScheduler();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="基本使用">基本使用</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JobInit</span> <span class="keyword">implements</span> <span class="title class_">ApplicationRunner</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ID</span> <span class="operator">=</span> <span class="string">&quot;SUMMERDAY&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Scheduler scheduler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">JobDetail</span> <span class="variable">jobDetail</span> <span class="operator">=</span> JobBuilder.newJob(SecondJob.class)</span><br><span class="line">                .withIdentity(ID + <span class="string">&quot; 02&quot;</span>)</span><br><span class="line">                .storeDurably()</span><br><span class="line">                .build();</span><br><span class="line">        <span class="type">CronScheduleBuilder</span> <span class="variable">scheduleBuilder</span> <span class="operator">=</span></span><br><span class="line">                CronScheduleBuilder.cronSchedule(<span class="string">&quot;0/10 * * * * ? *&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建任务触发器</span></span><br><span class="line">        <span class="type">Trigger</span> <span class="variable">trigger</span> <span class="operator">=</span> TriggerBuilder.newTrigger()</span><br><span class="line">                .forJob(jobDetail)</span><br><span class="line">                .withIdentity(ID + <span class="string">&quot; 02Trigger&quot;</span>)</span><br><span class="line">                .withSchedule(scheduleBuilder)</span><br><span class="line">                .startNow() <span class="comment">//立即執行一次任務</span></span><br><span class="line">                .build();</span><br><span class="line">        Set&lt;Trigger&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        set.add(trigger);</span><br><span class="line">        <span class="comment">// boolean replace 表示启动时对数据库中的 quartz 的任务进行覆盖。</span></span><br><span class="line">        scheduler.scheduleJob(jobDetail, set, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>定时任务</tag>
        <tag>Quartz</tag>
      </tags>
  </entry>
  <entry>
    <title>Git（1-基本概念）</title>
    <url>/blog/2024/12/05/Java/%E5%B7%A5%E4%BD%9C%E6%8A%80%E5%B7%A7/Git/Git%EF%BC%881-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%89/</url>
    <content><![CDATA[<h2 id="Git-与-SVN">Git 与 SVN</h2>
<p>Git 属于分布式版本控制，而 SVN 属于集中式版本控制</p>
<ol>
<li>集中式版本控制只有中心服务器拥有一份代码，每个开发者只能从中央服务器获取代码，并且提交修改也需要依赖于中央服务器；而分布式版本控制每个人的电脑上都有一份完整的代码，可以独立地进行开发和版本控制，在本地进行提交、分支、合并等操作</li>
<li>集中式版本控制有安全性问题，当中心服务器挂了所有人都没办法工作了，需要连网才能工作，如果网速过慢，那么提交一个文件会慢的无法让人忍受，新建一个分支相当于复制一份完整代码；而分布式版本控制不需要连网就能工作，新建分支、合并分支操作速度非常快</li>
</ol>
<h2 id="基本概念">基本概念</h2>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>概念名称</strong></th>
<th style="text-align:left"><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">工作区（Workspace）</td>
<td style="text-align:left">在电脑里能看到的代码库目录，新增、修改的文件会提交到暂存区</td>
</tr>
<tr>
<td style="text-align:left">暂存区（stage 或 index）</td>
<td style="text-align:left">用于临时存放文件的修改，实际上它只是一个文件（<code>.git/index</code>），保存待提交的文件列表信息。</td>
</tr>
<tr>
<td style="text-align:left">版本库/仓库（Repository）</td>
<td style="text-align:left">Git 的管理仓库，管理版本的数据库，记录文件/目录状态的地方，所有内容的修改记录（版本）都在这里。</td>
</tr>
<tr>
<td style="text-align:left">服务端/远程仓库（origin 或 remote）</td>
<td style="text-align:left">服务端的版本库，专用的 Git 服务器，为多人共享提供服务，承担中心服务器的角色。本地版本库通过 push 指令把代码推送到服务端版本库。</td>
</tr>
<tr>
<td style="text-align:left">本地仓库</td>
<td style="text-align:left">用户机器上直接使用的的的版本库</td>
</tr>
<tr>
<td style="text-align:left">分支（Branch）</td>
<td style="text-align:left">分支是从主线分离出去的“副本”，可以独立操作而互不干扰，仓库初始化就有一个默认主分支 <code>master</code>。</td>
</tr>
<tr>
<td style="text-align:left">头（HEAD）</td>
<td style="text-align:left">HEAD 类似一个“指针”，指向当前活动分支的最新版本。</td>
</tr>
<tr>
<td style="text-align:left">提交（Commit）</td>
<td style="text-align:left">把暂存区的所有变更的内容提交到当前仓库的活动分支。</td>
</tr>
<tr>
<td style="text-align:left">推送（Push）</td>
<td style="text-align:left">将本地仓库的版本推送到服务端（远程）仓库，与他人共享。</td>
</tr>
<tr>
<td style="text-align:left">拉取（Pull）</td>
<td style="text-align:left">从服务端（远程）仓库获取更新到本地仓库，获取他人共享的更新。</td>
</tr>
<tr>
<td style="text-align:left">获取（Fetch）</td>
<td style="text-align:left">从服务端（远程）仓库更新，作用同拉取（Pull），区别是不会自动合并。</td>
</tr>
<tr>
<td style="text-align:left">冲突（Conflict）</td>
<td style="text-align:left">多人对同一文件的工作副本进行更改，并将这些更改合并到仓库时就会面临冲突，需要人工合并处理。</td>
</tr>
<tr>
<td style="text-align:left">合并（Merge）</td>
<td style="text-align:left">对有冲突的文件进行合并操作，Git 会自动合并变更内容，无法自动处理的冲突内容会提示人工处理。</td>
</tr>
<tr>
<td style="text-align:left">标签（Tags）</td>
<td style="text-align:left">标签指的是某个分支某个特定时间点的状态，可以理解为提交记录的别名，常用来标记版本。</td>
</tr>
<tr>
<td style="text-align:left">master（或 main）</td>
<td style="text-align:left">仓库的“<code>master</code>”分支，默认的主分支，初始化仓库就有了。Github 上创建的仓库默认名字为“<code>main</code>”</td>
</tr>
<tr>
<td style="text-align:left">origin/master</td>
<td style="text-align:left">表示远程仓库（<code>origin</code>）的“<code>master</code>”分支</td>
</tr>
<tr>
<td style="text-align:left">origin/HEAD</td>
<td style="text-align:left">表示远程仓库（<code>origin</code>）的最新提交的位置，一般情况等于“<code>origin/master</code>”</td>
</tr>
</tbody>
</table>
<h2 id="工作区-暂存区-仓库">工作区/暂存区/仓库</h2>
<p>新建一个仓库之后，当前目录就成为了工作区，工作区下有一个隐藏目录.git，它属于 Git 的版本库，Git 的版本库有一个称为 Stage 的暂存区以及最后的 History 版本库，History 存储所有分支信息，使用一个 HEAD 指针指向当前分支</p>
<p><img src="1.png" alt=""></p>
<ol>
<li>workspace（工作区）：平时存放项目代码的地方</li>
<li>index/stage（暂存区）：用于临时存放改动文件</li>
<li>repository（仓库区或版本库）：安全存放数据的位置</li>
<li>remote（远程仓库）：托管代码的服务器</li>
</ol>
<p><img src="2.png" alt=""></p>
<ol>
<li>hexo 为项目目录，也就是 Git 工作区。</li>
<li>项目根目录下隐藏的.git 目录就是 Git 仓库目录了，存放了所有 Git 管理的信息。</li>
<li>.git/config 为该仓库的配置文件，可通过指令修改或直接修改。</li>
<li>index 文件就是存放的暂存区内容。</li>
</ol>
<h2 id="分支">分支</h2>
<h3 id="分支实现">分支实现</h3>
<p>使用指针将每个提交连接成一条时间线，HEAD 指针指向当前分支指针</p>
<p><img src="4.png" alt=""></p>
<h3 id="新建分支">新建分支</h3>
<p>新建一个指针指向时间线的最后一个节点，并让 HEAD 指针指向新分支，表示新分支成为当前分支</p>
<p><img src="5.png" alt=""></p>
<p>每次提交只会让当前分支向前移动，而其他分支指针不会移动</p>
<p><img src="6.png" alt=""></p>
<p>合并分支也只需要改变指针即可</p>
<p><img src="7.png" alt=""></p>
<h3 id="分支冲突">分支冲突</h3>
<p>当两个分支都对同一个文件的同一行进行了修改，在分支合并时就会产生冲突</p>
<p><img src="8.png" alt=""></p>
<p>Git 会使用 &lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt; &gt;&gt;&gt;&gt;&gt; 标记出不同分支的内容，只需要把不同分支中冲突部分修改成一样就能解决冲突</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">Creating a <span class="keyword">new</span> <span class="title class_">branch</span> is quick &amp; simple.</span><br><span class="line">=======</span><br><span class="line">Creating a <span class="keyword">new</span> <span class="title class_">branch</span> is quick AND simple.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure>
<h3 id="快进式合并">快进式合并</h3>
<p>直接将 master 分支指向合并的分支，这种模式下进行分支合并会丢失分支信息，也就不能在分支历史上看出分支信息，可以在合并时加上–no-ff 参数来禁用 Fast forward 模式，并且加上-m 参数让合并产生一个新的 commit，例如：git merge --no-ff -m “merge with no-ff” dev</p>
<p><img src="9.png" alt=""></p>
<h2 id="工作流程">工作流程</h2>
<ol>
<li>暂存（git add）：将需要进行版本管理的文件放入暂存区域。</li>
<li>提交（git commit）：将暂存区域的文件提交到 Git 仓库。</li>
<li>推送（git push）：将本地仓库推送到远程仓库，同步版本库。</li>
<li>获取更新（git fetch/pull）：从服务端更新到本地，获取他人推送的更新，与他人协作、共享。</li>
</ol>
<p><img src="3.png" alt=""></p>
<ol>
<li>git commit -a 指令省略了 add 到暂存区的步骤，直接提交工作区的修改内容到版本库，不包括新增的文件。</li>
<li>git fetch、git pull 都是从远程服务端获取最新记录，区别是 git pull 多了一个步骤，就是自动合并更新工作区。</li>
<li>git checkout .、git checkout [file] 会清除工作区中未添加到暂存区的修改，用暂存区内容替换工作区。</li>
<li>git checkout HEAD .、git checkout HEAD [file] 会清除工作区、暂存区的修改，用 HEAD 指向的当前分支最新版本替换暂存区、工作区。</li>
<li>git diff 用来对比不同部分之间的区别，如暂存区、工作区，最新版本与未提交内容，不同版本之间等。</li>
<li>git reset 是专门用来撤销修改、回退版本的指令，替代上面 checkout 的撤销功能。</li>
</ol>
<h2 id="提交规范">提交规范</h2>
<p><strong>开发提交格式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure>
<p><strong>参数信息</strong></p>
<ol>
<li>type</li>
</ol>
<table>
<thead>
<tr>
<th>功能</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>feat</td>
<td>新功能、新特性</td>
</tr>
<tr>
<td>fix</td>
<td>修改 bug</td>
</tr>
<tr>
<td>perf</td>
<td>更改代码，以提高性能（在不影响代码内部行为的前提下，对程序性能进行优化）</td>
</tr>
<tr>
<td>refactor</td>
<td>代码重构（重构，在不影响代码内部行为、功能下的代码修改）</td>
</tr>
<tr>
<td>docs</td>
<td>文档修改</td>
</tr>
<tr>
<td>style</td>
<td>代码格式修改，注意不是 css 修改（例如分号修改）</td>
</tr>
<tr>
<td>test</td>
<td>测试用例新增、修改</td>
</tr>
<tr>
<td>build</td>
<td>影响项目构建或依赖项修改</td>
</tr>
<tr>
<td>revert</td>
<td>恢复上一次提交</td>
</tr>
<tr>
<td>ci</td>
<td>持续集成相关文件修改</td>
</tr>
<tr>
<td>chore</td>
<td>其他修改（不在上述类型中的修改）</td>
</tr>
<tr>
<td>release</td>
<td>发布新版本</td>
</tr>
<tr>
<td>workflow</td>
<td>工作流相关文件修改</td>
</tr>
</tbody>
</table>
<ol start="2">
<li>scope：commit 影响的范围，比如：route，component，utils，build…</li>
<li>subject：commit 的概述</li>
<li>body：commit 具体修改内容，可以分为多行（或修改的涉及模块）</li>
<li>footer：一些备注，通常是 BREAKING CHANGE 或修复的 bug 的链接</li>
</ol>
<p><strong>使用案例</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">fix：修复bug</span><br><span class="line">report</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git（3-IDEA使用）</title>
    <url>/blog/2024/12/15/Java/%E5%B7%A5%E4%BD%9C%E6%8A%80%E5%B7%A7/Git/Git%EF%BC%883-IDEA%E4%BD%BF%E7%94%A8%EF%BC%89/</url>
    <content><![CDATA[<h2 id="从远程仓库克隆项目">从远程仓库克隆项目</h2>
<ol>
<li>如果上方显示的是VCS选项</li>
</ol>
<p><img src="1.png" alt=""></p>
<p><img src="2.png" alt=""></p>
<ol start="2">
<li>如果上方显示的是Git选项</li>
</ol>
<p><img src="3.png" alt=""></p>
<h2 id="添加文件到暂存区">添加文件到暂存区</h2>
<ol>
<li>在项目里每添加一个文件，IDEA就会询问我们是否将文件添加到Git，选择Add将文件添加添加进Git暂存区</li>
</ol>
<p><img src="5.png" alt=""></p>
<ol start="2">
<li>如果选中了Cancel，可以通过另一种方式添加到Git暂存区，右键点击项目</li>
</ol>
<p><img src="6.png" alt=""></p>
<h2 id="提交到本地仓库">提交到本地仓库</h2>
<p>选中Commit后代码会提交到本地仓库</p>
<p><img src="7.png" alt=""></p>
<h2 id="推送到远程仓库">推送到远程仓库</h2>
<p>选中Push后代码会提交到远程仓库</p>
<p><img src="8.png" alt=""></p>
<h2 id="选择分支">选择分支</h2>
<p>通过Branches可以选择对应的分支进行开发</p>
<p><img src="9.png" alt=""></p>
<h2 id="创建新分支">创建新分支</h2>
<p>通过New Branch可以在某个分支的基础上创建一个新的分支</p>
<p><img src="10.png" alt=""></p>
<p><img src="11.png" alt=""></p>
<h2 id="分支合并">分支合并</h2>
<p>通过Merge选择某个分支的内容合并到当前分支上</p>
<p><img src="D:%5Cblog%5Chexo%5Csource_posts%5CJava%5C%E5%B7%A5%E4%BD%9C%E6%8A%80%E5%B7%A7%5CGit%5CGit%EF%BC%883-Idea%E4%BD%BF%E7%94%A8%EF%BC%89%5C12-1734148431455-43.png" alt=""><img src="13.png" alt=""></p>
<h2 id="提交历史记录查看">提交历史记录查看</h2>
<p><img src="14.png" alt=""><img src="15.png" alt=""></p>
<h2 id="对比不同版本">对比不同版本</h2>
<ol>
<li>Compare with Revision：当前文件与该文件各次提交的版本做比较</li>
<li>Compare with Branch：当前文件与其他分支上该文件的版本进行比较</li>
</ol>
<p><img src="16.png" alt=""></p>
<h2 id="代码搁置">代码搁置</h2>
<p>当我们临时需要开发某个功能时，此时的代码修改后可能还不想进行提交，可以先搁置代码，当完成开发后再回来释放代码，继续之前的代码修改</p>
<ol>
<li>shelve changes（代码搁置和恢复）</li>
</ol>
<p><img src="17.png" alt=""></p>
<p><img src="18.png" alt=""></p>
<p><img src="19.png" alt=""></p>
<p><img src="20.png" alt=""></p>
<ol start="2">
<li>stash changes（搁置代码）和unstash changes（恢复代码）</li>
</ol>
<p><img src="21.png" alt=""></p>
<p><img src="22.png" alt=""></p>
<h2 id="回退版本">回退版本</h2>
<p>当我们想要回退某个分支的版本时，可以通过右键点击提交历史记录，选择reset current branch to here</p>
<p><img src="23.png" alt=""></p>
<p><img src="24.png" alt=""></p>
<ol>
<li>hard：回滚后，本地代码就是你回退版本的代码（彻底回退，所有改动的内容都不见了，慎用）</li>
</ol>
<ul>
<li>移动本地库HEAD指针</li>
<li>重置暂存区</li>
<li>重置工作区</li>
</ul>
<ol start="2">
<li>soft：回滚后，仅仅是把本地库的指针移动了，暂存区和本地的代码是没有做任何的改变，而你上次改动已提交committed到本地库的代码显示是绿色即未提交的状态</li>
</ol>
<ul>
<li>移动本地库HEAD指针</li>
</ul>
<ol start="3">
<li>mixed：回滚后，不仅移动了本地库的指针，同时暂存区的东西也没了，即上次添加到暂存区的文件没了</li>
</ol>
<ul>
<li>移动本地库HEAD指针</li>
<li>重置暂存区</li>
</ul>
<ol start="4">
<li>keep：回滚后，本地代码就是你回退版本的代码，而暂存区是没有做任何改变的</li>
</ol>
<ul>
<li>移动本地库HEAD指针</li>
<li>暂存区不变</li>
<li>重置工作区</li>
</ul>
<h2 id="撤销某个commit">撤销某个commit</h2>
<p>当我们想要撤销某个commit时，可以通过右键点击提交历史记录，选择revert commit</p>
<p><img src="23.png" alt=""></p>
<h2 id="合并某个commit">合并某个commit</h2>
<p>当我们想要合并某个分支的某个提交内容时，可以cherry-pick选定某个commit或某个commit的部分文件</p>
<p><img src="25.png" alt=""></p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git（2-常用命令）</title>
    <url>/blog/2024/12/14/Java/%E5%B7%A5%E4%BD%9C%E6%8A%80%E5%B7%A7/Git/Git%EF%BC%882-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%89/</url>
    <content><![CDATA[<h2 id="配置">配置</h2>
<h3 id="配置文件">配置文件</h3>
<p>Git 有三个主要的配置文件：三个配置文件的优先级是 1 &lt; 2 &lt; 3</p>
<ol>
<li>系统全局配置（system）：包含了适用于系统所有用户和所有仓库（项目）的配置信息，存放在 Git 安装目录下：C:\Program Files\Git\etc\gitconfig。</li>
<li>用户全局配置（global）：当前系统用户的全局配置，存放用户目录：C:\Users\[系统用户名]\.gitconfig。</li>
<li>仓库/项目配置（local）：仓库（项目）的特定配置，存放在项目目录下.git/config</li>
</ol>
<h3 id="设置用户信息">设置用户信息</h3>
<ol>
<li>git config --global <a href="http://user.name">user.name</a> “用户名”：设置用户名</li>
<li>git config --global user.email “邮箱”：设置邮箱</li>
<li>git config --list：查看 git 配置信息</li>
<li>git config --list --global：查询当前用户全局配置</li>
<li>git config --system --list：查看系统配置</li>
</ol>
<h3 id="忽略-gitignore">忽略.gitignore</h3>
<p>工作目录中的文件并不是全都需要纳入版本管理，如日志、临时文件、私有配置文件等不需要也不能纳入版本管理，那该怎么办呢？</p>
<p>在工作区根目录下创建.gitignore 文件，文件中配置不需要进行版本管理的文件、文件夹。.gitignore 文件本身是被纳入版本管理的，可以共享。有如下规则：</p>
<ol>
<li>#符号开头为注释。</li>
<li>可以使用 Linux 通配符。</li>
</ol>
<ul>
<li>星号（*）：代表任意多个字符，</li>
<li>问号（？）：代表一个字符，</li>
<li>方括号（[abc]）：代表可选字符范围，</li>
<li>大括号（{string1, string2,…}）：代表可选的字符串等。</li>
</ul>
<ol start="3">
<li>感叹号（!）开头：表示例外规则，将不被忽略。</li>
<li>路径分隔符（/f）开头：，表示要忽略根目录下的文件 f。</li>
<li>路径分隔符（f/）结尾：，表示要忽略文件夹 f 下面的所有文件。</li>
</ol>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="params">#</span>为注释</span><br><span class="line">*.txt <span class="params">#</span>忽略所有“.txt”结尾的文件</span><br><span class="line">!lib.txt <span class="params">#</span>lib.txt除外</span><br><span class="line">/temp <span class="params">#</span>仅忽略项目根目录下的temp文件,不包括其它目录下的temp，如不包括“src/temp”</span><br><span class="line">build/ <span class="params">#</span>忽略build/目录下的所有文件</span><br><span class="line">doc/*.txt <span class="params">#</span>会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span><br></pre></td></tr></table></figure>
<h2 id="查看状态信息">查看状态信息</h2>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>指令</strong></th>
<th style="text-align:left"><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">git --version</td>
<td style="text-align:left">查看 git 版本</td>
</tr>
<tr>
<td style="text-align:left">git status</td>
<td style="text-align:left">查看本地仓库状态，比较常用的指令，加参数 <code>-s</code> 简洁模式</td>
</tr>
<tr>
<td style="text-align:left">git [指令] -h</td>
<td style="text-align:left">查看指令帮助信息</td>
</tr>
<tr>
<td style="text-align:left">git [指令] --help</td>
<td style="text-align:left">打开指令详细帮助页面</td>
</tr>
</tbody>
</table>
<p><img src="1.png" alt=""></p>
<h2 id="代码-仓库管理">代码/仓库管理</h2>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>指令</strong></th>
<th style="text-align:left"><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">git init [文件目录]</td>
<td style="text-align:left">初始化创建 Git 仓库，如果不指定 [文件目录]，则在当前目录创建。</td>
</tr>
<tr>
<td style="text-align:left">git add [file1] [file2]</td>
<td style="text-align:left">添加文件到暂存区，包括修改的文件、新增的文件</td>
</tr>
<tr>
<td style="text-align:left">git add [dir]</td>
<td style="text-align:left">同上，添加目录到暂存区，包括子目录</td>
</tr>
<tr>
<td style="text-align:left">git add .</td>
<td style="text-align:left">同上，添加所有修改、新增文件（未跟踪）到暂存区</td>
</tr>
<tr>
<td style="text-align:left">git rm [file]</td>
<td style="text-align:left">删除工作区文件，并且将这次删除放入暂存区</td>
</tr>
<tr>
<td style="text-align:left">git commit -m ‘说明’</td>
<td style="text-align:left">提交变更，参数 <code>-m</code> 设置提交的描述信息，应该正确提交，不带该参数会进入说明编辑模式</td>
</tr>
<tr>
<td style="text-align:left">git commit -a</td>
<td style="text-align:left">参数 <code>-a</code>，表示直接从工作区提交到版本库，略过了 <code>git add</code> 步骤，不包括新增的文件</td>
</tr>
<tr>
<td style="text-align:left">git commit [file]</td>
<td style="text-align:left">提交暂存区的指定文件到仓库区</td>
</tr>
<tr>
<td style="text-align:left">git commit --amend -m</td>
<td style="text-align:left">使用一次新的 <code>commit</code>，替代上一次提交，会修改 <code>commit</code> 的 <code>hash</code> 值（id）</td>
</tr>
<tr>
<td style="text-align:left">git cherry-pick [commit]</td>
<td style="text-align:left">拣选提交，复制一个特定的提交到当前分支，而不管这个提交在哪个分支</td>
</tr>
<tr>
<td style="text-align:left">git log -n20</td>
<td style="text-align:left">查看日志(最近 20 条)，不带参数 <code>-n</code> 则显示所有日志</td>
</tr>
<tr>
<td style="text-align:left">git log -n20 --oneline</td>
<td style="text-align:left">参数“<code>--oneline</code>”可以让日志输出更简洁（一行）</td>
</tr>
<tr>
<td style="text-align:left">git log -n20 --graph</td>
<td style="text-align:left">参数“<code>--graph</code>”可视化显示分支关系</td>
</tr>
<tr>
<td style="text-align:left">git log --follow [file]</td>
<td style="text-align:left">显示某个文件的版本历史</td>
</tr>
<tr>
<td style="text-align:left">git blame [file]</td>
<td style="text-align:left">以列表形式显示指定文件的修改记录</td>
</tr>
<tr>
<td style="text-align:left">git reflog</td>
<td style="text-align:left">查看所有可用的历史版本记录（实际是 HEAD 变更记录），包含被回退的记录（重要）</td>
</tr>
</tbody>
</table>
<ol>
<li>git init：在当前文件下初始化仓库，之后在该目录下会出现一个.git 文件夹，这个是 Git 来跟踪管理版本库的</li>
</ol>
<p><img src="2.png" alt=""></p>
<ol start="2">
<li>git add 文件：添加文件到工作区（使用 git add .命令，则表示把当前目录下的所有文件全部添加到工作区）</li>
</ol>
<p><img src="3.png" alt=""></p>
<ol start="3">
<li>git log：查看历史记录（显示你所提交的日志）</li>
</ol>
<p><img src="4.png" alt=""></p>
<ol start="4">
<li>git reflog：查看历史记录（只显示版本号和提交信息）</li>
</ol>
<p><img src="5.png" alt=""></p>
<h2 id="查看修改信息">查看修改信息</h2>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>指令</strong></th>
<th style="text-align:left"><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">git diff</td>
<td style="text-align:left">查看暂存区和工作区的差异</td>
</tr>
<tr>
<td style="text-align:left">git diff [file]</td>
<td style="text-align:left">同上，指定文件</td>
</tr>
<tr>
<td style="text-align:left">git diff --cached</td>
<td style="text-align:left">查看已暂存的改动，就是暂存区与新版本 <code>HEAD</code> 进行比较</td>
</tr>
<tr>
<td style="text-align:left">git diff --staged</td>
<td style="text-align:left">同上</td>
</tr>
<tr>
<td style="text-align:left">git diff --cached [file]</td>
<td style="text-align:left">同上，指定文件</td>
</tr>
<tr>
<td style="text-align:left">git diff HEAD</td>
<td style="text-align:left">查看已暂存的+未暂存的所有改动，就是与最新版本 <code>HEAD</code> 进行比较</td>
</tr>
<tr>
<td style="text-align:left">git diff HEAD~</td>
<td style="text-align:left">同上，与上一个版本比较。<code>HEAD~</code> 表示上一个版本，<code>HEAD~10</code> 为最近第 10 个版本</td>
</tr>
<tr>
<td style="text-align:left">git diff [id] [id]</td>
<td style="text-align:left">查看两次提交之间的差异</td>
</tr>
<tr>
<td style="text-align:left">git diff [branch]</td>
<td style="text-align:left">查看工作区和分支直接的差异</td>
</tr>
</tbody>
</table>
<p><img src="6.png" alt=""></p>
<h2 id="暂存区管理">暂存区管理</h2>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>指令</strong></th>
<th style="text-align:left"><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">git stash</td>
<td style="text-align:left">把未提交内容隐藏起来，包括未暂存、已暂存。 等以后恢复现场后继续工作</td>
</tr>
<tr>
<td style="text-align:left">git stash list</td>
<td style="text-align:left">查看所有被隐藏的内容列表</td>
</tr>
<tr>
<td style="text-align:left">git stash pop</td>
<td style="text-align:left">恢复被隐藏的内容，同时删除隐藏记录</td>
</tr>
<tr>
<td style="text-align:left">git stash save “message”</td>
<td style="text-align:left">同 <code>git stash</code>，可以备注说明 <code>message</code></td>
</tr>
<tr>
<td style="text-align:left">git stash apply</td>
<td style="text-align:left">恢复被隐藏的文件，但是隐藏记录不删除</td>
</tr>
<tr>
<td style="text-align:left">git stash drop</td>
<td style="text-align:left">删除隐藏记录</td>
</tr>
</tbody>
</table>
<h2 id="远程仓库管理">远程仓库管理</h2>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>指令</strong></th>
<th style="text-align:left"><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">git clone [git 地址]</td>
<td style="text-align:left">从远程仓库克隆到本地（当前目录）</td>
</tr>
<tr>
<td style="text-align:left">git remote -v</td>
<td style="text-align:left">查看所有远程仓库，不带参数 <code>-v</code> 只显示名称</td>
</tr>
<tr>
<td style="text-align:left">git remote show [remote]</td>
<td style="text-align:left">显示某个远程仓库的信息</td>
</tr>
<tr>
<td style="text-align:left">git remote add [name] [url]</td>
<td style="text-align:left">增加一个新的远程仓库，并命名</td>
</tr>
<tr>
<td style="text-align:left">git remote rename [old] [new]</td>
<td style="text-align:left">修改远程仓库名称</td>
</tr>
<tr>
<td style="text-align:left">git remote rm [remote-name]</td>
<td style="text-align:left">删除远程仓库</td>
</tr>
<tr>
<td style="text-align:left">git pull [remote] [branch]</td>
<td style="text-align:left">取回远程仓库的变化，并与本地版本合并</td>
</tr>
<tr>
<td style="text-align:left">git pull</td>
<td style="text-align:left">同上，针对当前分支</td>
</tr>
<tr>
<td style="text-align:left">git pull --rebase</td>
<td style="text-align:left">使用 rebase 的模式进行合并</td>
</tr>
<tr>
<td style="text-align:left">git fetch [remote]</td>
<td style="text-align:left">获取远程仓库的所有变动到本地仓库，不会自动合并！需要手动合并</td>
</tr>
<tr>
<td style="text-align:left">git push</td>
<td style="text-align:left">推送当前分支到远程仓库</td>
</tr>
<tr>
<td style="text-align:left">git push [remote] [branch]</td>
<td style="text-align:left">推送本地当前分支到远程仓库的指定分支</td>
</tr>
<tr>
<td style="text-align:left">git push [remote] --force/-f</td>
<td style="text-align:left">强行推送当前分支到远程仓库，即使有冲突，⚠️ 很危险！</td>
</tr>
<tr>
<td style="text-align:left">git push [remote] --all</td>
<td style="text-align:left">推送所有分支到远程仓库</td>
</tr>
<tr>
<td style="text-align:left">git push –u</td>
<td style="text-align:left">参数 <code>–u</code> 表示与远程分支建立关联，第一次执行的时候用，后面就不需要了</td>
</tr>
<tr>
<td style="text-align:left">git push origin --delete [branch-name]</td>
<td style="text-align:left">删除远程分支</td>
</tr>
</tbody>
</table>
<h2 id="分支管理">分支管理</h2>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>指令</strong></th>
<th style="text-align:left"><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">git branch</td>
<td style="text-align:left">列出所有本地分支，加参数 <code>-v</code> 显示详细列表，下同</td>
</tr>
<tr>
<td style="text-align:left">git branch -r</td>
<td style="text-align:left">列出所有远程分支</td>
</tr>
<tr>
<td style="text-align:left">git branch -a</td>
<td style="text-align:left">列出所有本地分支和远程分支，用不同颜色区分</td>
</tr>
<tr>
<td style="text-align:left">git branch [branch-name]</td>
<td style="text-align:left">新建一个分支，但依然停留在当前分支</td>
</tr>
<tr>
<td style="text-align:left">git branch -d dev</td>
<td style="text-align:left">删除 <code>dev</code> 分支，-D（大写）强制删除</td>
</tr>
<tr>
<td style="text-align:left">git branch [branch] [commit]</td>
<td style="text-align:left">新建一个分支，指向指定 <code>commit id</code></td>
</tr>
<tr>
<td style="text-align:left">git branch --track [branch] [remote-branch]</td>
<td style="text-align:left">新建一个分支，与指定的远程分支建立关联</td>
</tr>
<tr>
<td style="text-align:left">git branch --set-upstream [branch] [remote-branch]</td>
<td style="text-align:left">在现有分支与指定的远程分支之间建立跟踪关联：</td>
</tr>
<tr>
<td style="text-align:left">git branch --set-upstream hotfix remote/hotfix</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">git checkout -b dev</td>
<td style="text-align:left">从当前分支创建并切换到 <code>dev</code> 分支</td>
</tr>
<tr>
<td style="text-align:left">git checkout -b feature1 dev</td>
<td style="text-align:left">从本地 <code>dev</code> 分支代码创建一个 <code>feature1</code> 分支，并切换到新分支</td>
</tr>
<tr>
<td style="text-align:left">git checkout -b hotfix remote hotfix</td>
<td style="text-align:left">从远端 <code>remote</code> 的 <code>hotfix</code> 分支创建本地 <code>hotfix</code> 分支</td>
</tr>
<tr>
<td style="text-align:left">git checkout [branch-name]</td>
<td style="text-align:left">切换到指定分支，并更新工作区</td>
</tr>
<tr>
<td style="text-align:left">git checkout .</td>
<td style="text-align:left">撤销工作区的（未暂存）修改，把暂存区恢复到工作区。</td>
</tr>
<tr>
<td style="text-align:left">git checkout HEAD .</td>
<td style="text-align:left">撤销工作区、暂存区的修改，用 <code>HEAD</code> 指向的当前分支最新版本替换</td>
</tr>
<tr>
<td style="text-align:left">git merge [branch]</td>
<td style="text-align:left">合并指定分支到当前分支</td>
</tr>
<tr>
<td style="text-align:left">git merge --no-ff dev</td>
<td style="text-align:left">合并 <code>dev</code> 分支到当前分支，参数 <code>--no-ff</code> 禁用快速合并模式</td>
</tr>
<tr>
<td style="text-align:left">git rebase master</td>
<td style="text-align:left">将当前分支变基合并到 <code>master</code> 分支</td>
</tr>
<tr>
<td style="text-align:left">git switch master</td>
<td style="text-align:left">切换到已有的 <code>master</code> 分支</td>
</tr>
<tr>
<td style="text-align:left">git switch -c dev</td>
<td style="text-align:left">创建并切换到新的 <code>dev</code> 分支</td>
</tr>
</tbody>
</table>
<h2 id="标签管理">标签管理</h2>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>指令</strong></th>
<th style="text-align:left"><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">git tag</td>
<td style="text-align:left">查看标签列表</td>
</tr>
<tr>
<td style="text-align:left">git tag -l ‘a*’</td>
<td style="text-align:left">查看名称是“a”开头的标签列表，带查询参数</td>
</tr>
<tr>
<td style="text-align:left">git show [tagname]</td>
<td style="text-align:left">查看标签信息</td>
</tr>
<tr>
<td style="text-align:left">git tag [tagname]</td>
<td style="text-align:left">创建一个标签，默认标签是打在最新提交的 commit 上的</td>
</tr>
<tr>
<td style="text-align:left">git tag [tagname] [commit id]</td>
<td style="text-align:left">新建一个 tag 在指定 commit 上</td>
</tr>
<tr>
<td style="text-align:left">git tag -a v5.1 -m’v5.1 版本’</td>
<td style="text-align:left">创建标签 <code>v5.1.1039</code>，<code>-a</code> 指定标签名，<code>-m</code> 指定说明文字</td>
</tr>
<tr>
<td style="text-align:left">git tag -d [tagname]</td>
<td style="text-align:left">删除本地标签</td>
</tr>
<tr>
<td style="text-align:left">git checkout v5.1.1039</td>
<td style="text-align:left">切换标签，同切换分支</td>
</tr>
<tr>
<td style="text-align:left">git push [remote] v5.1</td>
<td style="text-align:left">推送标签，标签不会默认随代码推送推送到服务端</td>
</tr>
<tr>
<td style="text-align:left">git push [remote] --tags</td>
<td style="text-align:left">提交所有 tag</td>
</tr>
</tbody>
</table>
<h2 id="撤销变更">撤销变更</h2>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>指令</strong></th>
<th style="text-align:left"><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">git checkout .</td>
<td style="text-align:left">撤销工作区的（未暂存）修改，把暂存区恢复到工作区。不影响暂存区，如果没暂存，则撤销所有工作区修改</td>
</tr>
<tr>
<td style="text-align:left">git checkout [file]</td>
<td style="text-align:left">同上，<code>file</code> 指定文件</td>
</tr>
<tr>
<td style="text-align:left">git checkout HEAD .</td>
<td style="text-align:left">撤销工作区、暂存区的修改，用 <code>HEAD</code> 指向的当前分支最新版本替换工作区、暂存区</td>
</tr>
<tr>
<td style="text-align:left">git checkout HEAD [file]</td>
<td style="text-align:left">同上，<code>file</code> 指定文件</td>
</tr>
<tr>
<td style="text-align:left">git reset</td>
<td style="text-align:left">撤销暂存区状态，同 <code>git reset HEAD</code>，不影响工作区</td>
</tr>
<tr>
<td style="text-align:left">git reset HEAD [file]</td>
<td style="text-align:left">同上，指定文件 <code>file</code>，<code>HEAD</code> 可省略</td>
</tr>
<tr>
<td style="text-align:left">git reset [commit]</td>
<td style="text-align:left">回退到指定版本，清空暂存区，不影响工作区。工作区需要手动 <code>git checkout</code> 签出</td>
</tr>
<tr>
<td style="text-align:left">git reset --soft [commit]</td>
<td style="text-align:left">移动分支 <code>master</code>、<code>HEAD</code> 到指定的版本，不影响暂存区、工作区，需手动 <code>git checkout</code> 签出更新</td>
</tr>
<tr>
<td style="text-align:left">git reset --hard HEAD</td>
<td style="text-align:left">撤销工作区、暂存区的修改，用当前最新版</td>
</tr>
<tr>
<td style="text-align:left">git reset --hard HEAD~</td>
<td style="text-align:left">回退到上一个版本，并重置工作区、暂存区内容。</td>
</tr>
<tr>
<td style="text-align:left">git reset --hard [commit]</td>
<td style="text-align:left">回退到指定版本，并重置工作区、暂存区内容。</td>
</tr>
<tr>
<td style="text-align:left">git revert [commit]</td>
<td style="text-align:left">撤销一个提交，会用一个新的提交（原提交的逆向操作）来完成撤销操作，如果已 <code>push</code> 则重新 <code>push</code> 即可</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
